{"_id":"Curve","projectName":"default","arguments":"points","specification":"Represents a curve as a sequence of points. No dependencies.","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Represents a curve with an array of points.\n * @constructor\n * @param {Array} [points] - An optional array of points to initialize the curve.\n */\n","code":"function Curve(points) {\n  this.points = points || [];\n  this.getPoints = function() { return this.points; };\n  this.setPoint = function(i, point) {\n    if (i >= 0 && i < this.points.length) {\n      this.points[i] = point;\n    }\n  };\n}","lastGenerated":"2024-06-25T02:45:42.205Z"}
{"_id":"Edge","projectName":"default","arguments":"vertex1, vertex2","specification":"Represents an edge in BREP. Depends on (Vertex).","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Represents an edge in a graph or geometric structure connecting two vertices.\n * @constructor\n * @param {number[]} vertex1 - The coordinates of the first vertex as an array [x, y, z].\n * @param {number[]} vertex2 - The coordinates of the second vertex as an array [x, y, z].\n * @property {Object} vertexA - The first vertex with its coordinates.\n * @property {Object} vertexB - The second vertex with its coordinates.\n */","code":"function Edge(vertex1, vertex2) {\n  this.vertexA = {x: vertex1[0], y: vertex1[1], z: vertex1[2]};\n  this.vertexB = {x: vertex2[0], y: vertex2[1], z: vertex2[2]};\n}","lastGenerated":"2024-06-25T02:46:16.693Z"}
{"_id":"Face","projectName":"default","arguments":"surface, loops","specification":"Represents a face in BREP. Depends on (Surface, Loop).","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Constructs a new face by finding intersections between edges of the surface and given loops.\n * @param {Object} surface - The surface object containing edges and shells.\n * @param {Array<{vertex1: Object, vertex2: Object}>} loops - An array of loop objects with vertices.\n */\n","code":"function Face(surface, loops) {\n  const vertices = [];\n  for (let i = 0; i < loops.length; i++) {\n    const edge = {v1: loops[i].vertex1, v2: loops[i].vertex2};\n    for (const edge2 of surface.edges) {\n      if ((edge.v1.x === edge2.v1.x && edge.v1.y === edge2.v1.y && edge.v1.z === edge2.v1.z &&\n           edge.v2.x === edge2.v2.x && edge.v2.y === edge2.v2.y && edge.v2.z === edge2.v2.z) ||\n          (edge.v1.x === edge2.v2.x && edge.v1.y === edge2.v2.y && edge.v1.z === edge2.v2.z &&\n           edge.v2.x === edge2.v1.x && edge.v2.y === edge2.v1.y && edge.v2.z === edge2.v1.z)) {\n        const intersection = {x: (edge.v1.x + edge.v2.x) / 2, y: (edge.v1.y + edge.v2.y) / 2, z: (edge.v1.z + edge.v2.z) / 2};\n        vertices.push(intersection);\n      }\n    }\n  }\n  surface.shells[0].faces.push({vertices});\n}","lastGenerated":"2024-06-25T02:47:29.840Z"}
{"_id":"Loop","projectName":"default","arguments":"edges","specification":"Represents a loop (a closed sequence of edges) in BREP. Depends on (Edge).","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Creates a loop from an array of edges by checking for intersections and ensuring each edge is unique in the loop.\n * @param {Array<[number, number]>} edges - An array of edges represented as pairs of coordinates.\n * @returns {Array<[[number, number], [number, number]]>} An array of unique edge pairs forming a loop.\n */","code":"function Loop(edges){let result=[];for(let i=0;i<edges.length;i++){const currentEdge=edges[i];const nextEdge=edges[(i+1)%edges.length];if(!findIntersection(currentEdge,nextEdge)){result.push([currentEdge,nextEdge]);}else{console.error(`Intersection detected between edge ${i} and edge ${(i+1)%edges.length}. Loop creation interrupted.`);break;}}return result;}","lastGenerated":"2024-06-25T02:48:01.704Z"}
{"_id":"Matrix","projectName":"default","arguments":"elements","specification":"Represents a transformation matrix. No dependencies.","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Represents a matrix with elements provided during construction.\n * @constructor\n * @param {Array<Array<number>>} elements - The elements of the matrix.\n *\n * @method times\n * @param {Matrix} other - The matrix to multiply with.\n * @returns {Matrix} A new Matrix instance representing the product of this and the other matrix.\n */","code":"function Matrix(elements) {\n  this.elements = elements;\n  this.times = function(other) {\n    var result = [];\n    for (var i = 0; i < elements.length; i++) {\n      result[i] = [];\n      for (var j = 0; j < other.elements[0].length; j++) {\n        var sum = 0;\n        for (var k = 0; k < elements[0].length; k++) {\n          sum += elements[i][k] * other.elements[k][j];\n        }\n        result[i].push(sum);\n      }\n    }\n    return new Matrix(result);\n  };\n}","lastGenerated":"2024-06-25T02:48:45.662Z"}
{"_id":"Point","projectName":"default","arguments":"x, y, z","specification":"Represents a point in 3D space. No dependencies.","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Represents a point in three-dimensional space with x, y, and z coordinates.\n * @constructor\n * @param {number} x - The x coordinate of the point.\n * @param {number} y - The y coordinate of the point.\n * @param {number} z - The z coordinate of the point.\n * @returns {Object} An object with properties x, y, and z representing the coordinates of the point.\n */","code":"function Point(x, y, z) {\n  return { x, y, z };\n}","lastGenerated":"2024-06-25T02:49:10.952Z"}
{"_id":"Shell","projectName":"default","arguments":"faces","specification":"Represents a shell (a closed collection of faces) in BREP. Depends on (Face).","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Represents a shell containing multiple faces.\n * @constructor\n * @param {Array<Object>} faces - The initial faces to be included in the shell.\n */\nfunction Shell(faces) {\n  this._faces = Array.isArray(faces) ? faces : [faces];\n}\n\n/**\n * Retrieves the array of faces contained within the shell.\n * @returns {Array<Object>} - The array of faces.\n */\nShell.prototype.getFaces = function() {\n  return this._faces;\n};\n\n/**\n * Sets a new array of faces for the shell.\n * @param {Array<Object>} newFaces - The new array of faces to be set.\n */\nShell.prototype.setFaces = function(newFaces) {\n  this._faces = newFaces instanceof Array ? newFaces : [newFaces];\n};\n\n/**\n * Creates a clone of the shell, including all its faces.\n * @returns {Shell} - A new Shell object with the same faces as the original.\n */\nShell.prototype.clone = Shell.prototype.cloneCurve = function() {\n  return new Shell(this._faces);\n};","code":"function Shell(faces) {\n  this._faces = Array.isArray(faces) ? faces : [faces];\n}\n\nShell.prototype.getFaces = function() {\n  return this._faces;\n};\n\nShell.prototype.setFaces = function(newFaces) {\n  this._faces = newFaces instanceof Array ? newFaces : [newFaces];\n};\n\nShell.prototype.clone = Shell.prototype.cloneCurve = function() {\n  return new Shell(this._faces);\n};","lastGenerated":"2024-06-25T02:50:17.453Z"}
{"_id":"Solid","projectName":"default","arguments":"shells","specification":"Represents a solid in BREP. Depends on (Shell).","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Calculates the volume of a solid object represented by an array of shells.\n * @param {Array} Shells - An array of shell objects, each with methods to calculate its area and normal vector.\n * @returns {number} The calculated volume of the solid.\n */","code":"function Solid(Shells) {\n  let volume = 0;\n  for (let i = 0; i < Shells.length; i++) {\n      const shell = Shells[i];\n      volume += shell.area() * Math.abs(shell.normal().dot(new Point(0, 0, 1)));\n  }\n  return volume;\n}","lastGenerated":"2024-06-25T02:50:44.552Z"}
{"_id":"Surface","projectName":"default","arguments":"controlPoints","specification":"Represents a surface defined by control points. No dependencies.","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Represents a surface defined by an array of control points.\n * @constructor\n * @param {Array<{x: number, y: number, z: number}>} controlPoints - The array of control points defining the surface.\n */\n\nfunction Surface(controlPoints) {\n    this.controlPoints = controlPoints;\n}\n\n/**\n * Generates a curve based on the control points of the surface.\n * @returns {Array<{x: number, y: number, z: number}>} An array of objects representing the curve segments between consecutive control points.\n */\nSurface.prototype.getCurve = function() {\n    let curve = [];\n    for (let i = 0; i < this.controlPoints.length - 1; i++) {\n        curve.push({x: this.controlPoints[i].x, y: this.controlPoints[i].y, z: this.controlPoints[i].z});\n        curve.push({x: this.controlPoints[i].x, y: this.controlPoints[i].y, z: this.controlPoints[i + 1].z});\n    }\n    return curve;\n};","code":"function Surface(controlPoints) {\n    this.controlPoints = controlPoints;\n}\n\nSurface.prototype.getCurve = function() {\n    let curve = [];\n    for (let i = 0; i < this.controlPoints.length - 1; i++) {\n        curve.push({x: this.controlPoints[i].x, y: this.controlPoints[i].y, z: this.controlPoints[i].z});\n        curve.push({x: this.controlPoints[i].x, y: this.controlPoints[i].y, z: this.controlPoints[i + 1].z});\n    }\n    return curve;\n};","lastGenerated":"2024-06-25T02:51:58.130Z"}
{"_id":"Vector","projectName":"default","arguments":"x, y, z","specification":"Represents a vector in 3D space. No dependencies.","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Represents a three-dimensional vector with x, y, and z components.\n * @constructor\n * @param {number} x - The x coordinate of the vector.\n * @param {number} y - The y coordinate of the vector.\n * @param {number} z - The z coordinate of the vector.\n */\nfunction Vector(x, y, z) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n}\n\n/**\n * Adds two vectors and returns a new vector as the result.\n * @param {Vector} vector2 - The vector to add to the current vector.\n * @returns {Vector} A new Vector object representing the sum of the two vectors.\n */\nVector.prototype.add = function(vector2) {\n    return new Vector(this.x + vector2.x, this.y + vector2.y, this.z + vector2.z);\n};\n\n/**\n * Subtracts another vector from the current vector and returns a new vector as the result.\n * @param {Vector} vector2 - The vector to subtract from the current vector.\n * @returns {Vector} A new Vector object representing the difference of the two vectors.\n */\nVector.prototype.subtract = function(vector2) {\n    return new Vector(this.x - vector2.x, this.y - vector2.y, this.z - vector2.z);\n};","code":"function Vector(x, y, z) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n}\n\nVector.prototype.add = function(vector2) {\n    return new Vector(this.x + vector2.x, this.y + vector2.y, this.z + vector2.z);\n};\n\nVector.prototype.subtract = function(vector2) {\n    return new Vector(this.x - vector2.x, this.y - vector2.y, this.z - vector2.z);\n};","lastGenerated":"2024-06-25T02:53:19.191Z"}
{"_id":"Vertex","projectName":"default","arguments":"point","specification":"Represents a vertex in BREP. Depends on (Point).","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Represents a vertex in three-dimensional space with coordinates (x, y, z).\n * @constructor\n * @param {Object} point - The point object containing the x, y, and z coordinates.\n * @param {number} point.x - The x coordinate of the vertex.\n * @param {number} point.y - The y coordinate of the vertex.\n * @param {number} point.z - The z coordinate of the vertex.\n */","code":"function Vertex(point) {\n  this.x = point.x;\n  this.y = point.y;\n  this.z = point.z;\n}","lastGenerated":"2024-06-25T02:53:49.624Z"}
{"_id":"addEdge","projectName":"default","arguments":"solid, edge","specification":"Adds an edge to a solid. Depends on (Solid, Edge).","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Adds an edge to a solid by creating new vertices and adding them to the solid's vertex list.\n * @param {Object} solid - The solid object to which the edge will be added.\n * @param {Object} edge - The edge object containing vertex information.\n * @param {Object} edge.vertex1 - The first vertex of the edge.\n * @param {number} edge.vertex1.x - The x-coordinate of the first vertex.\n * @param {number} edge.vertex1.y - The y-coordinate of the first vertex.\n * @param {number} edge.vertex1.z - The z-coordinate of the first vertex.\n * @param {Object} edge.vertex2 - The second vertex of the edge.\n * @param {number} edge.vertex2.x - The x-coordinate of the second vertex.\n * @param {number} edge.vertex2.y - The y-coordinate of the second vertex.\n * @param {number} edge.vertex2.z - The z-coordinate of the second vertex.\n * @param {Array} solid.vertices - The array of vertices in the solid to which new vertices will be added.\n */","code":"function addEdge(solid, edge) {\n  let newVertex1 = {x: edge.vertex1.x, y: edge.vertex1.y, z: edge.vertex1.z};\n  let newVertex2 = {x: edge.vertex2.x, y: edge.vertex2.y, z: edge.vertex2.z};\n  \n  solid.vertices.push(newVertex1);\n  solid.vertices.push(newVertex2);\n}","lastGenerated":"2024-06-25T02:54:58.186Z"}
{"_id":"addFace","projectName":"default","arguments":"shell, face","specification":"Adds a face to a shell. Depends on (Shell, Face).","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Adds a face to the shell's faces array and returns the modified shell object.\n * @param {Object} shell - The shell object which contains the faces array.\n * @param {string} face - The face string to be added to the faces array.\n * @returns {Object} - The updated shell object with the new face added.\n */","code":"function addFace(shell, face) {\n  shell.faces = [...shell.faces, face];\n  return shell;\n}","lastGenerated":"2024-06-25T02:55:19.894Z"}
{"_id":"addLoop","projectName":"default","arguments":"face, loop","specification":"Adds a loop to a face. Depends on (Face, Loop).","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Adds a loop to the given face object.\n * If the face does not have a 'loops' property or it is not an array, initializes it as an empty array.\n * Then pushes the provided loop into the 'loops' array of the face.\n * @param {Object} face - The face object to which the loop will be added.\n * @param {Array} loop - The loop to add to the face.\n */","code":"function addLoop(face, loop) {\n  if (!(\"loops\" in face) || !Array.isArray(face.loops)) face.loops = [];\n  face.loops.push(loop);\n}","lastGenerated":"2024-06-25T02:55:49.482Z"}
{"_id":"addShell","projectName":"default","arguments":"solid, shell","specification":"Adds a shell to a solid. Depends on (Solid, Shell).","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Adds a shell to the given solid object.\n * @param {Object} solid - The original solid object which contains at least properties x, y, z and shells.\n * @param {Object} shell - The shell object to be added to the solid's shells array.\n * @returns {Object} newSolid - A new solid object with the additional shell in its shells array.\n */","code":"function addShell(solid, shell) {\n    var newSolid = {x: solid.x, y: solid.y, z: solid.z, shells: [...solid.shells, shell]};\n    return newSolid;\n}","lastGenerated":"2024-06-25T02:56:16.671Z"}
{"_id":"addVectors","projectName":"default","arguments":"v1, v2","specification":"Adds two vectors. Depends on (Vector).","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Adds two vectors component-wise and returns the result as a new vector.\n * @param {Object} v1 - The first vector with properties x, y, and z.\n * @param {Object} v2 - The second vector with properties x, y, and z.\n * @returns {Object} A new vector that is the sum of v1 and v2.\n */","code":"function addVectors(v1, v2) {\n    return {x: v1.x + v2.x, y: v1.y + v2.y, z: v1.z + v2.z};\n}","lastGenerated":"2024-06-25T02:56:47.445Z"}
{"_id":"addVertex","projectName":"default","arguments":"solid, vertex","specification":"Adds a vertex to a solid. Depends on (Solid, Vertex).","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Adds a vertex to the last shell in the given solid object.\n * @param {Object} solid - The solid object containing shells and vertices.\n * @param {Array} vertex - The vertex array to be added to the last shell's faces.\n */","code":"function addVertex(solid, vertex) {\n    solid.shell.push({});\n    var lastShell = solid.shell[solid.shell.length - 1];\n    if (!lastShell.faces) {\n        lastShell.faces = [];\n    }\n    lastShell.faces.push({ vertices: [vertex] });\n}","lastGenerated":"2024-06-25T02:57:16.227Z"}
{"_id":"cloneCurve","projectName":"default","arguments":"curve","specification":"Creates a copy of a curve. Depends on (Curve).","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Clones a curve by creating a deep copy of its points.\n * @param {Object} curve - The original curve object containing an array of point objects with x, y, and z properties.\n * @returns {Object} - Returns a new object containing the cloned points array.\n */","code":"function cloneCurve(curve) {\n    const clonedPoints = curve.points.map(point => ({ x: point.x, y: point.y, z: point.z }));\n    return { points: clonedPoints };\n}","lastGenerated":"2024-06-25T02:57:42.065Z"}
{"_id":"cloneMatrix","projectName":"default","arguments":"matrix","specification":"Creates a copy of a matrix. Depends on (Matrix).","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Creates a deep clone of the given matrix.\n * @param {Array<Array<number>>} matrix - The input matrix to be cloned.\n * @returns {{x: Array<Array<number>>, y: Array<Array<number>>, z: Array<Array<number>}} - A new object containing three copies of the original matrix.\n */","code":"function cloneMatrix(matrix) {\n    var result = [];\n    for (var i = 0; i < matrix.length; i++) {\n        result[i] = [];\n        for (var j = 0; j < matrix[0].length; j++) {\n            result[i][j] = matrix[i][j];\n        }\n    }\n    return {x: result, y: result, z: result};\n}","lastGenerated":"2024-06-25T02:58:19.365Z"}
{"_id":"clonePoint","projectName":"default","arguments":"point","specification":"Creates a copy of a point. Depends on (Point).","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Clones a point object by creating a new object with the same x, y, and z properties as the original.\n * @param {Object} point - The point object to be cloned.\n * @param {number} point.x - The x-coordinate of the point.\n * @param {number} point.y - The y-coordinate of the point.\n * @param {number} point.z - The z-coordinate of the point (optional).\n * @returns {Object} A new object with the same properties as the original point.\n */","code":"function clonePoint(point) {\n  return {x: point.x, y: point.y, z: point.z};\n}","lastGenerated":"2024-06-25T02:58:48.885Z"}
{"_id":"cloneSolid","projectName":"default","arguments":"solid","specification":"Creates a copy of a solid. Depends on (Solid).","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Clones the given solid by creating a deep copy of its shells and their associated faces, loops, edges, and vertices.\n * @param {Solid} solid - The solid to be cloned.\n * @returns {Solid} A new Solid instance with cloned shells and their contents.\n */","code":"function cloneSolid(solid) {\n    const shells = solid.shells.map(shell => ({\n        faces: shell.faces.map(face => ({\n            controlPoints: face.controlPoints,\n            loops: face.loops.map(loop => ({\n                edges: loop.edges.length ? [new Edge(loop.edges[0])] : [],\n                vertices: []\n            }))\n        }))\n    }));\n    return new Solid([], shells);\n}","lastGenerated":"2024-06-25T02:59:29.077Z"}
{"_id":"cloneSurface","projectName":"default","arguments":"surface","specification":"Creates a copy of a surface. Depends on (Surface).","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Clones a surface array and its nested points, preserving the x, y, z coordinates of each point.\n * @param {Array<Array<{x: number, y: number, z: number}>>} surface - The surface to be cloned.\n * @returns {{data: Array<Array<{x: number, y: number, z: number}>}} - A clone of the input surface with nested points.\n */","code":"function cloneSurface(surface) {\n  let result = [];\n  for (let i = 0; i < surface.length; i++) {\n    let point = [];\n    for (let j = 0; j < surface[i].length; j++) {\n      point.push({x: surface[i][j].x, y: surface[i][j].y, z: surface[i][j].z});\n    }\n    result.push(point);\n  }\n  return {data: result};\n}","lastGenerated":"2024-06-25T03:00:17.734Z"}
{"_id":"cloneVector","projectName":"default","arguments":"vector","specification":"Creates a copy of a vector. Depends on (Vector).","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Clones a vector object by creating a new object with the same x, y, and z properties as the original.\n * @param {Object} vector - The vector object to be cloned.\n * @param {number} vector.x - The x-coordinate of the vector.\n * @param {number} vector.y - The y-coordinate of the vector.\n * @param {number} vector.z - The z-coordinate of the vector.\n * @returns {Object} A new object with the same properties as the input vector.\n */","code":"function cloneVector(vector) {\n  return { x: vector.x, y: vector.y, z: vector.z };\n}","lastGenerated":"2024-06-25T03:00:53.862Z"}
{"_id":"createCone","projectName":"default","arguments":"baseRadius, topRadius, height","specification":"Creates a cone with given base radius, top radius, and height. Depends on (Surface, Solid, extrude, revolve).","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Generates a cone with specified base and top radii and height.\n * @param {number} baseRadius - The radius of the base of the cone.\n * @param {number} topRadius - The radius of the top of the cone.\n * @param {number} height - The vertical distance from the base to the top of the cone.\n * @returns {[Array<[number, number, number]>, Array<{faces: [{x: number, y: number}], shell: number}>]} An array containing two elements:\n *  1. A list of points representing the surface of the cone.\n *  2. A list of faces that form the solid structure of the cone.\n */","code":"function createCone(baseRadius, topRadius, height) {\n  const surface = [];\n  for (let i = 0; i <= 1; i++) {\n    for (let j = 0; j < 2; j++) {\n      if (j === 0) {\n        let z = baseRadius;\n      } else {\n        let z = height - topRadius * Math.sqrt(3) / 2;\n      }\n      surface.push([i, j, z]);\n    }\n  }\n  const solid = [];\n  solid.push({faces: [[{x: 0, y: 0}, {x: 1, y: 0}, {x: 0.5, y: Math.sqrt(3) / 2}]], shell: 0});\n  return [surface, solid];\n}","lastGenerated":"2024-06-25T03:01:59.405Z"}
{"_id":"createCylinder","projectName":"default","arguments":"radius, height","specification":"Creates a cylinder with a given radius and height. Depends on (Surface, Solid, extrude, revolve).","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Creates a cylinder with the specified radius and height.\n * @param {number} radius - The radius of the cylinder's circular bases.\n * @param {number} height - The height of the cylinder.\n * @returns {Object} - A mesh representing the cylinder, composed of an extruded base profile and a revolved top profile.\n */","code":"function createCylinder(radius, height) {\n    const topBase = {x:0, y:0, z:height/2};\n    const bottomBase = {x:0, y:0, z:-height/2};\n    \n    const baseProfile = [{x: radius, y: 0}, {x: -radius, y: 0}];\n    const topProfile = [{x: radius, y: height}, {x: -radius, y: height}];\n    return extrude(baseProfile, {x:0,y:1,z:0}, height).union(revolve(topProfile, {x:0,y:1,z:0}, Math.PI*2));\n}","lastGenerated":"2024-06-25T03:02:51.427Z"}
{"_id":"createPrism","projectName":"default","arguments":"base, height","specification":"Creates a prism with a given base and height. Depends on (Curve, Surface, Solid, extrude).","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Creates a prism with the given base and height.\n * @param {Object} base - The base point of the prism, represented as an object with x, y, and z coordinates.\n * @param {number} base.x - The x-coordinate of the base point.\n * @param {number} base.y - The y-coordinate of the base point.\n * @param {number} height - The height of the prism.\n * @returns {Object} - A solid object representing the prism, with shell and surfaces properties.\n */","code":"function createPrism(base, height) {\n  const basePoint = {x:base.x, y:base.y, z:0};\n  const topPoint = {x:base.x, y:base.y, z:height};\n  const faceSurface = [{points:[basePoint, topPoint], curve:[1]}];\n  const shell = [{surfaces:faceSurface, curves:[]}];\n  const solid = [{shell:shell}];\n  extrude({profile:faceSurface[0]}, {axis: 'z'}, height);\n  return solid[0];\n}","lastGenerated":"2024-06-25T03:03:44.278Z"}
{"_id":"createSphere","projectName":"default","arguments":"radius","specification":"Creates a sphere with a given radius. Depends on (Surface, Solid, revolve).","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Creates a sphere object with the given radius.\n * @param {number} radius - The radius of the sphere.\n * @returns {Object} - A solid object representing the sphere, including its type and contents.\n */","code":"function createSphere(radius) {\n    const controlPoints = [{x:-radius, y:-radius*Math.sqrt(3)/2, z:0},{x:radius, y:-radius*Math.sqrt(3)/2, z:0},{x:0, y:radius*Math.sqrt(3)/2, z:0}];\n    const surface = {controlPoints};\n    return {type:\"Solid\", contents:[{type:\"Shell\", contents:[{type:\"Loop\", edges:[]}, {type:\"Face4\", vertices:controlPoints}]}]};\n}","lastGenerated":"2024-06-25T03:04:21.295Z"}
{"_id":"createTorus","projectName":"default","arguments":"majorRadius, minorRadius","specification":"Creates a torus with given major and minor radii. Depends on (Surface, Solid, revolve).","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Creates a torus shape given the major and minor radii.\n * @param {number} majorRadius - The radius of the tube around the central axis.\n * @param {number} minorRadius - The radius of the cross-section of the tube.\n * @returns {{surface: Array<[Object, Object]>}} - An object containing an array of line segments forming the surface of the torus.\n */","code":"function createTorus(majorRadius, minorRadius) {\n    const profilePoints = [];\n    for (let theta = 0; theta < Math.PI * 2; theta += Math.PI / 150) {\n        let phi = Math.acos(Math.cos(theta) - 0.5);\n        let x = majorRadius + minorRadius * Math.sin(phi);\n        let y = minorRadius * Math.cos(phi);\n        profilePoints.push({x, y});\n    }\n    const surface = [];\n    for (let i = 0; i < profilePoints.length; i++) {\n        surface.push([profilePoints[i], profilePoints[(i + 1) % profilePoints.length]]);\n    }\n    return {surface};\n}","lastGenerated":"2024-06-25T03:05:12.351Z"}
{"_id":"crossProduct","projectName":"default","arguments":"v1, v2","specification":"Computes the cross product of two vectors. Depends on (Vector).","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Computes the cross product of two vectors in three-dimensional space.\n * @param {Object} v1 - The first vector with properties x, y, and z.\n * @param {Object} v2 - The second vector with properties x, y, and z.\n * @returns {Object} A new vector representing the cross product of v1 and v2, with properties x, y, and z.\n */","code":"function crossProduct(v1, v2) { let x = v1.y * v2.z - v1.z * v2.y; let y = v1.z * v2.x - v1.x * v2.z; let z = v1.x * v2.y - v1.y * v2.x; return { x: x, y: y, z: z }; }","lastGenerated":"2024-06-25T03:05:48.891Z"}
{"_id":"dotProduct","projectName":"default","arguments":"v1, v2","specification":"Computes the dot product of two vectors. Depends on (Vector).","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Calculates the dot product of two vectors in three-dimensional space.\n * @param {Object} v1 - The first vector with properties x, y, and z.\n * @param {Object} v2 - The second vector with properties x, y, and z.\n * @returns {number} The dot product of the two vectors.\n */","code":"function dotProduct(v1, v2) {\n    return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n}","lastGenerated":"2024-06-25T03:06:13.921Z"}
{"_id":"evaluateCurve","projectName":"default","arguments":"curve, t","specification":"Evaluates a point on the curve at parameter t. Depends on (Curve, Point).","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Evaluates a curve at a given parameter t to find the point on the curve corresponding to that parameter.\n * @param {Object} curve - The curve object containing an array of points representing the curve.\n * @param {number} t - The parameter value along the curve, ranging from 0 to the total curve length.\n * @returns {Object} - A vector representing the point on the curve corresponding to the parameter t.\n */\n```","code":"function evaluateCurve(curve, t) {\n    let currentPoint = curve.points[0];\n    for (let i = 1; i < curve.points.length; i++) {\n        const nextPoint = curve.points[i];\n        if (t <= calculateDistanceBetweenPoints(currentPoint, nextPoint) / getCurveLength(curve)) {\n            return createVectorFromPoints(currentPoint, nextPoint).scale((t / calculateDistanceBetweenPoints(currentPoint, nextPoint)) * getVectorDirection(currentPoint, nextPoint));\n        }\n    }\n    currentPoint = curve.points[curve.points.length - 1];\n    const remainingDistance = getCurveLength(curve) - calculateDistanceBetweenPoints(currentPoint, t);\n    return createVectorFromPoints(currentPoint, interpolatePointOnCurve(t, currentPoint, curve.points[curve.points.length - 1])).scale((remainingDistance / getVectorDirection(currentPoint, curve.points[curve.points.length - 1])).magnitude()) * getVectorDirection(currentPoint, curve.points[curve.points.length - 1]);\n}\n\nfunction calculateDistanceBetweenPoints(p1, p2) {\n    return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2) + Math.pow(p2.z - p1.z, 2));\n}\n\nfunction getCurveLength(curve) {\n    let length = 0;\n    for (let i = 1; i < curve.points.length; i++) {\n        length += calculateDistanceBetweenPoints(curve.points[i - 1], curve.points[i]);\n    }\n    return length;\n}\n\nfunction createVectorFromPoints(p1, p2) {\n    return { x: p2.x - p1.x, y: p2.y - p1.y, z: p2.z - p1.z };\n}\n\nfunction getVectorDirection(p1, p2) {\n    let vector = createVectorFromPoints(p1, p2);\n    let magnitude = Math.sqrt(Math.pow(vector.x, 2) + Math.pow(vector.y, 2) + Math.pow(vector.z, 2));\n    return { x: vector.x / magnitude, y: vector.y / magnitude, z: vector.z / magnitude };\n}\n\nfunction interpolatePointOnCurve(t, p1, p2) {\n    let ratio = t / calculateDistanceBetweenPoints(p1, p2);\n    return { x: p1.x + (p2.x - p1.x) * ratio, y: p1.y + (p2.y - p1.y) * ratio, z: p1.z + (p2.z - p1.z) * ratio };\n}","lastGenerated":"2024-06-25T03:08:27.716Z"}
{"_id":"evaluateSurface","projectName":"default","arguments":"surface, u, v","specification":"Evaluates a point on the surface at parameters u and v. Depends on (Surface, Point).","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Evaluates the surface at given parameters u and v.\n * @param {Surface} surface - The surface to evaluate.\n * @param {number} u - The parameter along the U direction.\n * @param {number} v - The parameter along the V direction.\n * @returns {Point} A new Point object representing the evaluated surface at (u, v).\n */","code":"function evaluateSurface(surface, u, v) {\n    const controlPoints = surface.controlPoints;\n    \n    if (u === 0 && v === 0) return new Point();\n    \n    const uVector = [];\n    for (let i = 0; i < controlPoints.length - 1; i++) {\n        uVector.push([controlPoints[i][0] - controlPoints[i + 1][0], controlPoints[i][1] - controlPoints[i + 1][1], controlPoints[i][2] - controlPoints[i + 1][2]]);\n    }\n    \n    const point = new Point();\n    for (let i = 0; i < surface.loops.length; i++) {\n        let localU = 0;\n        let localV = 0;\n        for (let j = 0; j < surface.loops[i].length - 1; j++) {\n            localU += surface.loops[i][j][0] * uVector[j][0];\n            localV += surface.loops[i][j][0] * (evaluateCurve(surface.loops[i], v)[0] - surface.loops[i][j][0]) + surface.loops[i][j][1] * (evaluateCurve(surface.loops[i], v)[1] - surface.loops[i][j][1]);\n        }\n        \n        point = new Point(localU, localV, 0);\n    }\n    \n    let cv = [0, 0, 0];\n    for (let i = 0; i < uVector.length - 1; i++) {\n        cv[0] += (uVector[i][1] * localV - uVector[i][2] * (evaluateCurve(surface.loops[0], v)[1] - surface.loops[0][i][1]) + uVector[i][2] * (evaluateCurve(surface.loops[0], v)[2] - surface.loops[0][i][2])) / localU;\n        cv[1] += (uVector[i][2] * localV - uVector[i][0] * (evaluateCurve(surface.loops[0], v)[2] - surface.loops[0][i][2]) + uVector[i][0] * (evaluateCurve(surface.loops[0], v)[0] - surface.loops[0][i][0])) / localU;\n        cv[2] += (uVector[i][0] * localV - uVector[i][1] * (evaluateCurve(surface.loops[0], v)[0] - surface.loops[0][i][0]) + uVector[i][1] * (evaluateCurve(surface.loops[0], v)[1] - surface.loops[0][i][1])) / localU;\n    }\n    \n    return point.add(new Point(cv[0], cv[1], cv[2])).scale(localU);\n}","lastGenerated":"2024-06-25T03:10:54.767Z"}
{"_id":"extrude","projectName":"default","arguments":"profile, direction, distance","specification":"Creates a solid by extruding a profile along a direction for a certain distance. Depends on (Curve, Surface, Solid, translate, addFace, addShell).","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Extrudes a profile along a specified direction by a given distance to generate a shell.\n * @param {Array<{x: number, y: number, z: number}>} profile - The array of points defining the profile to be extruded.\n * @param {{x: number, y: number, z: number}} direction - The vector representing the direction in which to extrude the profile.\n * @param {number} distance - The total distance to extrude the profile along the given direction.\n * @returns {[Array<[number, number, number]>, Array<[number, number, number]>]} An array containing two arrays:\n *                                                                            1. The original curve of points defining the profile.\n *                                                                            2. The shell of points generated by extruding the profile along the direction.\n */","code":"function extrude(profile, direction, distance) {\n  let curve = [];\n  for (let i = 0; i < profile.length; i++) {\n    curve.push([profile[i].x, profile[i].y, profile[i].z]);\n  }\n  let shell = [];\n  let translationVector = [direction.x, direction.y, direction.z];\n  \n  for (let t = 0; t <= distance; t++) {\n    let point = [];\n    for (let i = 0; i < curve.length; i++) {\n      point.push(curve[i][0] + translationVector[0], \n                 curve[i][1] + translationVector[1], \n                 curve[i][2] + translationVector[2]);\n    }\n    shell.push(point);\n  }\n  \n  return [curve, shell];\n}","lastGenerated":"2024-06-25T03:12:06.714Z"}
{"_id":"findIntersection","projectName":"default","arguments":"edge1, edge2","specification":"Finds the intersection point of two edges. Depends on (Edge, Point, Vector, subtractVectors, crossProduct).","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Finds the intersection point between two edges in 3D space, if it exists.\n * @param {Array<Array<number>>} edge1 - The first edge represented by an array of two points (start and end).\n * @param {Array<Array<number>>} edge2 - The second edge represented by an array of two points (start and end).\n * @returns {Vertex|null} - The intersection point as a Vertex object, or null if there is no intersection.\n */","code":"function findIntersection(edge1, edge2) {\n    const v1 = subtractVectors(subtractVectors(edge1[1], edge1[0]), edge2[0]);\n    const v2 = crossProduct(subtractVectors(edge2[1], edge1[0]), subtractVectors(edge2[0], edge1[0]));\n    let d0 = dotProduct(v1, v2);\n\n    if (Math.abs(d0) < Number.EPSILON) return null; // No intersection\n\n    let s = -dotProduct(subtractVectors(edge1[0], edge2[0]), v2) / d0;\n    let t = -dotProduct(subtractVectors(edge1[0], edge2[1]), v2) / d0;\n\n    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {\n        return Vertex.fromPoint(addVectors(edge1[0], multiplyVectorByScalar(v1, s)));\n    } else {\n        return null; // No intersection within bounds\n    }\n}","lastGenerated":"2024-06-25T03:13:18.597Z"}
{"_id":"intersect","projectName":"default","arguments":"solid1, solid2","specification":"Computes the intersection of two solids. Depends on (Solid, Shell, Face, Loop, Edge, Vertex).","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Computes the intersection points between two solid shells by checking each pair of faces for coplanarity and finding their intersections.\n * @param {Object} solid1 - The first solid with shells containing faces to be intersected.\n * @param {Array<Object>} solid1.shells - An array of shell objects, each containing an array of face objects.\n * @param {Object} solid2 - The second solid with shells containing faces to be intersected.\n * @param {Array<Object>} solid2.shells - An array of shell objects, each containing an array of face objects.\n * @returns {Array<Object>} intersections - An array of intersection points between the faces of the two solids. Each object contains a property 'points' which is an array of intersection point coordinates.\n */","code":"function intersect(solid1, solid2) {\n    let intersections = [];\n    for (let i = 0; i < solid1.shells.length; i++) {\n        for (let j = 0; j < solid2.shells.length; j++) {\n            let currentShell1 = solid1.shells[i];\n            let currentShell2 = solid2.shells[j];\n            for (let k = 0; k < currentShell1.faces.length; k++) {\n                let face1 = currentShell1.faces[k];\n                for (let l = 0; l < currentShell2.faces.length; l++) {\n                    let face2 = currentShell2.faces[l];\n                    if (face1.isCoplanarWith(face2) && findIntersection(face1, face2).points.length > 0) {\n                        let intersectionPoints = findIntersection(face1, face2);\n                        intersections.push({ points: intersectionPoints });\n                    }\n                }\n            }\n        }\n    }\n    return intersections;\n}","lastGenerated":"2024-06-25T03:14:26.504Z"}
{"_id":"loft","projectName":"default","arguments":"profiles","specification":"Creates a solid by lofting between multiple profiles. Depends on (Curve, Surface, Solid, evaluateCurve, addFace, addShell).","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Generates a solid object from an array of profiles using lofting technique.\n * @param {Array<Object>} profiles - An array of profile objects, each representing a cross-section of the solid along its length.\n * @returns {Object} - A solid object with type \"Solid\" and an array of shells.\n */","code":"function loft(profiles) {\n    let shells = [];\n    for (let i = 0; i < profiles.length - 1; i++) {\n        let curveFrom = [profiles[i], projToProfileAxis(profiles[i + 1], profiles[i])];\n        let curveTo = evaluateCurve(curveFrom, t);\n        \n        let surface = {controlPoints: [], loops: [{vertices: [addVertex(shells[0], curveFrom), addVertex(shells[0], curveTo)]}]};;\n        \n        shells.push(createShell(surface));\n    }\n    \n    return {type: \"Solid\", shells: shells};\n}","lastGenerated":"2024-06-25T03:14:59.200Z"}
{"_id":"multiplyMatrices","projectName":"default","arguments":"m1, m2","specification":"Multiplies two matrices. Depends on (Matrix).","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Multiplies two matrices together.\n * @param {number[][]} m1 - The first matrix to multiply, represented as a 2D array of numbers.\n * @param {number[][]} m2 - The second matrix to multiply, represented as a 2D array of numbers.\n * @returns {number[][]} A new matrix that is the result of multiplying m1 and m2.\n */","code":"function multiplyMatrices(m1, m2) {\n  let result = [];\n  for (let i = 0; i < m1.length; i++) {\n    result[i] = [];\n    for (let j = 0; j < m2[0].length; j++) {\n      let sum = 0;\n      for (let k = 0; k < m1[0].length; k++) {\n        sum += m1[i][k] * m2[k][j];\n      }\n      result[i][j] = sum;\n    }\n  }\n  return result;\n}","lastGenerated":"2024-06-25T03:15:40.253Z"}
{"_id":"multiplyMatrixVector","projectName":"default","arguments":"matrix, vector","specification":"Multiplies a matrix by a vector. Depends on (Matrix, Vector).","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Multiplies a matrix by a vector and returns the resulting vector.\n * @param {Object} matrix - The matrix to be multiplied, represented as an object with x, y, and z properties each containing arrays of numbers.\n * @param {Object} vector - The vector to be multiplied, represented as an object with x, y, and z properties each containing a number.\n * @returns {Object} - The resulting vector from the multiplication, represented as an object with x, y, and z properties each containing a number.\n */","code":"function multiplyMatrixVector(matrix, vector) {\n  let result = {x: 0, y: 0, z: 0};\n  for (let i = 0; i < matrix.length; i++) {\n    let sum = {x: 0, y: 0, z: 0};\n    for (let j = 0; j < vector.y.length; j++) {\n      if (j < vector.y.length - 1) {\n        sum.x += matrix[i][j] * vector.y[j];\n        sum.y += matrix[i][j + 1] * vector.y[j];\n        sum.z += matrix[i][j + 2] * vector.y[j];\n      } else {\n        sum.x += matrix[i][j] * vector.y[j];\n      }\n    }\n    result.x += sum.x;\n    result.y += sum.y;\n    result.z += sum.z;\n  }\n  return {x: result.x, y: result.y, z: result.z};\n}","lastGenerated":"2024-06-25T03:16:57.586Z"}
{"_id":"on","jsdoc":" /**\n * Calculates the Euclidean distance from the origin (0, 0, 0) to a point defined by its x, y, and z coordinates.\n * @param {Object} p - An object containing properties x, y, and z representing the coordinates of the point.\n * @param {number} p.x - The x-coordinate of the point.\n * @param {number} p.y - The y-coordinate of the point.\n * @param {number} p.z - The z-coordinate of the point.\n * @returns {number} - The Euclidean distance from the origin to the specified point, or NaN if any of x, y, or z are missing.\n */","code":"function on(p) { if (p.x && p.y && p.z) { return Math.sqrt(Math.pow(p.x - 0, 2) + Math.pow(p.y - 0, 2) + Math.pow(p.z - 0, 2)); } else { return NaN; }}","lastGenerated":"2024-06-25T02:45:17.734Z","errorLogs":"","needsGeneration":"false"}
{"_id":"projectPointOnSurface","projectName":"default","arguments":"point, surface","specification":"Projects a point onto a surface. Depends on (Point, Surface, evaluateSurface).","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Evaluates the surface and projects a point onto it by linearly combining the basis vectors of the surface.\n * @param {Object} point - The point to be projected, containing x, y, and z coordinates.\n * @param {Object} surface - The surface object, containing u and v components representing basis vectors.\n * @returns {Object} An object with x, y, and z properties representing the projected point on the surface.\n */","code":"function projectPointOnSurface(point, surface) {\n  const [u, v] = evaluateSurface(surface);\n  return { x: u * point.x + v * surface.u, y: u * point.y + v * surface.v, z: u * point.z };\n}","lastGenerated":"2024-06-25T03:17:31.103Z"}
{"_id":"revolve","projectName":"default","arguments":"profile, axis, angle","specification":"Creates a solid by revolving a profile around an axis by a given angle. Depends on (Curve, Surface, Solid, rotate, addFace, addShell).","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Generates a solid by revolving a profile around an axis by a given angle.\n * @param {Array<Point>} profile - The array of points defining the profile to be revolved.\n * @param {Vector} axis - The vector representing the axis around which the profile will be revolved.\n * @param {number} angle - The angle in radians by which the profile will be rotated.\n * @returns {Solid} A solid object generated by revolving the given profile around the specified axis by the given angle.\n */","code":"function revolve(profile, axis, angle) {\n  let curve = Curve([profile]);\n  let matrix = new Matrix();\n  let rotatedProfile = [];\n  for (let i = 0; i < profile.length; i++) {\n    let vector = Vector.subtract(new Point(), profile[i]);\n    rotatedProfile.push(Matrix.multiplyVector(matrix, vector));\n  }\n  let solid = Solid();\n  for (let loop of curve.loops) {\n    let shell = Shell();\n    for (let face of loop.faces) {\n      addFace(shell, new Face(rotatedProfile, face.controlPoints));\n    }\n    addShell(solid, shell);\n  }\n  return solid;\n}","lastGenerated":"2024-06-25T03:18:18.687Z"}
{"_id":"rotate","projectName":"default","arguments":"point, axis, angle","specification":"Rotates a point around an axis by an angle. Depends on (Point, Vector, Matrix, multiplyMatrixVector).","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Rotates a point around an axis by a specified angle.\n * @param {Object} point - The point to be rotated, represented as an object with x, y, and z properties.\n * @param {Object} axis - The axis of rotation, represented as an object with x, y, and z properties.\n * @param {number} angle - The angle in radians by which the point should be rotated around the axis.\n * @returns {Object} - A new object representing the rotated point, with x, y, and z properties updated according to the rotation.\n */","code":"function rotate(point, axis, angle) {\n    var v = {x: point.x - axis.x, y: point.y - axis.y, z: point.z - axis.z};\n    var uMag = Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z);\n    var xAxis = {x: axis.x / uMag, y: 0, z: 0};\n    var yAxis = {x: 0, y: axis.y / uMag, z: 0};\n    var zAxis = {x: 0, y: 0, z: axis.z / uMag};\n\n    var xRotationMatrix = [\n        [Math.cos(angle), -Math.sin(angle)*v.x/uMag, Math.sin(angle)*v.z/uMag],\n        [Math.sin(angle)*v.y/uMag + Math.cos(angle)*(axis.y/uMag), Math.cos(angle) - Math.sin(angle)*axis.y/uMag*v.z/uMag, -Math.sin(angle)*v.z/uMag + Math.cos(angle)*(axis.z/uMag)],\n        [-Math.sin(angle)*v.z/uMag + Math.cos(angle)*(axis.z/uMag), 0, Math.cos(angle) - Math.sin(angle)*axis.z/uMag*v.y/uMag]\n    ];\n\n    var yRotationMatrix = [\n        [Math.cos(angle), 0, -Math.sin(angle)],\n        [0, Math.cos(angle), 0],\n        [Math.sin(angle), 0, Math.cos(angle)]\n    ];\n\n    var zRotationMatrix = [\n        [Math.cos(angle), -Math.sin(angle)*v.x/uMag, Math.sin(angle)*v.y/uMag],\n        [Math.sin(angle)*v.z/uMag + Math.cos(angle)*(axis.z/uMag), 0,\n         -Math.sin(angle)*v.y/uMag + Math.cos(angle)*(axis.y/uMag)],\n        [-Math.sin(angle)*v.x/uMag + Math.cos(angle)*(axis.x/uMag), 0, Math.cos(angle) - Math.sin(angle)*axis.x/uMag*v.y/uMag]\n    ];\n\n    var x = point.x;\n    var y = point.y;\n    var z = point.z;\n\n    var rotatedX = (xRotationMatrix[0][0]*x + xRotationMatrix[0][1]*(y-axis.y) + xRotationMatrix[0][2]*(z-axis.z)) * uMag + axis.x;\n    var rotatedY = (xRotationMatrix[1][0]*(x-axis.x) + yRotationMatrix[1][1]*y + zRotationMatrix[1][2]*(z-axis.z)) * uMag + axis.y;\n    var rotatedZ = (xRotationMatrix[2][0]*(x-axis.x) + xRotationMatrix[2][1]*(y-axis.y) + zRotationMatrix[2][2]*(z-axis.z)) * uMag + axis.z;\n\n    return {x: rotatedX, y: rotatedY, z: rotatedZ};\n}","lastGenerated":"2024-06-25T03:21:11.387Z"}
{"_id":"scale","projectName":"default","arguments":"point, scaleFactor","specification":"Scales a point by a factor. Depends on (Point).","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Scales the given point by a specified scale factor and returns a new scaled point object.\n * @param {Object} point - The original point to be scaled, containing x, y, and z coordinates.\n * @param {number} scaleFactor - The scaling factor to apply to each coordinate of the point.\n * @returns {Object} A new object representing the scaled point, with properties x, y, and z all multiplied by the scale factor.\n */","code":"function scale(point, scaleFactor) { return { x: point.x * scaleFactor, y: point.y * scaleFactor, z: point.z * scaleFactor }; }","lastGenerated":"2024-06-25T03:21:38.110Z"}
{"_id":"subtract","projectName":"default","arguments":"solid1, solid2","specification":"Computes the difference between two solids. Depends on (Solid, Shell, Face, Loop, Edge, Vertex).","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Subtracts one solid from another by comparing each shell in the second solid and subtracting its loops from the corresponding shells in the first solid, then returning the result of the subtraction.\n * @param {Object} solid1 - The base solid to subtract from.\n * @param {Object} solid2 - The solid to subtract from the base solid.\n * @returns {Object} A new solid that is the result of subtracting solid2 from solid1.\n */","code":"function subtract(solid1, solid2) {\n    let shellDifference = new Shell();\n    \n    const clonedSolid1 = cloneSolid(solid1);\n    const clonedSolid2 = cloneSolid(solid2);\n    \n    for (const shell2 of Solids.getShells(clonedSolid2)) {\n        let loopDifference;\n        \n        for (const loop2 of Solids.getLoops(shell2)) {\n            let faceDifference = new Face();\n            \n            for (const face2 of Solids.getFaces(loop2)) {\n                let edgeDifference = [];\n                \n                const edges2 = Solids.getEdges(face2);\n                for (const edge2 of edges2) {\n                    if (!Solid.hasEdge(edgeDifference, edge2)) {\n                        let vertexDifference;\n                        \n                        const vertices2 = Solids.getVertices(edge2);\n                        for (const vertex2 of vertices2) {\n                            if (!Solid.hasVertex(vertexDifference, vertex2)) {\n                                let pointDifference;\n                                \n                                const points1 = Solids.getPoints(clonedSolid1);\n                                if (!points1.some(point => Vector.equals(vertex2, point))) {\n                                    pointDifference = new Point(vertex2.x, vertex2.y, vertex2.z);\n                                } else {\n                                    let existingPoint;\n                                    for (const point of points1) {\n                                        if (Vector.equals(vertex2, point)) {\n                                            existingPoint = point;\n                                            break;\n                                        }\n                                    }\n                                    \n                                    if (!existingPoint) continue;\n                                    \n                                    pointDifference = subtractVectors(point, existingPoint);\n                                }\n                                \n                                edgeDifference.push(pointDifference);\n                            }\n                        }\n                        \n                        faceDifference.addEdge(edgeDifference);\n                    }\n                }\n                \n                loopDifference = subtractLoops(loop2, loopDifference);\n            }\n            \n            shellDifference.addLoop(loopDifference);\n        }\n        \n        addShell(shellDifference, clonedSolid1);\n    }\n    \n    return subtractSolids(clonedSolid1, solid2);\n}","lastGenerated":"2024-06-25T03:23:29.409Z"}
{"_id":"subtractVectors","projectName":"default","arguments":"v1, v2","specification":"Subtracts one vector from another. Depends on (Vector).","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Subtracts the components of two vectors and returns a new vector with the results.\n * @param {Object} v1 - The first vector object with properties x, y, and z.\n * @param {Object} v2 - The second vector object with properties x, y, and z.\n * @returns {Object} A new vector object with components (xA: v1.x - v2.x, yA: v1.y - v2.y, zA: v1.z - v2.z).\n */","code":"function subtractVectors(v1, v2) {\n    return { xA: v1.x - v2.x, yA: v1.y - v2.y, zA: v1.z - v2.z };\n}","lastGenerated":"2024-06-25T03:24:01.684Z"}
{"_id":"sweep","projectName":"default","arguments":"profile, path","specification":"Creates a solid by sweeping a profile along a path. Depends on (Curve, Surface, Solid, evaluateCurve, addFace, addShell).","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Evaluates the curve defined by the given path and sweeps the profile along this curve to generate a solid object.\n * @param {Object} profile - The profile object used for sweeping.\n * @param {Array} path - The array of points defining the path of the sweep.\n * @returns {void}\n */","code":"function sweep(profile, path) {\n    const curve = evaluateCurve(path);\n    let solid = null;\n\n    for (let t of curve.getPoints()) {\n        const edge = new Edge(t.previousPoint, t.point);\n        if (!solid) {\n            solid = new Solid();\n        }\n        addFace(solid, profile, edge);\n        addShell(solid, profile, edge);\n    }\n}","lastGenerated":"2024-06-25T03:24:31.389Z"}
{"_id":"translate","projectName":"default","arguments":"point, vector","specification":"Translates a point by a vector. Depends on (Point, Vector, addVectors).","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Translates a point by adding the components of a vector to the corresponding coordinates of the point.\n * @param {Object} point - The original point object with properties x, y, and z.\n * @param {Object} vector - The translation vector object with properties x, y, and z.\n * @returns {Object} A new object representing the translated point with properties x, y, and z.\n */","code":"function translate(point, vector) {\n    let x = point.x + vector.x;\n    let y = point.y + vector.y;\n    let z = point.z + vector.z;\n    return {x, y, z};\n}","lastGenerated":"2024-06-25T03:24:59.020Z"}
{"_id":"union","projectName":"default","arguments":"solid1, solid2","specification":"Computes the union of two solids. Depends on (Solid, Shell, Face, Loop, Edge, Vertex).","needsGeneration":"true","errorLogs":"{\"index\":1744,\"lineNumber\":63,\"description\":\"Unexpected token ...\"}","jsdoc":" /**\n * Combines two solids by creating a new solid that is the union of both input solids.\n * @param {Solid} solid1 - The first solid to be combined.\n * @param {Solid} solid2 - The second solid to be combined.\n * @returns {Solid} A new Solid representing the union of the two input solids.\n */\nfunction union(solid1, solid2) {\n    let shells = [];\n    for (let i = 0; i < solid1.shells.length; i++) {\n        shells.push(cloneShell(solid1.shells[i]));\n    }\n    shells = addShells(shells, cloneShellArray(solid2.shells));\n\n    let faces = [];\n    for (let i = 0; i < solid1.faces.length; i++) {\n        faces.push(cloneFace(solid1.faces[i]));\n    }\n    for (let i = 0; i < solid2.faces.length; i++) {\n        faces.push(cloneFace(solid2.faces[i]));\n    }\n\n    let loops = [];\n    for (let i = 0; i < solid1.loops.length; i++) {\n        loops.push(cloneLoop(solid1.loops[i]));\n    }\n    for (let i = 0; i < solid2.loops.length; i++) {\n        loops.push(cloneLoop(solid2.loops[i]));\n    }\n\n    let edges = [];\n    for (let i = 0; i < solid1.edges.length; i++) {\n        edges.push(cloneEdge(solid1.edges[i], solid2.vertices));\n    }\n    for (let i = 0; i < solid2.edges.length; i++) {\n        edges.push(cloneEdge(solid2.edges[i], solid1.vertices, solid2.vertices));\n    }\n\n    let unionSolid = new Solid();\n    unionSolid.shells = shells;\n    unionSolid.faces = faces;\n    unionSolid.loops = loops;\n    unionSolid.edges = edges;\n    unionSolid.vertices = solid1.vertices.concat(solid2.vertices);\n\n    return unionSolid;\n}\n\n/**\n * Clones a shell by creating a new Shell and cloning all faces within it.\n * @param {Shell} shell - The shell to be cloned.\n * @returns {Shell} A new cloned shell with the same faces as the original.\n */\nfunction cloneShell(shell) {\n    let newShell = new Shell();\n    newShell.faces = shell.faces.map(cloneFace);\n    return newShell;\n}\n\n/**\n * Adds shells to a given array of shells, ensuring no duplicates based on face comparison.\n * @param {Array<Shell>} shells - The array of shells to which new shells will be added.\n * @param {Array<Shell>} shellArray - The array of shells to be added.\n * @returns {Array<Shell>} The updated array of shells with potential duplicates removed.\n */\nfunction addShells(shells, shellArray) {\n    for (let shell of shellArray) {\n        if (!shells.some(s => s.isSame(shell))) {\n            shells.push(shell);\n        }\n    }\n    return shells;\n}\n\n/**\n * Clones an array of shells by mapping each shell in the original array to a new cloned shell.\n * @param {Array<Shell>} shellArray - The array of shells to be cloned.\n * @returns {Array<Shell>} A new array of cloned shells.\n */\nfunction cloneShellArray(shellArray) {\n    return shellArray.map(cloneShell);\n}\n\n/**\n * Clones a face by creating a new Face and cloning all loops within it.\n * @param {Face} face - The face to be cloned.\n * @returns {Face} A new cloned face with the same loops as the original.\n */\nfunction cloneFace(face) {\n    let newFace = new Face();\n    newFace.loops = face.loops.map(loop => ({ ...loop }));\n    return newFace;\n}\n\n/**\n * Clones a loop by creating a new Loop and cloning all edges within it.\n * @param {Loop} loop - The loop to be cloned.\n * @returns {Loop} A new cloned loop with the same edges as the original.\n */\nfunction cloneLoop(loop) {\n    let newLoop = new Loop();\n    newLoop.edges = loop.edges.map(edge => ({ ...edge }));\n    return newLoop;\n}\n\n/**\n * Clones an edge by creating a new Edge and cloning all vertices within it, using provided vertices from two solids if necessary.\n * @param {Edge} edge - The edge to be cloned.\n * @param {Array<Vertex>} vertices1 - The vertices from the first solid used in the clone.\n * @param {Array<Vertex>} vertices2 - The vertices from the second solid used in the clone (optional).\n * @returns {Edge} A new cloned edge with the same vertices as the original, adjusted for potential missing vertices.\n */\nfunction cloneEdge(edge, vertices1, vertices2 = []) {\n    let vertices = vertices1.concat(vertices2);\n    let newEdge = new Edge();\n    newEdge.vertices = edge.vertices.map(v => ({ ...v }));\n    return newEdge;\n}","code":"function union(solid1, solid2) {\n    let shells = [];\n    for (let i = 0; i < solid1.shells.length; i++) {\n        shells.push(cloneShell(solid1.shells[i]));\n    }\n    shells = addShells(shells, cloneShellArray(solid2.shells));\n\n    let faces = [];\n    for (let i = 0; i < solid1.faces.length; i++) {\n        faces.push(cloneFace(solid1.faces[i]));\n    }\n    for (let i = 0; i < solid2.faces.length; i++) {\n        faces.push(cloneFace(solid2.faces[i]));\n    }\n\n    let loops = [];\n    for (let i = 0; i < solid1.loops.length; i++) {\n        loops.push(cloneLoop(solid1.loops[i]));\n    }\n    for (let i = 0; i < solid2.loops.length; i++) {\n        loops.push(cloneLoop(solid2.loops[i]));\n    }\n\n    let edges = [];\n    for (let i = 0; i < solid1.edges.length; i++) {\n        edges.push(cloneEdge(solid1.edges[i], solid2.vertices));\n    }\n    for (let i = 0; i < solid2.edges.length; i++) {\n        edges.push(cloneEdge(solid2.edges[i], solid1.vertices, solid2.vertices));\n    }\n\n    let unionSolid = new Solid();\n    unionSolid.shells = shells;\n    unionSolid.faces = faces;\n    unionSolid.loops = loops;\n    unionSolid.edges = edges;\n    unionSolid.vertices = solid1.vertices.concat(solid2.vertices);\n\n    return unionSolid;\n}\n\nfunction cloneShell(shell) {\n    let newShell = new Shell();\n    newShell.faces = shell.faces.map(cloneFace);\n    return newShell;\n}\n\nfunction addShells(shells, shellArray) {\n    for (let shell of shellArray) {\n        if (!shells.some(s => s.isSame(shell))) {\n            shells.push(shell);\n        }\n    }\n    return shells;\n}\n\nfunction cloneShellArray(shellArray) {\n    return shellArray.map(cloneShell);\n}\n\nfunction cloneFace(face) {\n    let newFace = new Face();\n    newFace.loops = face.loops.map(loop => ({ ...loop }));\n    return newFace;\n}\n\nfunction cloneLoop(loop) {\n    let newLoop = new Loop();\n    newLoop.edges = loop.edges.map(edge => ({ ...edge }));\n    return newLoop;\n}\n\nfunction cloneEdge(edge, vertices1, vertices2 = []) {\n    let vertices = vertices1.concat(vertices2);\n    let newEdge = new Edge();\n    newEdge.vertices = edge.vertices.map(v => ({ ...v }));\n    return newEdge;\n}","lastGenerated":"2024-06-26T01:09:52.506Z"}
