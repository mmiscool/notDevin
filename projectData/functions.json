{"_id":"applyChamfer","projectName":"default","arguments":"surface1, surface2, distance","specification":"Creates a chamfer between two surfaces. Depends on (intersectSurfaces, subtractSurface)","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Applies a chamfer to the intersection of two NURBS surfaces.\n *\n * This function calculates the intersection curve of two input surfaces and applies a chamfer by offsetting each\n * surface by the specified distance. The chamfer surface is created by lofting between the original intersection\n * curve and the new intersection curve of the offset surfaces. The chamfer is applied by subtracting the chamfer\n * surface from each of the original surfaces and then uniting the resulting surfaces.\n *\n * @param {NURBSSurface} surface1 - The first NURBS surface to apply the chamfer to.\n * @param {NURBSSurface} surface2 - The second NURBS surface to apply the chamfer to.\n * @param {number} distance - The distance by which to offset the surfaces to create the chamfer.\n * @returns {NURBSSurface} The resulting surface after applying the chamfer operation.\n */","code":"function applyChamfer(surface1, surface2, distance) {\n    var intersectionCurve = intersectSurfaces(surface1, surface2);\n    var offsetSurface1 = offsetSurface(surface1, -distance);\n    var offsetSurface2 = offsetSurface(surface2, -distance);\n    var chamferCurve = findIntersection(offsetSurface1, offsetSurface2);\n    var chamferSurface = loftNurbsSurfaces([\n        intersectionCurve,\n        chamferCurve\n    ]);\n    var resultSurface1 = booleanOperation(surface1, chamferSurface, 'subtract');\n    var resultSurface2 = booleanOperation(surface2, chamferSurface, 'subtract');\n    return booleanOperation(resultSurface1, resultSurface2, 'union');\n}","lastGenerated":"2024-10-26T23:03:52.124Z"}
{"_id":"applyFillet","projectName":"default","arguments":"surface1, surface2, radius","specification":"Applies a fillet between two surfaces. Depends on (offsetSurface, blendCurves)","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Applies a fillet between two given NURBS surfaces based on the specified radius.\n *\n * This function creates a fillet surface where two input surfaces intersect. It offsets\n * both surfaces by the negative of the specified radius, computes the intersection curve\n * between the offset surfaces, approximates a new curve through the intersection points,\n * and finally generates a lofted NURBS surface to form the fillet.\n *\n * @param {NURBSSurface} surface1 - The first NURBS surface to apply the fillet to.\n * @param {NURBSSurface} surface2 - The second NURBS surface to apply the fillet to.\n * @param {number} radius - The radius of the fillet to be applied between the two surfaces.\n * @returns {NURBSSurface} - A new NURBS surface representing the fillet between the two input surfaces.\n */","code":"function applyFillet(surface1, surface2, radius) {\n    var offsetSurface1 = offsetSurface(surface1, -radius);\n    var offsetSurface2 = offsetSurface(surface2, -radius);\n    var intersectionCurve = intersectSurfaces(offsetSurface1, offsetSurface2);\n    var blendCurve = approximateCurveThroughPoints(intersectionCurve);\n    var filletSurface = loftNurbsSurfaces([\n        blendCurve,\n        intersectionCurve\n    ]);\n    return filletSurface;\n}","lastGenerated":"2024-10-26T23:03:47.853Z"}
{"_id":"approximateCurveThroughPoints","projectName":"default","arguments":"points","specification":"Creates a NURBS curve approximating given points. Depends on (none)","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Approximates a NURBS curve through a given set of points.\n *\n * This function generates a NURBS curve by calculating control points and\n * knot vector based on the provided 3D points. The degree of the curve\n * is fixed at 3, making it a cubic NURBS curve.\n *\n * @param {Array<Object>} points - An array of objects representing the points\n *     through which the curve should be approximated. Each object should have\n *     `x`, `y`, and `z` properties representing its coordinates in 3D space.\n * @returns {Object} A NURBS curve represented by control points, degree, and knot vector.\n *     The return value is typically an object containing the computed control points,\n *     the degree of the curve, and the knot vector necessary for NURBS representation.\n *\n * @example\n * const points = [\n *   { x: 0, y: 0, z: 0 },\n *   { x: 1, y: 2, z: 1 },\n *   { x: 3, y: 5, z: 2 },\n *   { x: 6, y: 8, z: 3 }\n * ];\n * const nurbsCurve = approximateCurveThroughPoints(points);\n */","code":"function approximateCurveThroughPoints(points) {\n    var degree = 3;\n    var n = points.length - 1;\n    var knots = [];\n    var controlPoints = [];\n    for (var i = 0; i <= degree; i++) {\n        knots.push(0);\n    }\n    for (var i = 1; i <= n - degree; i++) {\n        knots.push(i / (n - degree + 1));\n    }\n    for (var i = 0; i <= degree; i++) {\n        knots.push(1);\n    }\n    for (var i = 0; i <= n; i++) {\n        controlPoints.push([\n            points[i].x,\n            points[i].y,\n            points[i].z\n        ]);\n    }\n    return createNurbsCurve(controlPoints, degree, knots);\n}","lastGenerated":"2024-10-26T23:03:19.023Z"}
{"_id":"booleanOperation","projectName":"default","arguments":"solid1, solid2, operationType","specification":"Performs boolean operations (union, difference, intersection) on BREP solids. Depends on (classifyPointInSolid, intersectSurfaces)","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Performs a boolean operation between two 3D solid objects.\n *\n * @param {Object} solid1 - The first solid object, consisting of a set of faces.\n * @param {Object} solid2 - The second solid object, consisting of a set of faces.\n * @param {string} operationType - The type of boolean operation to perform. Valid options are 'union', 'difference', and 'intersection'.\n * \n * @returns {Object} A new solid object resulting from the specified boolean operation between solid1 and solid2.\n * \n * @throws {Error} If the operationType provided is not one of 'union', 'difference', or 'intersection'.\n */","code":"function booleanOperation(solid1, solid2, operationType) {\n    function classifyPointInSolid(point, solid) {\n        var intersections = 0;\n        for (var i = 0; i < solid.faces.length; i++) {\n            var face = solid.faces[i];\n            for (var j = 0; j < face.edges.length; j++) {\n                var edge = face.edges[j];\n                if (intersectSurfaces({\n                        type: 'plane',\n                        equation: [\n                            point.x,\n                            point.y,\n                            point.z\n                        ]\n                    }, edge).length % 2 !== 0) {\n                    intersections++;\n                }\n            }\n        }\n        return intersections % 2 === 1 ? 'inside' : 'outside';\n    }\n    function union(solid1, solid2) {\n        var resultSolid = { faces: [] };\n        for (var i = 0; i < solid1.faces.length; i++) {\n            resultSolid.faces.push(solid1.faces[i]);\n        }\n        for (var i = 0; i < solid2.faces.length; i++) {\n            for (var j = 0; j < solid2.faces[i].edges.length; j++) {\n                var point = solid2.faces[i].edges[j].vertices[0];\n                if (classifyPointInSolid(point, solid1) === 'outside') {\n                    resultSolid.faces.push(solid2.faces[i]);\n                    break;\n                }\n            }\n        }\n        return resultSolid;\n    }\n    function difference(solid1, solid2) {\n        var resultSolid = { faces: [] };\n        for (var i = 0; i < solid1.faces.length; i++) {\n            for (var j = 0; j < solid1.faces[i].edges.length; j++) {\n                var point = solid1.faces[i].edges[j].vertices[0];\n                if (classifyPointInSolid(point, solid2) === 'outside') {\n                    resultSolid.faces.push(solid1.faces[i]);\n                    break;\n                }\n            }\n        }\n        return resultSolid;\n    }\n    function intersection(solid1, solid2) {\n        var resultSolid = { faces: [] };\n        for (var i = 0; i < solid1.faces.length; i++) {\n            for (var j = 0; j < solid1.faces[i].edges.length; j++) {\n                var point = solid1.faces[i].edges[j].vertices[0];\n                if (classifyPointInSolid(point, solid2) === 'inside') {\n                    resultSolid.faces.push(solid1.faces[i]);\n                    break;\n                }\n            }\n        }\n        return resultSolid;\n    }\n    if (operationType === 'union') {\n        return union(solid1, solid2);\n    } else if (operationType === 'difference') {\n        return difference(solid1, solid2);\n    } else if (operationType === 'intersection') {\n        return intersection(solid1, solid2);\n    } else {\n        throw new Error('Invalid operation type');\n    }\n}","lastGenerated":"2024-10-26T23:04:33.811Z"}
{"_id":"closestPointOnCurve","projectName":"default","arguments":"point, curve","specification":"Finds the closest point on a curve to a given point. Depends on (none)","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Computes the closest point on a NURBS curve to a given point in 3D space.\n *\n * @param {Object} point - The point in 3D space to find the closest point to. Should have properties x, y, and z representing its coordinates.\n * @param {Object} curve - The NURBS curve to evaluate. Should be an object containing the necessary properties to define a NURBS curve.\n * @returns {Object|null} - The point on the curve that is closest to the provided point. Returns null if no point is found.\n *\n * @function\n *\n * @description\n * This function calculates the point on a specified NURBS curve that is closest in distance to a given 3D point. \n * It does so by evaluating several points along the curve, calculating the distance from each to the given point, \n * and then identifying the one with the smallest distance. The curve is evaluated at discrete divisions \n * between the start (t = 0) and end (t = 1) for approximation.\n *\n * @see {@link evaluateNurbsCurve} for how the curve is evaluated at a certain parameter t.\n */","code":"function closestPointOnCurve(point, curve) {\n    var minDistance = Infinity;\n    var closestPoint = null;\n    var divisions = 100;\n    for (var i = 0; i <= divisions; i++) {\n        var t = i / divisions;\n        var curvePoint = evaluateNurbsCurve(curve, t);\n        var distance = Math.sqrt(Math.pow(point.x - curvePoint.x, 2) + Math.pow(point.y - curvePoint.y, 2) + Math.pow(point.z - curvePoint.z, 2));\n        if (distance < minDistance) {\n            minDistance = distance;\n            closestPoint = curvePoint;\n        }\n    }\n    return closestPoint;\n}","lastGenerated":"2024-10-26T23:03:13.860Z"}
{"_id":"createExtrusion","projectName":"default","arguments":"profileCurve, direction, length","specification":"Creates a solid by extruding a profile along a direction. Depends on (translateCurve, loftNurbsSurfaces)","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Creates an extrusion of a given profile curve along a specified direction vector and for a given length.\n *\n * @param {Array<Object>} profileCurve - An array of objects representing the points of the profile curve. Each point should have x, y, and z coordinates.\n * @param {Object} direction - An object representing the direction vector in which to extrude. The vector should have x, y, and z components.\n * @param {number} length - The length of the extrusion along the direction vector.\n * @returns {Object} A NURBS surface representing the extruded geometry.\n */\n","code":"function createExtrusion(profileCurve, direction, length) {\n    function translateCurve(curve, translationVector) {\n        return curve.map(point => ({\n            x: point.x + translationVector.x,\n            y: point.y + translationVector.y,\n            z: point.z + translationVector.z\n        }));\n    }\n    var directionMagnitude = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);\n    var unitDirection = {\n        x: direction.x / directionMagnitude,\n        y: direction.y / directionMagnitude,\n        z: direction.z / directionMagnitude\n    };\n    var extrusionVector = {\n        x: unitDirection.x * length,\n        y: unitDirection.y * length,\n        z: unitDirection.z * length\n    };\n    var translatedCurve = translateCurve(profileCurve, extrusionVector);\n    return loftNurbsSurfaces([\n        profileCurve,\n        translatedCurve\n    ]);\n}","lastGenerated":"2024-10-26T23:03:22.743Z"}
{"_id":"createNurbsCurve","projectName":"default","arguments":"controlPoints, degree, knots","specification":"Creates a NURBS curve. Depends on (none)","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Creates a NURBS (Non-Uniform Rational B-Splines) curve object.\n *\n * @param {Array} controlPoints - An array of control points, where each point is an array of coordinates (e.g., [x, y, z]).\n * @param {number} degree - The degree of the curve, indicating the polynomial degree of the segments.\n * @param {Array} knots - An array representing the knot vector, defining the parameterization of the curve.\n * @returns {Object} A NURBS curve object containing the control points, degree, and knot vector.\n */","code":"function createNurbsCurve(controlPoints, degree, knots) {\n    return {\n        controlPoints: controlPoints,\n        degree: degree,\n        knots: knots\n    };\n}","lastGenerated":"2024-10-26T23:01:51.939Z"}
{"_id":"createNurbsSurface","projectName":"default","arguments":"controlPoints, degreeU, degreeV, knotsU, knotsV","specification":"Creates a NURBS surface. Depends on (none)","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Creates a NURBS surface object.\n *\n * @param {Array<Array<Number[]>>} controlPoints - A 2D array of control points where each control point is represented by an array of numbers (coordinates).\n * @param {number} degreeU - The degree of the NURBS surface along the U direction.\n * @param {number} degreeV - The degree of the NURBS surface along the V direction.\n * @param {Array<number>} knotsU - The knot vector for the U direction.\n * @param {Array<number>} knotsV - The knot vector for the V direction.\n * @returns {Object} An object representing the NURBS surface with properties for control points, degrees, and knot vectors, \n * and a method to evaluate the surface at given parameters (u, v).\n */","code":"function createNurbsSurface(controlPoints, degreeU, degreeV, knotsU, knotsV) {\n    return {\n        controlPoints: controlPoints,\n        degreeU: degreeU,\n        degreeV: degreeV,\n        knotsU: knotsU,\n        knotsV: knotsV,\n        evaluate: function (u, v) {\n            return deBoorSurfaceAlgorithm(this.controlPoints, this.degreeU, this.degreeV, this.knotsU, this.knotsV, u, v);\n        }\n    };\n}","lastGenerated":"2024-10-26T23:02:06.989Z"}
{"_id":"createRevolution","projectName":"default","arguments":"profileCurve, axisPoint, axisDirection, angle","specification":"Creates a solid by revolving a profile around an axis. Depends on (rotateCurve)","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Creates a 3D surface by revolving a profile curve around a specified axis.\n *\n * @param {Array<Object>} profileCurve - An array of points representing the profile curve to be revolved. Each point is an object with x, y, and z coordinates.\n * @param {Object} axisPoint - An object representing a point on the axis of revolution. Contains x, y, and z coordinates.\n * @param {Object} axisDirection - An object representing the direction of the axis of revolution. Should be a normalized vector with x, y, and z components.\n * @param {number} angle - The angle of rotation in degrees for each step of the revolution.\n * @returns {Object} A NURBS surface generated by revolving the profile curve around the axis.\n */\n","code":"function createRevolution(profileCurve, axisPoint, axisDirection, angle) {\n    function rotatePoint(point, axisPoint, axisDirection, angle) {\n        var rad = angle * (Math.PI / 180);\n        var cosTheta = Math.cos(rad);\n        var sinTheta = Math.sin(rad);\n        var u = axisDirection.x;\n        var v = axisDirection.y;\n        var w = axisDirection.z;\n        var x = point.x - axisPoint.x;\n        var y = point.y - axisPoint.y;\n        var z = point.z - axisPoint.z;\n        var rotatedX = u * (u * x + v * y + w * z) * (1 - cosTheta) + x * cosTheta + (-w * y + v * z) * sinTheta + axisPoint.x;\n        var rotatedY = v * (u * x + v * y + w * z) * (1 - cosTheta) + y * cosTheta + (w * x - u * z) * sinTheta + axisPoint.y;\n        var rotatedZ = w * (u * x + v * y + w * z) * (1 - cosTheta) + z * cosTheta + (-v * x + u * y) * sinTheta + axisPoint.z;\n        return {\n            x: rotatedX,\n            y: rotatedY,\n            z: rotatedZ\n        };\n    }\n    var rotatedProfiles = [];\n    for (var i = 0; i <= 360; i += angle) {\n        var rotatedProfile = profileCurve.map(function (point) {\n            return rotatePoint(point, axisPoint, axisDirection, i);\n        });\n        rotatedProfiles.push(rotatedProfile);\n    }\n    return loftNurbsSurfaces(rotatedProfiles);\n}","lastGenerated":"2024-10-26T23:03:28.961Z"}
{"_id":"createSweep","projectName":"default","arguments":"profileCurve, pathCurve","specification":"Creates a solid by sweeping a profile along a path. Depends on (loftNurbsSurfaces)","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Creates a 3D sweep surface by sweeping a profile curve along a path curve.\n *\n * This function generates a series of profile sections positioned along\n * a given path curve, constructing a 3D surface by lofting through these\n * sections. Both the profile curve and path curve should be represented\n * as arrays of control points suitable for NURBS evaluation.\n *\n * @param {Array.<{x: number, y: number, z: number}>} profileCurve - An array of control points defining the profile curve.\n * @param {Array.<{x: number, y: number, z: number}>} pathCurve - An array of control points defining the path curve.\n * @returns {Object} A NURBS surface object that represents the 3D sweep model.\n *\n * @example\n * const profile = [{x: 0, y: 0, z: 0}, {x: 1, y: 0, z: 0}, {x: 0.5, y: 1, z: 0}];\n * const path = [{x: 0, y: 0, z: 0}, {x: 0, y: 5, z: 5}, {x: 0, y: 10, z: 10}];\n * const sweptSurface = createSweep(profile, path);\n */","code":"function createSweep(profileCurve, pathCurve) {\n    var profilePoints = [];\n    var pathLength = curveLength(pathCurve);\n    var sections = 10;\n    for (var i = 0; i <= sections; i++) {\n        var t = i / sections;\n        var pathPoint = evaluateNurbsCurve(pathCurve, t * pathLength);\n        var profileSection = [];\n        for (var j = 0; j < profileCurve.length; j++) {\n            profileSection.push({\n                x: profileCurve[j].x + pathPoint.x,\n                y: profileCurve[j].y + pathPoint.y,\n                z: profileCurve[j].z + pathPoint.z\n            });\n        }\n        profilePoints.push(profileSection);\n    }\n    return loftNurbsSurfaces(profilePoints);\n}","lastGenerated":"2024-10-26T23:03:35.053Z"}
{"_id":"curveLength","projectName":"default","arguments":"nurbsCurve","specification":"Calculates the length of a NURBS curve. Depends on (integrateCurve)","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Calculates the length of a given NURBS curve.\n *\n * This function utilizes numerical integration to determine the \n * length of the specified NURBS curve. It supports both rational \n * and non-rational curves.\n *\n * @param {NURBSCurve} nurbsCurve - The NURBS curve for which to calculate the length. \n *                                  The curve should be represented with its control points,\n *                                  degree, knots, and optionally weights.\n * @returns {number} The length of the NURBS curve.\n */","code":"function curveLength(nurbsCurve) {\n    return integrateCurve(nurbsCurve);\n}","lastGenerated":"2024-10-26T23:02:41.789Z"}
{"_id":"deBoorAlgorithm","projectName":"default","arguments":"controlPoints, degree, knots, t","specification":"Calculates a curve point using de Boor's algorithm. Depends on (none)","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Evaluates a point on a B-spline curve using the De Boor algorithm.\n *\n * @param {Array<Object>} controlPoints - An array of control points, where each point is an object with x, y, and z properties.\n * @param {number} degree - The degree of the B-spline.\n * @param {Array<number>} knots - A non-decreasing array representing the knots vector.\n * @param {number} t - The parameter at which the curve should be evaluated, typically between the first and last knot values where the curve is defined.\n * @returns {Object|null} - An object representing the x, y, z coordinates of the point on the curve at parameter t, or null if t is out of the valid range.\n */","code":"function deBoorAlgorithm(controlPoints, degree, knots, t) {\n    function deBoorRecursive(k, i, degree, controlPoints, knots, t) {\n        if (k === 0) {\n            return controlPoints[i];\n        }\n        var alpha = (t - knots[i]) / (knots[i + degree - k + 1] - knots[i]);\n        var point1 = deBoorRecursive(k - 1, i - 1, degree, controlPoints, knots, t);\n        var point2 = deBoorRecursive(k - 1, i, degree, controlPoints, knots, t);\n        return {\n            x: (1 - alpha) * point1.x + alpha * point2.x,\n            y: (1 - alpha) * point1.y + alpha * point2.y,\n            z: (1 - alpha) * point1.z + alpha * point2.z\n        };\n    }\n    var n = controlPoints.length - 1;\n    var m = knots.length - 1;\n    var k = degree;\n    if (t < knots[degree] || t > knots[m - degree])\n        return null;\n    for (var i = degree; i <= n; i++) {\n        if (t >= knots[i] && t < knots[i + 1]) {\n            return deBoorRecursive(degree, i, degree, controlPoints, knots, t);\n        }\n    }\n    return null;\n}","lastGenerated":"2024-10-26T23:02:02.813Z"}
{"_id":"deBoorSurfaceAlgorithm","projectName":"default","arguments":"controlPoints, degreeU, degreeV, knotsU, knotsV, u, v","specification":"Calculates a surface point using de Boor's algorithm. Depends on (none)","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Evaluates a NURBS surface at a given parameter (u, v) using the de Boor algorithm.\n *\n * @param {Array<Array<{x: number, y: number, z: number}>>} controlPoints - A 2D array of control points for the surface.\n * @param {number} degreeU - The degree of the surface in the U direction.\n * @param {number} degreeV - The degree of the surface in the V direction.\n * @param {Array<number>} knotsU - The knot vector in the U direction.\n * @param {Array<number>} knotsV - The knot vector in the V direction.\n * @param {number} u - The parameter value in the U direction at which to evaluate the surface.\n * @param {number} v - The parameter value in the V direction at which to evaluate the surface.\n * @returns {{x: number, y: number, z: number}} - The evaluated point on the NURBS surface.\n */","code":"function deBoorSurfaceAlgorithm(controlPoints, degreeU, degreeV, knotsU, knotsV, u, v) {\n    function deBoor(ctrlPts, degree, knots, t) {\n        const n = ctrlPts.length - 1;\n        const d = degree;\n        let k = findSpan(n, d, t, knots);\n        let dPts = Array.from({ length: d + 1 }, (_, i) => ({\n            x: ctrlPts[k - d + i].x,\n            y: ctrlPts[k - d + i].y,\n            z: ctrlPts[k - d + i].z\n        }));\n        for (let r = 1; r <= d; r++) {\n            for (let i = d; i >= r; i--) {\n                let alpha = (t - knots[k - d + i]) / (knots[k + i - r + 1] - knots[k - d + i]);\n                dPts[i].x = (1 - alpha) * dPts[i - 1].x + alpha * dPts[i].x;\n                dPts[i].y = (1 - alpha) * dPts[i - 1].y + alpha * dPts[i].y;\n                dPts[i].z = (1 - alpha) * dPts[i - 1].z + alpha * dPts[i].z;\n            }\n        }\n        return dPts[d];\n    }\n    function findSpan(n, degree, u, knots) {\n        if (u >= knots[n + 1])\n            return n;\n        if (u <= knots[degree])\n            return degree;\n        let low = degree, high = n + 1, mid = Math.floor((low + high) / 2);\n        while (u < knots[mid] || u >= knots[mid + 1]) {\n            if (u < knots[mid])\n                high = mid;\n            else\n                low = mid;\n            mid = Math.floor((low + high) / 2);\n        }\n        return mid;\n    }\n    const nU = controlPoints.length;\n    const nV = controlPoints[0].length;\n    let tempPoints = [];\n    for (let i = 0; i < nU; i++) {\n        tempPoints.push(deBoor(controlPoints[i], degreeV, knotsV, v));\n    }\n    return deBoor(tempPoints, degreeU, knotsU, u);\n}","lastGenerated":"2024-10-26T23:02:54.741Z"}
{"_id":"derivativeOfCurve","projectName":"default","arguments":"nurbsCurve, order","specification":"Calculates derivatives of a NURBS curve. Depends on (none)","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Computes the derivatives of a given NURBS curve up to a specified order.\n *\n * @param {Object} nurbsCurve - The NURBS curve object.\n * @param {Array} nurbsCurve.controlPoints - The control points of the NURBS curve.\n * @param {Number} nurbsCurve.degree - The degree of the NURBS curve.\n * @param {Array} nurbsCurve.knots - The knot vector of the NURBS curve.\n * @param {Number} order - The order up to which the derivatives are to be calculated.\n *\n * @returns {Array} An array of control points representing the derivative curve of the specified order.\n */","code":"function derivativeOfCurve(nurbsCurve, order) {\n    var n = nurbsCurve.controlPoints.length - 1;\n    var p = nurbsCurve.degree;\n    var ders = Array(order + 1).fill().map(() => []);\n    var delta = Array(p + 1).fill().map(() => []);\n    for (var k = 0; k <= order; k++) {\n        for (var i = 0; i <= n - k; i++) {\n            delta[k][i] = {\n                x: 0,\n                y: 0,\n                z: 0\n            };\n        }\n    }\n    for (var r = 0; r <= n - order; r++) {\n        ders[order][r] = nurbsCurve.controlPoints[r];\n    }\n    for (var k = order - 1; k >= 0; k--) {\n        for (var j = n - k; j >= 0; j--) {\n            var alpha = (nurbsCurve.knots[j + p + 1] - nurbsCurve.knots[j + k + 1]) / (p - k);\n            delta[k][j].x = alpha * (ders[k + 1][j + 1].x - ders[k + 1][j].x);\n            delta[k][j].y = alpha * (ders[k + 1][j + 1].y - ders[k + 1][j].y);\n            delta[k][j].z = alpha * (ders[k + 1][j + 1].z - ders[k + 1][j].z);\n            ders[k][j] = {\n                x: ders[k + 1][j].x + delta[k][j].x,\n                y: ders[k + 1][j].y + delta[k][j].y,\n                z: ders[k + 1][j].z + delta[k][j].z\n            };\n        }\n    }\n    return ders[0];\n}","lastGenerated":"2024-10-26T23:02:53.324Z"}
{"_id":"derivativeOfSurface","projectName":"default","arguments":"nurbsSurface, orderU, orderV","specification":"Calculates derivatives of a NURBS surface. Depends on (none)","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Computes the derivative of a given NURBS surface with respect to the parameter directions U and V.\n *\n * @param {Object} nurbsSurface - An object representing the NURBS surface.\n * @param {number} nurbsSurface.degreeU - The degree of the NURBS surface in the U direction.\n * @param {number} nurbsSurface.degreeV - The degree of the NURBS surface in the V direction.\n * @param {Array.<Array.<{x: number, y: number, z: number}>>} nurbsSurface.controlPoints - A 2D array of control points for the NURBS surface.\n * @param {Array.<number>} nurbsSurface.knotsU - The knot vector in the U direction.\n * @param {Array.<number>} nurbsSurface.knotsV - The knot vector in the V direction.\n * @param {number} orderU - The order of the derivative in the U direction.\n * @param {number} orderV - The order of the derivative in the V direction.\n * @returns {Object} An object representing the derived NURBS surface with updated control points, degrees, and knot vectors.\n * @returns {Array.<Array.<{x: number, y: number, z: number}>>} controlPoints - The new control points of the derived surface.\n * @returns {number} degreeU - The new degree of the derived surface in the U direction.\n * @returns {number} degreeV - The new degree of the derived surface in the V direction.\n * @returns {Array.<number>} knotsU - The modified knot vector in the U direction.\n * @returns {Array.<number>} knotsV - The modified knot vector in the V direction.\n */","code":"function derivativeOfSurface(nurbsSurface, orderU, orderV) {\n    const du = nurbsSurface.degreeU >= orderU ? orderU : nurbsSurface.degreeU;\n    const dv = nurbsSurface.degreeV >= orderV ? orderV : nurbsSurface.degreeV;\n    const controlPointsU = nurbsSurface.controlPoints.length;\n    const controlPointsV = nurbsSurface.controlPoints[0].length;\n    const newControlPoints = [];\n    for (let i = 0; i < controlPointsU - du; i++) {\n        const row = [];\n        for (let j = 0; j < controlPointsV - dv; j++) {\n            const pointU = {\n                x: (nurbsSurface.controlPoints[i + 1][j].x - nurbsSurface.controlPoints[i][j].x) * nurbsSurface.degreeU,\n                y: (nurbsSurface.controlPoints[i + 1][j].y - nurbsSurface.controlPoints[i][j].y) * nurbsSurface.degreeU,\n                z: (nurbsSurface.controlPoints[i + 1][j].z - nurbsSurface.controlPoints[i][j].z) * nurbsSurface.degreeU\n            };\n            const pointV = {\n                x: (nurbsSurface.controlPoints[i][j + 1].x - nurbsSurface.controlPoints[i][j].x) * nurbsSurface.degreeV,\n                y: (nurbsSurface.controlPoints[i][j + 1].y - nurbsSurface.controlPoints[i][j].y) * nurbsSurface.degreeV,\n                z: (nurbsSurface.controlPoints[i][j + 1].z - nurbsSurface.controlPoints[i][j].z) * nurbsSurface.degreeV\n            };\n            row.push({\n                x: pointU.x + pointV.x,\n                y: pointU.y + pointV.y,\n                z: pointU.z + pointV.z\n            });\n        }\n        newControlPoints.push(row);\n    }\n    const derivativeSurface = {\n        controlPoints: newControlPoints,\n        degreeU: Math.max(0, nurbsSurface.degreeU - du),\n        degreeV: Math.max(0, nurbsSurface.degreeV - dv),\n        knotsU: nurbsSurface.knotsU.slice(0, nurbsSurface.knotsU.length - du),\n        knotsV: nurbsSurface.knotsV.slice(0, nurbsSurface.knotsV.length - dv)\n    };\n    return derivativeSurface;\n}","lastGenerated":"2024-10-26T23:03:07.809Z"}
{"_id":"evaluateNurbsCurve","projectName":"default","arguments":"nurbsCurve, t","specification":"Evaluates a NURBS curve at a given parameter t. Depends on (deBoorAlgorithm)","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Evaluates a point on a NURBS curve at a given parameter value.\n *\n * @param {Object} nurbsCurve - An object representing the NURBS curve.\n * @param {Array} nurbsCurve.controlPoints - The control points of the NURBS curve.\n * @param {number} nurbsCurve.degree - The degree of the NURBS curve.\n * @param {Array} nurbsCurve.knots - The knot vector of the NURBS curve.\n * @param {number} t - The parameter value at which to evaluate the curve.\n * @returns {Array} The evaluated point on the NURBS curve.\n */","code":"function evaluateNurbsCurve(nurbsCurve, t) {\n    return deBoorAlgorithm(nurbsCurve.controlPoints, nurbsCurve.degree, nurbsCurve.knots, t);\n}","lastGenerated":"2024-10-26T23:01:54.367Z"}
{"_id":"evaluateNurbsSurface","projectName":"default","arguments":"nurbsSurface, u, v","specification":"Evaluates a NURBS surface at parameters (u, v). Depends on (deBoorSurfaceAlgorithm)","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Evaluates a NURBS surface at the given parameter values (u, v).\n *\n * @param {Object} nurbsSurface - An object representing the NURBS surface.\n * @param {Array} nurbsSurface.controlPoints - A 2D array of control points for the NURBS surface.\n * @param {number} nurbsSurface.degreeU - The degree of the NURBS surface in the U direction.\n * @param {number} nurbsSurface.degreeV - The degree of the NURBS surface in the V direction.\n * @param {Array} nurbsSurface.knotsU - The knot vector in the U direction.\n * @param {Array} nurbsSurface.knotsV - The knot vector in the V direction.\n * @param {number} u - The parameter value in the U direction.\n * @param {number} v - The parameter value in the V direction.\n *\n * @returns {Object} The point on the NURBS surface corresponding to the parameters (u, v).\n */","code":"function evaluateNurbsSurface(nurbsSurface, u, v) {\n    return deBoorSurfaceAlgorithm(nurbsSurface.controlPoints, nurbsSurface.degreeU, nurbsSurface.degreeV, nurbsSurface.knotsU, nurbsSurface.knotsV, u, v);\n}","lastGenerated":"2024-10-26T23:02:10.534Z"}
{"_id":"findIntersection","projectName":"default","arguments":"curve1, curve2","specification":"Finds intersections between two curves. Depends on (intersectionAlgorithm)","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Finds the intersection points between two NURBS curves.\n *\n * This function utilizes an intersection algorithm to determine all intersection\n * points between two given NURBS curves, `curve1` and `curve2`.\n *\n * @param {Object} curve1 - The first NURBS curve to be checked for intersections.\n * @param {Object} curve2 - The second NURBS curve to be checked for intersections.\n * @returns {Array} An array of points representing the intersection locations between the two curves.\n * Each point is represented as an object containing the coordinates.\n */","code":"function findIntersection(curve1, curve2) {\n    return intersectionAlgorithm(curve1, curve2);\n}","lastGenerated":"2024-10-26T23:02:36.619Z"}
{"_id":"integrateCurve","projectName":"default","arguments":"nurbsCurve","specification":"Numerically integrates a curve for different purposes. Depends on (none)","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Integrates the length of a NURBS curve to compute an approximation of the curve's arc-length parameterization.\n * \n * This function uses a simple numerical integration technique (trapezoidal rule) to evaluate the integral\n * of the curve's arc-length by dividing the curve into a specified number of sections and accumulating\n * the vector sum along the curve.\n *\n * @param {Object} nurbsCurve - The NURBS curve to integrate. This object should have properties and methods \n * necessary to define and evaluate the curve at given parameter values.\n * @param {Function} nurbsCurve.evaluate - Function to evaluate the NURBS curve. It should accept a parameter `t` \n * and return an object with `x`, `y`, and `z` properties.\n * \n * @returns {Object} An object containing the integrated vector values along the curve, with properties `x`, `y`, \n * and `z` representing the accumulated length parameters along each axis.\n */","code":"function integrateCurve(nurbsCurve) {\n    var totalLength = curveLength(nurbsCurve);\n    var numSections = 100;\n    var deltaT = 1 / numSections;\n    var integral = {\n        x: 0,\n        y: 0,\n        z: 0\n    };\n    for (var i = 0; i < numSections; i++) {\n        var t1 = i * deltaT;\n        var t2 = (i + 1) * deltaT;\n        var point1 = evaluateNurbsCurve(nurbsCurve, t1);\n        var point2 = evaluateNurbsCurve(nurbsCurve, t2);\n        integral.x += (point1.x + point2.x) / 2 * deltaT * totalLength;\n        integral.y += (point1.y + point2.y) / 2 * deltaT * totalLength;\n        integral.z += (point1.z + point2.z) / 2 * deltaT * totalLength;\n    }\n    return integral;\n}","lastGenerated":"2024-10-26T23:02:47.574Z"}
{"_id":"intersectSurfaces","projectName":"default","arguments":"surface1, surface2","specification":"Finds the intersection curve between two surfaces. Depends on (intersectionAlgorithm)","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Computes the intersection curves of two NURBS surfaces.\n *\n * This function attempts to find intersection curves between two given NURBS surfaces by sampling points on a grid \n * and evaluating potential intersection segments. It then constructs curves through the identified intersections.\n *\n * @param {NURBSSurface} surface1 - The first NURBS surface to intersect.\n * @param {NURBSSurface} surface2 - The second NURBS surface to intersect.\n * @returns {Array} An array of curves representing the intersection between the two surfaces.\n *\n * @throws {Error} Throws an error if the intersection algorithm encounters an unexpected condition.\n *\n * @example\n * const surface1 = createNurbsSurface(...);\n * const surface2 = createNurbsSurface(...);\n * const intersectionCurves = intersectSurfaces(surface1, surface2);\n * console.log(intersectionCurves);\n *\n * @see evaluateNurbsSurface\n * @see createNurbsCurve\n * @see intersectionAlgorithm\n * @see approximateCurveThroughPoints\n */","code":"function intersectSurfaces(surface1, surface2) {\n    var uSegments = 10, vSegments = 10;\n    var intersectionCurves = [];\n    for (var i = 0; i <= uSegments; i++) {\n        var u = i / uSegments;\n        for (var j = 0; j <= vSegments; j++) {\n            var v = j / vSegments;\n            var curve1Point1 = evaluateNurbsSurface(surface1, u, v);\n            var curve1Point2 = evaluateNurbsSurface(surface1, u + 1 / uSegments, v);\n            var curve2Point1 = evaluateNurbsSurface(surface2, u, v);\n            var curve2Point2 = evaluateNurbsSurface(surface2, u + 1 / uSegments, v);\n            var curve1 = createNurbsCurve([\n                curve1Point1,\n                curve1Point2\n            ], 1, [\n                0,\n                0,\n                1,\n                1\n            ]);\n            var curve2 = createNurbsCurve([\n                curve2Point1,\n                curve2Point2\n            ], 1, [\n                0,\n                0,\n                1,\n                1\n            ]);\n            var intersection = intersectionAlgorithm(curve1, curve2);\n            if (intersection) {\n                intersectionCurves.push(intersection);\n            }\n        }\n    }\n    return approximateCurveThroughPoints(intersectionCurves);\n}","lastGenerated":"2024-10-26T23:04:39.488Z"}
{"_id":"intersectionAlgorithm","projectName":"default","arguments":"curve1, curve2","specification":"Implements intersection finding between two curves. Depends on (none)","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Computes the intersection between two NURBS curves.\n *\n * @function\n * @param {Object} curve1 - The first NURBS curve object.\n * @param {Object} curve2 - The second NURBS curve object.\n * @returns {Array} An array of intersection points.\n * @throws {Error} If finding the intersection fails or if provided curves are invalid.\n *\n * @description\n * This function takes two NURBS curve objects and returns the intersection points\n * between them. The curves must be valid NURBS curves. The intersection is calculated\n * using a specified algorithm which determines points where the curves meet.\n *\n * @example\n * const intersectionPoints = intersectionAlgorithm(curve1, curve2);\n */","code":"function intersectionAlgorithm(curve1, curve2) {\n    return findIntersection(curve1, curve2);\n}","lastGenerated":"2024-10-26T23:02:38.583Z"}
{"_id":"loftNurbsSurfaces","projectName":"default","arguments":"sectionCurves","specification":"Generates a lofted surface through a series of section curves. Depends on (matchCurveKnotVectors)","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Generates a series of NURBS surfaces by lofting a set of section curves.\n *\n * The lofting process interpolates multiple NURBS curves to form continuous NURBS surfaces.\n * This function matches the knot vectors of adjacent curves to ensure compatibility\n * and interpolates a series of control points to form the resulting surfaces.\n *\n * @param {Array} sectionCurves - An array of NURBS curves to be lofted. Each curve should\n *                                have properties including control points, degree, and knots.\n *\n * @returns {Array} An array of NURBS surfaces generated by lofting the given section curves.\n *                  Each surface is created by interpolating control points and constructing\n *                  a NURBS surface using the resulting control polygons.\n *\n * @throws {Error} Throws an error if the input curves array is empty or contains invalid curve definitions.\n *\n * @example\n * const curves = [nurbsCurve1, nurbsCurve2, nurbsCurve3];\n * const surfaces = loftNurbsSurfaces(curves);\n * // surfaces now contains interpolated NURBS surfaces between the given curves.\n */","code":"function loftNurbsSurfaces(sectionCurves) {\n    var matchedCurves = [];\n    for (var i = 1; i < sectionCurves.length; i++) {\n        var matched = matchCurveKnotVectors(sectionCurves[i - 1], sectionCurves[i]);\n        matchedCurves.push(matched[0]);\n        if (i === sectionCurves.length - 1) {\n            matchedCurves.push(matched[1]);\n        }\n    }\n    var surfaces = [];\n    for (var j = 0; j < matchedCurves.length - 1; j++) {\n        var interpolatedControlPoints = [];\n        for (var k = 0; k <= 1; k += 0.01) {\n            var curvePoints = [];\n            for (var l = 0; l < matchedCurves.length; l++) {\n                var point = evaluateNurbsCurve(matchedCurves[l], k);\n                curvePoints.push(point);\n            }\n            interpolatedControlPoints.push(curvePoints);\n        }\n        var surface = createNurbsSurface(interpolatedControlPoints, matchedCurves[0].degree, matchedCurves[0].degree, matchedCurves[0].knots, matchedCurves[0].knots);\n        surfaces.push(surface);\n    }\n    return surfaces;\n}","lastGenerated":"2024-10-26T23:03:40.482Z"}
{"_id":"matchCurveKnotVectors","projectName":"default","arguments":"curve1, curve2","specification":"Aligns the knot vector of two curves. Depends on (refineKnotVector)","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Matches the knot vectors of two NURBS curves by refining them to include all unique knots.\n *\n * This function takes two NURBS curves and aligns their knot vectors by combining the knots\n * from both curves into a single set of unique, sorted knots. It then refines each curve's\n * knot vector to match this unified knot vector, ensuring both curves have identical knot spans.\n *\n * @param {Object} curve1 - The first NURBS curve object. Expected to have a `knots` property, which is an array of numbers.\n * @param {Object} curve2 - The second NURBS curve object. Expected to have a `knots` property, which is an array of numbers.\n */","code":"function matchCurveKnotVectors(curve1, curve2) {\n    var knots1 = curve1.knots;\n    var knots2 = curve2.knots;\n    var allKnots = Array.from(new Set(knots1.concat(knots2))).sort((a, b) => a - b);\n    refineKnotVector(curve1, allKnots);\n    refineKnotVector(curve2, allKnots);\n}","lastGenerated":"2024-10-26T23:03:44.406Z"}
{"_id":"offsetSurface","projectName":"default","arguments":"nurbsSurface, distance","specification":"Offsets a NURBS surface by a distance in the normal direction. Depends on (evaluateNurbsSurface, derivativeOfSurface)","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Offsets a NURBS surface by a specified distance along its normal.\n *\n * @param {Object} nurbsSurface - The NURBS surface to offset, containing properties \n *                                such as degree and knot vectors in U and V directions.\n * @param {number} distance - The distance by which to offset the surface along the normal.\n * \n * @returns {Object} A new NURBS surface offset by the given distance, with \n *                   updated control points.\n *\n * @throws {Error} Throws an error if the surface cannot be evaluated at certain parameters.\n *\n * @description This function takes a given NURBS surface and offsets it by the specified\n *              distance in the direction normal to the surface. The new surface is created\n *              by evaluating the offset at discrete (u, v) parameter intervals. It uses\n *              the cross product of partial derivatives to calculate normal vectors.\n */","code":"function offsetSurface(nurbsSurface, distance) {\n    var controlPoints = [];\n    var degreeU = nurbsSurface.degreeU;\n    var degreeV = nurbsSurface.degreeV;\n    var knotsU = nurbsSurface.knotsU;\n    var knotsV = nurbsSurface.knotsV;\n    for (var u = 0; u <= 1; u += 0.1) {\n        var row = [];\n        for (var v = 0; v <= 1; v += 0.1) {\n            var point = evaluateNurbsSurface(nurbsSurface, u, v);\n            var du = derivativeOfSurface(nurbsSurface, 1, 0);\n            var dv = derivativeOfSurface(nurbsSurface, 0, 1);\n            var normal = {\n                x: du.y * dv.z - du.z * dv.y,\n                y: du.z * dv.x - du.x * dv.z,\n                z: du.x * dv.y - du.y * dv.x\n            };\n            var length = Math.sqrt(normal.x * normal.x + normal.y * normal.y + normal.z * normal.z);\n            normal.x /= length;\n            normal.y /= length;\n            normal.z /= length;\n            var offsetPoint = {\n                x: point.x + distance * normal.x,\n                y: point.y + distance * normal.y,\n                z: point.z + distance * normal.z\n            };\n            row.push(offsetPoint);\n        }\n        controlPoints.push(row);\n    }\n    return createNurbsSurface(controlPoints, degreeU, degreeV, knotsU, knotsV);\n}","lastGenerated":"2024-10-26T23:04:25.226Z"}
{"_id":"on","jsdoc":"/**\n * Determines if three points are collinear in 3D space.\n *\n * This function calculates the scalar triple product of vectors formed\n * by the input points and checks if the result equals zero, which indicates\n * that the points are collinear.\n *\n * @param {Object} p1 - The first point object.\n * @param {number} p1.x - The x-coordinate of the first point.\n * @param {number} p1.y - The y-coordinate of the first point.\n * @param {number} p1.z - The z-coordinate of the first point.\n * @param {Object} p2 - The second point object.\n * @param {number} p2.x - The x-coordinate of the second point.\n * @param {number} p2.y - The y-coordinate of the second point.\n * @param {number} p2.z - The z-coordinate of the second point.\n * @param {Object} p3 - The third point object.\n * @param {number} p3.x - The x-coordinate of the third point.\n * @param {number} p3.y - The y-coordinate of the third point.\n * @param {number} p3.z - The z-coordinate of the third point.\n * @returns {boolean} `true` if the points are collinear, `false` otherwise.\n */","code":"function on(p1, p2, p3) {\n    var a = p1.x * (p2.y * p3.z - p2.z * p3.y);\n    var b = p1.y * (p2.z * p3.x - p2.x * p3.z);\n    var c = p1.z * (p2.x * p3.y - p2.y * p3.x);\n    return a + b + c === 0;\n}","lastGenerated":"2024-10-26T00:57:59.178Z","errorLogs":"","needsGeneration":"false"}
{"_id":"projectPointOnCurve","projectName":"default","arguments":"point, curve","specification":"Projects a point onto a curve. Depends on (closestPointOnCurve)","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Projects a given point onto a curve and returns the closest point on the curve.\n *\n * This function calculates the closest point on a specified curve to a given point in space.\n *\n * @param {Array<number>} point - The point in 3D space to be projected onto the curve, represented as an array [x, y, z].\n * @param {Object} curve - The NURBS curve object onto which the point will be projected.\n * @returns {Array<number>} The point on the curve closest to the given point, represented as an array [x, y, z].\n */","code":"function projectPointOnCurve(point, curve) {\n    return closestPointOnCurve(point, curve);\n}","lastGenerated":"2024-10-26T23:03:09.637Z"}
{"_id":"refineKnotVector","projectName":"default","arguments":"curveOrSurface, newKnots","specification":"Inserts new knots into the existing knot vector. Depends on (none)","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Refines the knot vector of a given NURBS curve or surface by inserting new knots.\n * \n * @param {Object} curveOrSurface - The NURBS curve or surface to be refined.\n * @param {Array<number>} newKnots - The knots to be inserted into the knot vector.\n * \n * @returns {Object} - Returns a refined NURBS curve or surface with updated control points and knot vector.\n * \n * @property {Array<Object>} curveOrSurface.controlPoints - The control points of the curve or surface.\n * @property {number} curveOrSurface.degree - The degree of the curve (if it's a curve).\n * @property {number} curveOrSurface.degreeU - The degree of the surface in the U direction (if it's a surface).\n * @property {number} curveOrSurface.degreeV - The degree of the surface in the V direction (if it's a surface).\n * @property {Array<number>} curveOrSurface.knots - The knot vector (if it's a curve).\n * @property {Array<number>} curveOrSurface.knotsU - The knot vector in the U direction (if it's a surface).\n * @property {Array<number>} curveOrSurface.knotsV - The knot vector in the V direction (if it's a surface).\n * \n * @private\n * @function insertKnot\n *   Internal utility function to insert a single knot into the knot vector and update control points.\n * \n * @function findSpan\n *   Finds the knot span index in the knot vector for a given parameter.\n */","code":"function refineKnotVector(curveOrSurface, newKnots) {\n    var controlPoints, degree, knots;\n    var isCurve = curveOrSurface.hasOwnProperty('degree');\n    if (isCurve) {\n        controlPoints = curveOrSurface.controlPoints;\n        degree = curveOrSurface.degree;\n        knots = curveOrSurface.knots;\n    } else {\n        controlPoints = curveOrSurface.controlPoints;\n        degreeU = curveOrSurface.degreeU;\n        degreeV = curveOrSurface.degreeV;\n        knotsU = curveOrSurface.knotsU;\n        knotsV = curveOrSurface.knotsV;\n    }\n    function insertKnot(knot, k, p, controlPoints, knots) {\n        var n = controlPoints.length - 1;\n        var m = knots.length - 1;\n        var r = 1;\n        var a = findSpan(knot, k, p, knots);\n        var b = a + 1;\n        var newControlPoints = [];\n        for (var i = 0; i <= a - p; i++) {\n            newControlPoints.push(controlPoints[i]);\n        }\n        for (var i = a - p + 1; i <= a; i++) {\n            var alpha = (knot - knots[i]) / (knots[i + p] - knots[i]);\n            var pt = {\n                x: alpha * controlPoints[i].x + (1 - alpha) * controlPoints[i - 1].x,\n                y: alpha * controlPoints[i].y + (1 - alpha) * controlPoints[i - 1].y,\n                z: alpha * controlPoints[i].z + (1 - alpha) * controlPoints[i - 1].z\n            };\n            newControlPoints.push(pt);\n        }\n        for (var i = b; i <= n; i++) {\n            newControlPoints.push(controlPoints[i]);\n        }\n        var newKnots = [];\n        for (var i = 0; i <= a; i++) {\n            newKnots.push(knots[i]);\n        }\n        newKnots.push(knot);\n        for (var i = b; i <= m; i++) {\n            newKnots.push(knots[i]);\n        }\n        return {\n            controlPoints: newControlPoints,\n            knots: newKnots\n        };\n    }\n    function findSpan(u, n, p, U) {\n        if (u >= U[n + 1])\n            return n;\n        if (u <= U[p])\n            return p;\n        var low = p;\n        var high = n + 1;\n        var mid = Math.floor((low + high) / 2);\n        while (u < U[mid] || u >= U[mid + 1]) {\n            if (u < U[mid]) {\n                high = mid;\n            } else {\n                low = mid;\n            }\n            mid = Math.floor((low + high) / 2);\n        }\n        return mid;\n    }\n    for (var i = 0; i < newKnots.length; i++) {\n        if (isCurve) {\n            var result = insertKnot(newKnots[i], controlPoints.length - 1, degree, controlPoints, knots);\n            controlPoints = result.controlPoints;\n            knots = result.knots;\n        } else {\n            var nu = controlPoints.length - 1;\n            var nv = controlPoints[0].length - 1;\n            var knotResultU = insertKnot(newKnots[i], nu, degreeU, controlPoints, knotsU);\n            controlPoints = knotResultU.controlPoints;\n            knotsU = knotResultU.knots;\n            var knotResultV = insertKnot(newKnots[i], nv, degreeV, controlPoints[0], knotsV);\n            for (var j = 0; j < controlPoints.length; j++) {\n                controlPoints[j] = knotResultV.controlPoints[j];\n            }\n            knotsV = knotResultV.knots;\n        }\n    }\n    if (isCurve) {\n        return createNurbsCurve(controlPoints, degree, knots);\n    } else {\n        return createNurbsSurface(controlPoints, degreeU, degreeV, knotsU, knotsV);\n    }\n}","lastGenerated":"2024-10-26T23:02:34.246Z"}
{"_id":"shellSolid","projectName":"default","arguments":"solid, thickness","specification":"Generates a shell from a solid by offsetting its surfaces inward or outward. Depends on (offsetSurface, booleanOperation)","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Creates a shelled version of a solid by offsetting its surfaces both inward and outward.\n * This operation effectively adds thickness to the solid, creating a hollowed version.\n *\n * @param {Object} solid - The solid object to be shelled. It should have an array of surfaces.\n * @param {number} thickness - The thickness to be applied to the solid surfaces. Positive values add material, while negative values remove it.\n * \n * @returns {Object} - A new solid object representing the shelled version of the original solid.\n *\n * @throws {Error} If the solid does not have a properly defined surface array.\n */","code":"function shellSolid(solid, thickness) {\n    var offsetSolidOuter = [];\n    var offsetSolidInner = [];\n    for (var i = 0; i < solid.surfaces.length; i++) {\n        offsetSolidOuter.push(offsetSurface(solid.surfaces[i], thickness));\n        offsetSolidInner.push(offsetSurface(solid.surfaces[i], -thickness));\n    }\n    var outerShell = booleanOperation(solid, offsetSolidOuter, 'union');\n    var innerShell = booleanOperation(solid, offsetSolidInner, 'subtract');\n    return booleanOperation(outerShell, innerShell, 'subtract');\n}","lastGenerated":"2024-10-26T23:04:18.637Z"}
