{"_id":"Curve","projectName":"default","arguments":"points","specification":"Represents a curve as a sequence of points. No dependencies.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @name Curve\n * @param {Array} points - An array of points defining the curve.\n * @constructor\n *\n * @description Creates a new curve with the given points.\n *\n * @property {Array} points - The points that define the curve.\n * @method getPoints() - Returns the current points of the curve.\n * @method setPoint(i, point) - Sets a point at the specified index in the curve.","code":"function Curve(points) {\n  this.points = points || [];\n  this.getPoints = function() { return this.points; };\n  this.setPoint = function(i, point) {\n    if (i >= 0 && i < this.points.length) {\n      this.points[i] = point;\n    }\n  };\n}","lastGenerated":"2024-06-04T16:55:39.235Z"}
{"_id":"Edge","projectName":"default","arguments":"vertex1, vertex2","specification":"Represents an edge in BREP. Depends on (Vertex).","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Creates a new edge object representing the line segment between two vertices.\n * \n * @param {Array.<number>} vertex1 - The coordinates of the first vertex (x, y, z).\n * @param {Array.<number>} vertex2 - The coordinates of the second vertex (x, y, z).\n */","code":"function Edge(vertex1, vertex2) {\n  this.vertexA = {x: vertex1[0], y: vertex1[1], z: vertex1[2]};\n  this.vertexB = {x: vertex2[0], y: vertex2[1], z: vertex2[2]};\n}","lastGenerated":"2024-06-04T16:56:15.504Z"}
{"_id":"Face","projectName":"default","arguments":"surface, loops","specification":"Represents a face in BREP. Depends on (Surface, Loop).","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @param {Object} surface - \n * @param {Array} loops - \n */","code":"function Face(surface, loops) {\n  const vertices = [];\n  for (let i = 0; i < loops.length; i++) {\n    const edge = {v1: loops[i].vertex1, v2: loops[i].vertex2};\n    for (const edge2 of surface.edges) {\n      if (edge.v1.x === edge2.v1.x && edge.v1.y === edge2.v1.y && edge.v1.z === edge2.v1.z &&\n          edge.v2.x === edge2.v2.x && edge.v2.y === edge2.v2.y && edge.v2.z === edge2.v2.z) {\n        const intersection = {x: (edge.v1.x + edge.v2.x) / 2, y: (edge.v1.y + edge.v2.y) / 2, z: (edge.v1.z + edge.v2.z) / 2};\n        vertices.push(intersection);\n      } else if (edge.v1.x === edge2.v2.x && edge.v1.y === edge2.v2.y && edge.v1.z === edge2.v2.z &&\n                 edge.v2.x === edge2.v1.x && edge.v2.y === edge2.v1.y && edge.v2.z === edge2.v1.z) {\n        const intersection = {x: (edge.v1.x + edge.v2.x) / 2, y: (edge.v1.y + edge.v2.y) / 2, z: (edge.v1.z + edge.v2.z) / 2};\n        vertices.push(intersection);\n      }\n    }\n  }\n  surface.shells[0].faces.push({vertices});\n}","lastGenerated":"2024-06-04T16:58:14.274Z"}
{"_id":"Loop","projectName":"default","arguments":"edges","specification":"Represents a loop (a closed sequence of edges) in BREP. Depends on (Edge).","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @param {Array.<{x: number, y: number}>} edges \n * @return {Array.<[Edge1: {x: number, y: number}, Edge2: {x: number, y: number}]>}\n * Finds all non-intersecting edges in the given array and returns them.\n */","code":"function Loop(edges){let result=[];for(let i=0;i<edges.length;i++){const currentEdge=edges[i];const nextEdge=edges[(i+1)%edges.length];if(!findIntersection(currentEdge,nextEdge)){result.push([currentEdge,nextEdge]);}else{console.error(`Intersection detected between edge ${i} and edge ${(i+1)%edges.length}. Loop creation interrupted.`);break;}}return result;}","lastGenerated":"2024-06-04T16:59:15.017Z"}
{"_id":"Matrix","projectName":"default","arguments":"elements","specification":"Represents a transformation matrix. No dependencies.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @name Matrix\n * @param {Array} elements - The input matrix elements.\n * @description Creates a new matrix based on the given elements and defines a method for matrix multiplication.\n */","code":"function Matrix(elements) {\n  this.elements = elements;\n  this.times = function(other) {\n    var result = [];\n    for (var i = 0; i < elements.length; i++) {\n      result[i] = [];\n      for (var j = 0; j < other.elements[0].length; j++) {\n        var sum = 0;\n        for (var k = 0; k < elements[0].length; k++) {\n          sum += elements[i][k] * other.elements[k][j];\n        }\n        result[i].push(sum);\n      }\n    }\n    return new Matrix(result);\n  };\n}","lastGenerated":"2024-06-04T17:00:17.904Z"}
{"_id":"Point","projectName":"default","arguments":"x, y, z","specification":"Represents a point in 3D space. No dependencies.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @param {number} x - The x-coordinate of the point.\n * @param {number} y - The y-coordinate of the point.\n * @param {number} z - The z-coordinate of the point.\n * @returns {{x: number, y: number, z: number}} - A new Point object with the given coordinates.\n */","code":"function Point(x, y, z) {\n  return {x, y, z};\n}","lastGenerated":"2024-06-04T17:00:52.576Z"}
{"_id":"Shell","projectName":"default","arguments":"faces","specification":"Represents a shell (a closed collection of faces) in BREP. Depends on (Face).","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @class Shell\n *\n * @param {Array} faces - The initial faces of the shell.\n *\n * @description Represents a shell with multiple faces.\n */\n/**\n * @member {Array} getFaces()\n *\n * @returns {Array} The faces of the shell.\n *\n * @description Gets the faces of the shell.\n */\n/**\n * @member {void} setFaces(newFaces)\n *\n * @param {Array|Object} newFaces - New faces to set for the shell.\n *\n * @description Sets the faces of the shell.\n */\n/**\n * @member {Shell} clone()\n *\n * @returns {Shell} A cloned copy of this shell.\n *\n * @description Creates a deep copy of this shell.","code":"function Shell(faces) {\n  this._faces = Array.isArray(faces) ? faces : [faces];\n}\n\nShell.prototype.getFaces = function() {\n  return this._faces;\n};\n\nShell.prototype.setFaces = function(newFaces) {\n  this._faces = newFaces instanceof Array ? newFaces : [newFaces];\n};\n\nShell.prototype.clone = Shell.prototype.cloneCurve = function() {\n  return new Shell(this._faces);\n};","lastGenerated":"2024-06-04T17:02:14.483Z"}
{"_id":"Solid","projectName":"default","arguments":"shells","specification":"Represents a solid in BREP. Depends on (Shell).","needsGeneration":"true","errorLogs":"{\"index\":205,\"lineNumber\":5,\"description\":\"Unexpected token )\"}","jsdoc":"/**\n * @param {array} Shells - array of shell objects\n * @returns {number} the volume of the solid formed by stacking the shells\n */","code":"function Solid(Shells) {\n    let volume = 0;\n    for (let i = 0; i < Shells.length; i++) {\n        const shell = Shells[i];\n        volume += shell.area() * Math.abs(shell.normal().dot(new Point(0, 0, 1))));\n    }\n    return volume;\n}","lastGenerated":"2024-06-04T17:03:10.083Z"}
{"_id":"Surface","projectName":"default","arguments":"controlPoints","specification":"Represents a surface defined by control points. No dependencies.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @class Surface\n * Represents a surface defined by control points.\n *\n * @param {Array} controlPoints - The control points that define the surface.\n */\n/**\n * @method getCurve\n * Returns the curve of the surface defined by its control points.\n *\n * @return {Array} An array of objects representing the curve of the surface.\n */","code":"function Surface(controlPoints) {\n    this.controlPoints = controlPoints;\n}\n\nSurface.prototype.getCurve = function() {\n    let curve = [];\n    for (let i = 0; i < this.controlPoints.length - 1; i++) {\n        curve.push({x: this.controlPoints[i].x, y: this.controlPoints[i].y, z: this.controlPoints[i].z});\n        curve.push({x: this.controlPoints[i].x, y: this.controlPoints[i].y, z: this.controlPoints[i + 1].z});\n    }\n    return curve;\n};","lastGenerated":"2024-06-04T17:04:23.204Z"}
{"_id":"Vector","projectName":"default","arguments":"x, y, z","specification":"Represents a vector in 3D space. No dependencies.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @name Vector\n * @constructor\n * @description Creates a new vector with the specified x, y, and z components.\n * @param {number} x - The x component of the vector.\n * @param {number} y - The y component of the vector.\n * @param {number} z - The z component of the vector.\n */\n\n/**\n * @name Vector.prototype.add\n * @description Adds two vectors together and returns the result.\n * @param {Vector} vector2 - The second vector to add.\n * @returns {Vector}\n */\n\n/**\n * @name Vector.prototype.subtract\n * @description Subtracts one vector from another and returns the result.\n * @param {Vector} vector2 - The second vector to subtract.\n * @returns {Vector}\n */","code":"function Vector(x, y, z) {\n    return {x, y, z};\n}\n\nVector.prototype.add = function(vector2) {\n    return {x: this.x + vector2.x, y: this.y + vector2.y, z: this.z + vector2.z};\n};\n\nVector.prototype.subtract = function(vector2) {\n    return {x: this.x - vector2.x, y: this.y - vector2.y, z: this.z - vector2.z};\n};","lastGenerated":"2024-06-04T17:05:53.966Z"}
{"_id":"Vertex","projectName":"default","arguments":"point","specification":"Represents a vertex in BREP. Depends on (Point).","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @constructor\n * Creates a new Vertex object from the given point.\n *\n * @param {Point} point - The point coordinates to initialize this vertex with.\n */","code":"function Vertex(point) {\n  this.x = point.x;\n  this.y = point.y;\n  this.z = point.z;\n}","lastGenerated":"2024-06-04T17:06:22.601Z"}
{"_id":"addEdge","projectName":"default","arguments":"solid, edge","specification":"Adds an edge to a solid. Depends on (Solid, Edge).","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Adds an edge to a solid.\n *\n * @param {Object} solid - The solid to add the edge to.\n * @param {Object} edge - The edge to be added.\n */","code":"function addEdge(solid, edge) {\n  let newVertex1 = {x: edge.vertex1.x, y: edge.vertex1.y, z: edge.vertex1.z};\n  let newVertex2 = {x: edge.vertex2.x, y: edge.vertex2.y, z: edge.vertex2.z};\n  \n  solid.vertices.push(newVertex1);\n  solid.vertices.push(newVertex2);\n}","lastGenerated":"2024-06-04T17:07:11.668Z"}
{"_id":"addFace","projectName":"default","arguments":"shell, face","specification":"Adds a face to a shell. Depends on (Shell, Face).","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @param {Object} shell - The shell object.\n * @param {Object} face - The face object to be added.\n * @returns {Object} A new shell object with the given face added.\n */","code":"function addFace(shell, face) {\n  return {x:shell.x, y:shell.y, z:shell.z, faces:[...shell.faces,face]};\n}","lastGenerated":"2024-06-04T17:07:44.985Z"}
{"_id":"addLoop","projectName":"default","arguments":"face, loop","specification":"Adds a loop to a face. Depends on (Face, Loop).","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @param {Object} face - The object to add the loop to.\n * @param {*} loop - The loop to be added.\n * Adds a new loop to the given 'face' object, if it doesn't already have a 'loops' property or if that property is not an array. If necessary, initializes the 'loops' property with an empty array and then pushes the new loop onto it.","code":"function addLoop(face, loop) {\n  if (!(\"loops\" in face) || !Array.isArray(face.loops)) face.loops = [];\n  face.loops.push(loop);\n}","lastGenerated":"2024-06-04T17:08:28.975Z"}
{"_id":"addShell","projectName":"default","arguments":"solid, shell","specification":"Adds a shell to a solid. Depends on (Solid, Shell).","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @param {Object} solid - input solid object\n * @param {Object} shell - input shell object\n * @returns {Object} newSolid - the resulting solid object with added shell\n */","code":"function addShell(solid, shell) {\n    var newSolid = {x: solid.x, y: solid.y, z: solid.z, shells: [solid.shells].concat([shell])};\n    return newSolid;\n}","lastGenerated":"2024-06-04T17:09:05.149Z"}
{"_id":"addVectors","projectName":"default","arguments":"v1, v2","specification":"Adds two vectors. Depends on (Vector).","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @param {Object} v1 - The first vector.\n * @param {Object} v2 - The second vector.\n * @returns {Object} - The sum of the two vectors.\n */","code":"function addVectors(v1, v2) {\n    return {x: v1.x + v2.x, y: v1.y + v2.y, z: v1.z + v2.z};\n}","lastGenerated":"2024-06-04T17:09:39.741Z"}
{"_id":"addVertex","projectName":"default","arguments":"solid, vertex","specification":"Adds a vertex to a solid. Depends on (Solid, Vertex).","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @param {Object} solid - The solid object to add the vertex to.\n * @param {Array|Number} vertex - The vertex to be added, can be either an array or a single number representing a 3D point (x,y,z).\n * Adds a new vertex to the specified solid's shell.","code":"function addVertex(solid, vertex) {\n    solid.shell.push(new shell());\n    var lastFace = solid.shell[solid.shell.length-1].faces[solid.shell[solid.shell.length-1].faces.length-1];\n    lastFace.vertices.push(vertex);\n}","lastGenerated":"2024-06-04T17:10:23.963Z"}
{"_id":"cloneCurve","projectName":"default","arguments":"curve","specification":"Creates a copy of a curve. Depends on (Curve).","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @param {Object} curve - The curve to be cloned.\n * @returns {Object} A new curve with the same points as the input curve.\n */","code":"function cloneCurve(curve) {\n    const clonedPoints = curve.points.map(point => ({ x: point.x, y: point.y, z: point.z }));\n    return { points: clonedPoints };\n}","lastGenerated":"2024-06-04T17:10:56.834Z"}
{"_id":"cloneMatrix","projectName":"default","arguments":"matrix","specification":"Creates a copy of a matrix. Depends on (Matrix).","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @param {Array[]} matrix The input matrix to be cloned.\n * @returns {{x: Array[], y: Array[], z: Array[]}} The cloned matrix with the same shape as the input.\n */","code":"function cloneMatrix(matrix) {\n    var result = [];\n    for (var i = 0; i < matrix.length; i++) {\n        result[i] = [];\n        for (var j = 0; j < matrix[0].length; j++) {\n            result[i][j] = matrix[i][j];\n        }\n    }\n    return {x: result, y: result, z: result};\n}","lastGenerated":"2024-06-04T17:11:45.616Z"}
{"_id":"clonePoint","projectName":"default","arguments":"point","specification":"Creates a copy of a point. Depends on (Point).","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @param {Object} point - The point to clone.\n * @returns {Object} A new point with the same x, y, and z values as the input point.\n */","code":"function clonePoint(point) {\n  return {x: point.x, y: point.y, z: point.z};\n}","lastGenerated":"2024-06-04T17:12:15.558Z"}
{"_id":"cloneSolid","projectName":"default","arguments":"solid","specification":"Creates a copy of a solid. Depends on (Solid).","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Creates a deep clone of the given solid object, including all its shells and faces.\n * @param {Solid} solid The solid object to be cloned.\n * @return {Solid} A new solid object that is a deep copy of the original.\n */","code":"function cloneSolid(solid) {\n    const shells = [];\n    for (const shell of solid.shells) {\n        const clonedShell = {};\n        for (const face of shell.faces) {\n            const clonedFace = new Face(face.controlPoints, []);\n            for (const loop of face.loops) {\n                let cloneLoop;\n                if (!loop.edges.length) {\n                    cloneLoop = new Loop([], []);\n                } else {\n                    const clonedEdge = new Edge(loop.edges[0]);\n                    let cloneEdges = [clonedEdge];\n                    for (let i = 1; i < loop.edges.length; i++) {\n                        const edge = loop.edges[i];\n                        cloneEdges.push(new Edge(edge));\n                    }\n                    cloneLoop = new Loop([], cloneEdges);\n                }\n                clonedFace.loops.push(cloneLoop);\n            }\n            clonedShell.faces.push(clonedFace);\n        }\n        for (let i = 0; i < shells.length; i++) {\n            const shell = solid.shells[i];\n            const clonedShellPart = {};\n            clonedShellPart.faces = [];\n            for (const face of shell.faces) {\n                clonedShellPart.faces.push(new Face(face));\n            }\n            shells.push(clonedShellPart);\n        }\n        const clonedSolid = new Solid([], shells);\n        return clonedSolid;\n    }\n}","lastGenerated":"2024-06-04T04:52:41.647Z"}
{"_id":"cloneSurface","projectName":"default","arguments":"surface","specification":"Creates a copy of a surface. Depends on (Surface).","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @param {Array.<Array.<{x: number, y: number, z: number}>}> surface \n * @returns {{data: Array.<Array.<{x: number, y: number, z: number}>>}}\n */","code":"function cloneSurface(surface) {\n  let result = [];\n  for (let i = 0; i < surface.length; i++) {\n    let point = [];\n    for (let j = 0; j < surface[i].length; j++) {\n      point.push({x: surface[i][j].x, y: surface[i][j].y, z: surface[i][j].z});\n    }\n    result.push(point);\n  }\n  return {data: result};\n}","lastGenerated":"2024-06-04T17:14:45.455Z"}
{"_id":"cloneVector","projectName":"default","arguments":"vector","specification":"Creates a copy of a vector. Depends on (Vector).","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @param {Object} vector - The original vector object.\n * @returns {Object} - A cloned copy of the input vector object.\n */","code":"function cloneVector(vector) {\n  return { x: vector.x, y: vector.y, z: vector.z };\n}","lastGenerated":"2024-06-04T17:15:10.198Z"}
{"_id":"createCone","projectName":"default","arguments":"baseRadius, topRadius, height","specification":"Creates a cone with given base radius, top radius, and height. Depends on (Surface, Solid, extrude, revolve).","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @param {number} baseRadius - Base radius of the cone.\n * @param {number} topRadius - Top radius of the cone.\n * @param {number} height - Height of the cone.\n * @returns {Array} An array containing the surface and solid definitions of the cone.\n */","code":"function createCone(baseRadius, topRadius, height) {\n  const surface = [];\n  for (let i = 0; i <= 1; i++) {\n    for (let j = 0; j < 2; j++) {\n      if (j === 0) {\n        let z = baseRadius;\n      } else {\n        let z = height - topRadius * Math.sqrt(3) / 2;\n      }\n      surface.push([i, j, z]);\n    }\n  }\n  const solid = [];\n  solid.push({faces: [[{x: 0, y: 0}, {x: 1, y: 0}, {x: 0.5, y: Math.sqrt(3) / 2}]], shell: 0});\n  return [surface, solid];\n}","lastGenerated":"2024-06-04T17:16:36.971Z"}
{"_id":"createCylinder","projectName":"default","arguments":"radius, height","specification":"Creates a cylinder with a given radius and height. Depends on (Surface, Solid, extrude, revolve).","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n* @param {number} radius - \n* @param {number} height -\n* @returns {} - \n*/","code":"function createCylinder(radius, height) {\n    const topBase = {x:0, y:0, z:height/2};\n    const bottomBase = {x:0, y:0, z:-height/transform({x:0,y:0,z:height/2},'Y',-height)};\n    \n    const baseProfile = createCone(radius, radius, height);\n    const topProfile = createCone(radius, radius, height).translate({'Z':height/2});\n    return extrude(baseProfile, {x:0,y:1,z:0}, height).union(revolve(topProfile, {x:0,y:1,z:0}, Math.PI*2));\n}","lastGenerated":"2024-06-04T17:17:45.494Z"}
{"_id":"createPrism","projectName":"default","arguments":"base, height","specification":"Creates a prism with a given base and height. Depends on (Curve, Surface, Solid, extrude).","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @name createPrism\n * @description Creates a prism shape given base and height.\n * @param {Object} base - Base point of the prism.\n * @param {Number} height - Height of the prism.\n * @returns {Object} The created prism solid.\n */","code":"function createPrism(base, height) {\n  const basePoint = {x:base.x, y:base.y, z:0};\n  const topPoint = {x:base.x, y:base.y, z:height};\n  const faceSurface = [{points:[basePoint, topPoint], curve:[1]}];\n  const shell = [{surfaces:faceSurface, curves:[]}];\n  const solid = [{shell:shell}];\n  extrude({profile:faceSurface[0]}, {axis: 'z'}, height);\n  return solid[0];\n}","lastGenerated":"2024-06-04T17:18:53.064Z"}
{"_id":"createSphere","projectName":"default","arguments":"radius","specification":"Creates a sphere with a given radius. Depends on (Surface, Solid, revolve).","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Creates a sphere with the given radius.\n *\n * @param {number} radius - The radius of the sphere.\n * @returns {{type: string, contents: [{type: string, edges: [], vertices: ({x: number, y: number, z: number}[])}, ...]}} - A representation of the sphere as a 3D object.\n */","code":"function createSphere(radius) {\n    const controlPoints = [{x:-radius, y:-radius*Math.sqrt(3)/2, z:0},{x:radius, y:-radius*Math.sqrt(3)/2, z:0},{x:0, y:radius*Math.sqrt(3)/2, z:0}];\n    const surface = {controlPoints};\n    return {type:\"Solid\", contents:[{type:\"Shell\", contents:[{type:\"Loop\", edges:[]}, {type:\"Face4\", vertices:controlPoints}]}]};\n}","lastGenerated":"2024-06-04T17:20:00.163Z"}
{"_id":"createTorus","projectName":"default","arguments":"majorRadius, minorRadius","specification":"Creates a torus with given major and minor radii. Depends on (Surface, Solid, revolve).","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @function createTorus\n * \n * Creates a torus (doughnut) shape given major and minor radii.\n * \n * @param {number} majorRadius - the outer radius of the torus\n * @param {number} minorRadius - the inner radius of the torus\n * \n * @return {{surface: Array}} - an object with a surface property containing an array of points that form the torus shape\n */","code":"function createTorus(majorRadius, minorRadius) {\n    const profilePoints = [];\n    for (let theta = 0; theta < Math.PI * 2; theta += Math.PI / 150) {\n        let phi = Math.acos(Math.cos(theta) - 0.5);\n        let x = majorRadius + minorRadius * Math.sin(phi);\n        let y = minorRadius * Math.cos(phi);\n        profilePoints.push({x, y});\n    }\n    const surface = [];\n    for (let i = 0; i < profilePoints.length; i++) {\n        surface.push([profilePoints[i], profilePoints[(i + 1) % profilePoints.length]]);\n    }\n    return {surface};\n}","lastGenerated":"2024-06-04T17:21:27.777Z"}
{"_id":"crossProduct","projectName":"default","arguments":"v1, v2","specification":"Computes the cross product of two vectors. Depends on (Vector).","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @param {Object} v1 - First vector.\n * @param {Object} v2 - Second vector.\n * @returns {Object} Cross product of the two input vectors.\n */","code":"function crossProduct(v1,v2){let x=v1.y*v2.z-v1.z*v2.y;let y=v1.z*v2.x-v1.x*v2.z;let z=v1.x*v2.y-v1.y*v2.x;return{x:x,y:y,z:z};}","lastGenerated":"2024-06-04T17:22:10.625Z"}
{"_id":"dotProduct","projectName":"default","arguments":"v1, v2","specification":"Computes the dot product of two vectors. Depends on (Vector).","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Calculates the dot product of two vectors.\n *\n * @param {Vector} v1 - The first vector.\n * @param {Vector} v2 - The second vector.\n * @return {Number} The dot product of the two vectors.\n */","code":"function dotProduct(v1, v2) {\n    return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n}","lastGenerated":"2024-06-04T17:22:47.297Z"}
{"_id":"evaluateCurve","projectName":"default","arguments":"curve, t","specification":"Evaluates a point on the curve at parameter t. Depends on (Curve, Point).","needsGeneration":"true","errorLogs":"{\"index\":896,\"lineNumber\":11,\"description\":\"Unexpected token )\"}","jsdoc":"/**\n * @param {Object} curve - The curve object.\n * @param {Number} t - The parameter value.\n * @returns {Object} The interpolated point on the curve.\n */","code":"function evaluateCurve(curve,t) {\n    let currentPoint=curve.points[0];\n    for(let i=1;i<curve.points.length;i++){\n        const nextPoint=curve.points[i];\n        if(t<=calculateDistanceBetweenPoints(currentPoint,nextPoint)/getCurveLength(curve)){\n            return createVectorFromPoints(currentPoint,nextPoint).scale((t/calculateDistanceBetweenPoints(currentPoint,nextPoint))*getVectorDirection(currentPoint,nextPoint));\n         }\n     }\n    currentPoint=curve.points[curve.points.length-1];\n    const remainingDistance=getCurveLength(curve)-calculateDistanceBetweenPoints(currentPoint,t);\n    return createVectorFromPoints(currentPoint,interpolatePointOnCurve(t,currentPoint,curve.points[curve.points.length-1])).scale((remainingDistance/getVectorDirection(currentPoint,curve.points[curve.points.length-1])).magnitude())*getVectorDirection(currentPoint,curve.points[curve.points.length-1]));\n}\n\nfunction calculateDistanceBetweenPoints(p1,p2){\n    return Math.sqrt(Math.pow(p2.x-p1.x,2)+Math.pow(p2.y-p1.y,2)+Math.pow(p2.z-p1.z,2));\n}\nfunction getCurveLength(curve){\n    let length=0;\n    for(let i=1;i<curve.points.length;i++){\n        length+=calculateDistanceBetweenPoints(curve.points[i-1],curve.points[i]);\n     }\n    return length;\n}\nfunction createVectorFromPoints(p1,p2){\n    return {x:p2.x-p1.x,y:p2.y-p1.y,z:p2.z-p1.z};\n}\nfunction getVectorDirection(p1,p2){\n    let vector=createVectorFromPoints(p1,p2);\n    let magnitude=Math.sqrt(Math.pow(vector.x,2)+Math.pow(vector.y,2)+Math.pow(vector.z,2));\n    return {x:vector.x/magnitude,y:vector.y/magnitude,z:vector.z/magnitude};\n}\nfunction interpolatePointOnCurve(t,p1,p2){\n    let ratio=t/calculateDistanceBetweenPoints(p1,p2);\n    return {x:p1.x+(p2.x-p1.x)*ratio,y:p1.y+(p2.y-p1.y)*ratio,z:p1.z+(p2.z-p1.z)*ratio};\n}","lastGenerated":"2024-06-04T17:25:54.576Z"}
{"_id":"evaluateSurface","projectName":"default","arguments":"surface, u, v","specification":"Evaluates a point on the surface at parameters u and v. Depends on (Surface, Point).","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @param {Object} surface \n * @param {Number} u \n * @param {Number} v \n * @returns {Point}\n */","code":"function evaluateSurface(surface, u, v) {\n    const controlPoints = surface.controlPoints;\n    \n    if (u === 0 && v === 0) return new Point();\n    \n    const uVector = [];\n    for (let i = 0; i < controlPoints.length - 1; i++) {\n        uVector.push([controlPoints[i][0] - controlPoints[i + 1][0], controlPoints[i][1] - controlPoints[i + 1][1], controlPoints[i][2] - controlPoints[i + 1][2]]);\n    }\n    \n    const point = new Point();\n    for (let i = 0; i < surface.loops.length; i++) {\n        let localU = 0;\n        let localV = 0;\n        for (let j = 0; j < surface.loops[i].length - 1; j++) {\n            localU += surface.loops[i][j][0] * uVector[j][0];\n            localV += surface.loops[i][j][0] * (evaluateCurve(surface.loops[i], v)[0] - surface.loops[i][j][0]) + surface.loops[i][j][1] * (evaluateCurve(surface.loops[i], v)[1] - surface.loops[i][j][1]);\n        }\n        \n        point = new Point(localU, localV, 0);\n    }\n    \n    let cv = [0, 0, 0];\n    for (let i = 0; i < uVector.length - 1; i++) {\n        cv[0] += (uVector[i][1] * localV - uVector[i][2] * (evaluateCurve(surface.loops[0], v)[1] - surface.loops[0][i][1]) + uVector[i][2] * (evaluateCurve(surface.loops[0], v)[2] - surface.loops[0][i][2])) / localU;\n        cv[1] += (uVector[i][2] * localV - uVector[i][0] * (evaluateCurve(surface.loops[0], v)[2] - surface.loops[0][i][2]) + uVector[i][0] * (evaluateCurve(surface.loops[0], v)[0] - surface.loops[0][i][0])) / localU;\n        cv[2] += (uVector[i][0] * localV - uVector[i][1] * (evaluateCurve(surface.loops[0], v)[0] - surface.loops[0][i][0]) + uVector[i][1] * (evaluateCurve(surface.loops[0], v)[1] - surface.loops[0][i][1])) / localU;\n    }\n    \n    return point.add(new Point(cv[0], cv[1], cv[2])).scale(localU);\n}","lastGenerated":"2024-06-04T17:29:51.041Z"}
{"_id":"extrude","projectName":"default","arguments":"profile, direction, distance","specification":"Creates a solid by extruding a profile along a direction for a certain distance. Depends on (Curve, Surface, Solid, translate, addFace, addShell).","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @name extrude\n * @description Extrudes a profile in the specified direction and distance.\n * @param {array} profile - The 3D points that make up the profile to be extruded.\n * @param {object} direction - The vector representing the direction of extrusion.\n * @param {number} distance - The distance to extrude the profile.\n * @returns {array} An array containing the original profile and the extruded shell.\n */","code":"function extrude(profile, direction, distance) {\n  let curve = [];\n  for (let i = 0; i < profile.length; i++) {\n    curve.push([profile[i].x, profile[i].y, profile[i].z]);\n  }\n  let shell = [];\n  let translationVector = [direction.x, direction.y, direction.z];\n  \n  for (let t = 0; t <= distance; t++) {\n    let point = [];\n    for (let i = 0; i < curve.length; i++) {\n      point.push(curve[i][0] + translationVector[0], \n                 curve[i][1] + translationVector[1], \n                 curve[i][2] + translationVector[2]);\n    }\n    shell.push(point);\n  }\n  \n  return [curve, shell];\n}","lastGenerated":"2024-06-04T17:31:14.915Z"}
{"_id":"findIntersection","projectName":"default","arguments":"edge1, edge2","specification":"Finds the intersection point of two edges. Depends on (Edge, Point, Vector, subtractVectors, crossProduct).","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Finds the intersection point of two edges in 3D space.\n * \n * @param {Array} edge1 - The first edge, represented as an array of vertices.\n * @param {Array} edge2 - The second edge, represented as an array of vertices.\n * @return {Vertex|Null} The intersection point if it lies within the bounds of both edges, otherwise null.","code":"function findIntersection(edge1, edge2) {\n    const v1 = subtractVectors(subtractVectors(vertex2 = edge1[1], vertex1 = edge1[0]), vertex3 = edge2[0]);\n    const v2 = crossProduct(subtractVectors(vertex4 = edge2[1], vertex1), subtractVectors(vertex3, vertex1));\n    let d0 = dotProduct(v1, v2);\n\n    if (Math.abs(d0) < Number.EPSILON) return null; // No intersection\n\n    let s = -dotProduct(subtractVectors(vertex1, vertex3), v2) / d0;\n    let t = -dotProduct(subtractVectors(vertex1, vertex4), v2) / d0;\n\n    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {\n        return Vertex.fromPoint(addVectors(vertex1, multiplyVectorByScalar(v1, s)));\n    } else {\n        return null; // No intersection within bounds\n    }\n}","lastGenerated":"2024-06-04T17:32:56.493Z"}
{"_id":"intersect","projectName":"default","arguments":"solid1, solid2","specification":"Computes the intersection of two solids. Depends on (Solid, Shell, Face, Loop, Edge, Vertex).","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @param {object} solid1 - First solid object.\n * @param {object} solid2 - Second solid object.\n * @return {array} An array of intersection objects, each containing the points where the two solids intersect.\n */","code":"function intersect(solid1, solid2) {\n    let intersections = [];\n    for (let i = 0; i < solid1.shells.length; i++) {\n        for (let j = 0; j < solid2.shells.length; j++) {\n            let currentShell1 = solid1.shells[i];\n            let currentShell2 = solid2.shells[j];\n            for (let k = 0; k < currentShell1.faces.length; k++) {\n                let face1 = currentShell1.faces[k];\n                for (let l = 0; l < currentShell2.faces.length; l++) {\n                    let face2 = currentShell2.faces[l];\n                    if (face1.isCoplanarWith(face2) && findIntersection(face1, face2).points.length > 0) {\n                        let intersectionPoints = findIntersection(face1, face2);\n                        intersections.push({ points: intersectionPoints });\n                    }\n                }\n            }\n        }\n    }\n    return intersections;\n}","lastGenerated":"2024-06-04T17:34:22.549Z"}
{"_id":"loft","projectName":"default","arguments":"profiles","specification":"Creates a solid by lofting between multiple profiles. Depends on (Curve, Surface, Solid, evaluateCurve, addFace, addShell).","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @param {Array} profiles - An array of profile points.\n * @returns {{type: string, shells: Array}} - The lofted solid object.\n *\n * Lofts a series of connected surfaces from the given profile points.\n */","code":"function loft(profiles) {\n    let shells = [];\n    for (let i = 0; i < profiles.length - 1; i++) {\n        let curveFrom = [profiles[i], projToProfileAxis(profiles[i + 1], profiles[i])];\n        let curveTo = evaluateCurve(curveFrom, t);\n        \n        let surface = {controlPoints: [], loops: [{vertices: [addVertex(shells[0], curveFrom), addVertex(shells[0], curveTo)]}]};;\n        \n        shells.push(createShell(surface));\n    }\n    \n    return {type: \"Solid\", shells: shells};\n}","lastGenerated":"2024-06-04T17:35:19.787Z"}
{"_id":"multiplyMatrices","projectName":"default","arguments":"m1, m2","specification":"Multiplies two matrices. Depends on (Matrix).","needsGeneration":"true","errorLogs":"{\"index\":234,\"lineNumber\":13,\"description\":\"Unexpected end of input\"}","jsdoc":"/**\n * Multiply two matrices together.\n *\n * @param {Array<Array<number>>} m1 The first matrix.\n * @param {Array<Array<number>>} m2 The second matrix.\n * @returns {Array<Array<number>>} The product of the two input matrices.\n */","code":"function multiplyMatrices(m1, m2) {\nlet result=[];\nfor(let i=0;i<m1.length;i++){\nresult[i]=[];\nfor(let j=0;j<m2[0].length;j++){\nlet sum=0;\nfor(let k=0;k<m1[0].length;k++){\nsum+=m1[i][k]*m2[k][j];\n}\nresult[i][j]=sum;\n}\n}\nreturn result;","lastGenerated":"2024-06-04T17:36:22.704Z"}
{"_id":"multiplyMatrixVector","projectName":"default","arguments":"matrix, vector","specification":"Multiplies a matrix by a vector. Depends on (Matrix, Vector).","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @param {Array} matrix - The input matrix.\n * @param {Object} vector - The input vector.\n * @returns {Object} The result of the matrix-vector multiplication.\n */","code":"function multiplyMatrixVector(matrix, vector) {\n  let result = {x: 0, y: 0, z: 0};\n  for (let i = 0; i < matrix.length; i++) {\n    let sum = {x: 0, y: 0, z: 0};\n    for (let j = 0; j < vector.x; j++) {\n      sum.x += matrix[i][j] * vector.y[j];\n      sum.y += matrix[i][j+1] * vector.y[j];\n      sum.z += matrix[i][j+2] * vector.y[j];\n    }\n    result.x += sum.x;\n    result.y += sum.y;\n    result.z += sum.z;\n  }\n  return {x: result.x, y: result.y, z: result.z};\n}","lastGenerated":"2024-06-04T17:37:48.633Z"}
{"_id":"on","jsdoc":"/**\n * @param {Object} p - point coordinates (x, y, z)\n * @returns {number} distance from origin if x, y, and z are defined; NaN otherwise\n */","code":"function undefined(p) {\n    if (p.x && p.y && p.z) {\n        return Math.sqrt(Math.pow(p.x - 0, 2) + Math.pow(p.y - 0, 2) + Math.pow(p.z - 0, 2));\n    } else {\n        return NaN;\n    }\n}","lastGenerated":"2024-06-04T16:54:43.265Z","errorLogs":"","needsGeneration":"false"}
{"_id":"projectPointOnSurface","projectName":"default","arguments":"point, surface","specification":"Projects a point onto a surface. Depends on (Point, Surface, evaluateSurface).","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Projects a point onto a surface.\n * @param {Object} point - The point to project.\n * @param {Object} surface - The surface to project onto.\n * @return {Object} The projected point.\n */","code":"function projectPointOnSurface(point, surface) {\n  const [u, v] = evaluateSurface(surface);\n  return { x: u * point.x + v * surface.u, y: u * point.y + v * surface.v, z: u * point.z };\n}","lastGenerated":"2024-06-04T17:38:36.350Z"}
{"_id":"revolve","projectName":"default","arguments":"profile, axis, angle","specification":"Creates a solid by revolving a profile around an axis by a given angle. Depends on (Curve, Surface, Solid, rotate, addFace, addShell).","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @param {Array<Point>} profile The 3D profile to revolve.\n * @param {Vector} axis The axis of rotation.\n * @param {Number} angle The angle of rotation in radians.\n * @return {Solid} The resulting solid after revolving the profile.\n */","code":"function revolve(profile, axis, angle) {\n  let curve = Curve([profile]);\n  let matrix = new Matrix();\n  let rotatedProfile = [];\n  for (let i = 0; i < profile.length; i++) {\n    let vector = Vector.subtract(new Point(), profile[i]);\n    rotatedProfile.push(Matrix.multiplyVector(matrix, vector));\n  }\n  let solid = Solid();\n  for (let loop of curve.loops) {\n    let shell = Shell();\n    for (let face of loop.faces) {\n      addFace(shell, new Face(rotatedProfile, face.controlPoints));\n    }\n    addShell(solid, shell);\n  }\n  return solid;\n}","lastGenerated":"2024-06-04T17:48:34.793Z"}
{"_id":"rotate","projectName":"default","arguments":"point, axis, angle","specification":"Rotates a point around an axis by an angle. Depends on (Point, Vector, Matrix, multiplyMatrixVector).","needsGeneration":"true","errorLogs":"{\"index\":656,\"lineNumber\":10,\"description\":\"Unexpected token ;\"}","jsdoc":"/**\n * @param {Object} point - The point to be rotated.\n * @param {Object} axis - The axis of rotation.\n * @param {Number} angle - The angle of rotation in radians.\n * @returns {Object} The rotated point.\n */","code":"function rotate(point, axis, angle) {\n    var u = {x: point.x - axis.x, y: point.y - axis.y, z: point.z - axis.z};\n    var uMag = Math.sqrt(u.x*u.x + u.y*u.y + u.z*u.z);\n    var xAxis = {x: axis.x / uMag, y: 0, z: 0};\n    var yAxis = {x: 0, y: axis.y / uMag, z: 0};\n    var zAxis = {x: 0, y: 0, z: axis.z / uMag};\n\n    var xRotationMatrix = [[Math.cos(angle), -Math.sin(angle)*u.x/uMag, Math.sin(angle)*u.z/uMag],\n                             [Math.sin(angle)*u.y/uMag + Math.cos(angle)*(axis.y/axisMag), Math.cos(angle) - Math.sin(angle)*axis.y/axisMag*u.z/uMag,\n                             [-Math.sin(angle)*u.z/uMag + Math.cos(angle)*(axis.z/axisMag)]];\n    var yRotationMatrix = [[Math.cos(angle), 0, -Math.sin(angle)],\n                             [0, Math.cos(angle), 0],\n                             [Math.sin(angle), 0, Math.cos(angle)]];\n    var zRotationMatrix = [[Math.cos(angle), -Math.sin(angle)*u.x/uMag, Math.sin(angle)*u.y/uMag],\n                             [Math.sin(angle)*u.z/uMag + Math.cos(angle)*(axis.z/axisMag), 0,\n                             [-Math.sin(angle)*u.y/uMag + Math.cos(angle)*(axis.y/axisMag)]];\n    var x = point.x;\n    var y = point.y;\n    var z = point.z;\n\n    var rotatedX = (xRotationMatrix[0][0]*x + xRotationMatrix[0][1]*(y - axis.y) + xRotationMatrix[0][2]*(z - axis.z)) * uMag + axis.x;\n    var rotatedY = (xRotationMatrix[1][0]*(x - axis.x) + yRotationMatrix[1][1]*y + zRotationMatrix[1][2]*(z - axis.z)) * uMag + axis.y;\n    var rotatedZ = (xRotationMatrix[2][0]*(x - axis.x) + xRotationMatrix[2][1]*(y - axis.y) + zRotationMatrix[2][2]*(z - axis.z)) * uMag + axis.z;\n\n    return {x: rotatedX, y: rotatedY, z: rotatedZ};\n}","lastGenerated":"2024-06-04T17:51:01.424Z"}
{"_id":"scale","projectName":"default","arguments":"point, scaleFactor","specification":"Scales a point by a factor. Depends on (Point).","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @param {Object} point - The point to scale.\n * @param {number} scaleFactor - The factor by which to scale the point.\n * @returns {Object} Scaled point with x, y, and z coordinates.\n */","code":"function scale(point,scaleFactor){return{ x:point.x*scaleFactor,y:point.y*scaleFactor,z:point.z*scaleFactor};}","lastGenerated":"2024-06-04T17:51:27.384Z"}
{"_id":"subtract","projectName":"default","arguments":"solid1, solid2","specification":"Computes the difference between two solids. Depends on (Solid, Shell, Face, Loop, Edge, Vertex).","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @param {Object} solid1 \n * @param {Object} solid2 \n * @returns {Object}\n */","code":"function subtract(solid1, solid2) {\n    let shellDifference = new Shell();\n    \n    const clonedSolid1 = cloneSolid(solid1);\n    const clonedSolid2 = cloneSolid(solid2);\n    \n    for (const shell2 of Solids.getShells(clonedSolid2)) {\n        let loopDifference;\n        \n        for (const loop2 of Solids.getLoops(shell2)) {\n            let faceDifference = new Face();\n            \n            for (const face2 of Solids.getFaces(loop2)) {\n                let edgeDifference = [];\n                \n                const edges2 = Solids.getEdges(face2);\n                for (const edge2 of edges2) {\n                    if (!Solid.hasEdge(edgeDifference, edge2)) {\n                        let vertexDifference;\n                        \n                        const vertices2 = Solids.getVertices(edge2);\n                        for (const vertex2 of vertices2) {\n                            if (!Solid.hasVertex(vertexDifference, vertex2)) {\n                                let pointDifference;\n                                \n                                const points1 = Solids.getPoints(clonedSolid1);\n                                if (!points1.some(point => Vector.equals(vertex2, point))) {\n                                    pointDifference = new Point(vertex2.x, vertex2.y, vertex2.z);\n                                } else {\n                                    let existingPoint;\n                                    for (const point of points1) {\n                                        if (Vector.equals(vertex2, point)) {\n                                            existingPoint = point;\n                                            break;\n                                        }\n                                    }\n                                    \n                                    if (!existingPoint) continue;\n                                    \n                                    pointDifference = subtractVectors(point, existingPoint);\n                                }\n                                \n                                edgeDifference.push(pointDifference);\n                            }\n                        }\n                        \n                        faceDifference.addEdge(edgeDifference);\n                    }\n                }\n                \n                loopDifference = subtractLoops(loop2, loopDifference);\n            }\n            \n            shellDifference.addLoop(loopDifference);\n        }\n        \n        addShell(shellDifference, clonedSolid1);\n    }\n    \n    return subtractSolids(clonedSolid1, solid2);\n}","lastGenerated":"2024-06-04T17:53:31.852Z"}
{"_id":"subtractVectors","projectName":"default","arguments":"v1, v2","specification":"Subtracts one vector from another. Depends on (Vector).","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @param {Object} v1 First vector.\n * @param {Object} v2 Second vector.\n * @returns {Object} Resultant vector after subtracting v2 from v1.\n */","code":"function subtractVectors(v1,v2){return{xA:v1.x-v2.x,yA:v1.y-v2.y,zA:v1.z-v2.z};}","lastGenerated":"2024-06-04T17:53:58.695Z"}
{"_id":"sweep","projectName":"default","arguments":"profile, path","specification":"Creates a solid by sweeping a profile along a path. Depends on (Curve, Surface, Solid, evaluateCurve, addFace, addShell).","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @param {Object} profile - \n * @param {String} path - \n * @returns {void}\n */","code":"function sweep(profile, path) {\n    const curve = evaluateCurve(path);\n    let solid = null;\n\n    for (let t of curve.getPoints()) {\n        const edge = new Edge(t.previousPoint, t.point);\n        if (!solid) {\n            solid = new Solid();\n        }\n        addFace(solid, profile, edge);\n        addShell(solid, profile, edge);\n    }\n}","lastGenerated":"2024-06-04T17:54:37.179Z"}
{"_id":"translate","projectName":"default","arguments":"point, vector","specification":"Translates a point by a vector. Depends on (Point, Vector, addVectors).","needsGeneration":"true","errorLogs":"{\"index\":153,\"lineNumber\":5,\"description\":\"Unexpected end of input\"}","jsdoc":"/**\n * @param {Object} point - Point to translate.\n * @param {Object} vector - Vector to add to the point.\n * @returns {Object} Translated point with updated x, y, and z coordinates.\n */","code":"function translate(point, vector) {\n    let x = point.x + vector.x;\n    let y = point.y + vector.y;\n    let z = point.z + vector.z;\n    return {x, y, z};","lastGenerated":"2024-06-04T17:55:09.285Z"}
{"_id":"union","projectName":"default","arguments":"solid1, solid2","specification":"Computes the union of two solids. Depends on (Solid, Shell, Face, Loop, Edge, Vertex).","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @param {Solid} solid1\n * @param {Solid} solid2\n * @return {Solid}\n */","code":"function union(solid1, solid2) {\n    let shells = [];\n    for (let i = 0; i < solid1.shells.length; i++) {\n        shells.push(cloneShell(solid1.shells[i]));\n    }\n    shells = addShells(shells, cloneShellArray(solid2.shells));\n\n    let faces = [];\n    for (let i = 0; i < solid1.faces.length; i++) {\n        faces.push(cloneFace(solid1.faces[i]));\n    }\n    for (let i = 0; i < solid2.faces.length; i++) {\n        faces.push(cloneFace(solid2.faces[i]));\n    }\n\n    let loops = [];\n    for (let i = 0; i < solid1.loops.length; i++) {\n        loops.push(cloneLoop(solid1.loops[i]));\n    }\n    for (let i = 0; i < solid2.loops.length; i++) {\n        loops.push(cloneLoop(solid2.loops[i]));\n    }\n\n    let edges = [];\n    for (let i = 0; i < solid1.edges.length; i++) {\n        edges.push(cloneEdge(solid1.edges[i], solid2.vertices));\n    }\n    for (let i = 0; i < solid2.edges.length; i++) {\n        edges.push(cloneEdge(solid2.edges[i], solid1.vertices, solid2.vertices));\n    }\n\n    let unionSolid = new Solid();\n    unionSolid.shells = shells;\n    unionSolid.faces = faces;\n    unionSolid.loops = loops;\n    unionSolid.edges = edges;\n    unionSolid.vertices = solid1.vertices.concat(solid2.vertices);\n\n    return unionSolid;\n}\n\nfunction cloneShell(shell) {\n    // implement me\n}\n\nfunction addShells(shells, shellArray) {\n    // implement me\n}\n\nfunction cloneShellArray(shellArray) {\n    // implement me\n}\n\nfunction cloneFace(face) {\n    // implement me\n}\n\nfunction cloneLoop(loop) {\n    // implement me\n}\n\nfunction cloneEdge(edge, vertices) {\n    // implement me\n}","lastGenerated":"2024-06-04T17:57:22.564Z"}
