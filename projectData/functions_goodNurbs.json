{"_id":"analyzeSurfaceCurvature","projectName":"default","arguments":"surface, paramU, paramV","specification":"Analyzes the curvature of a NURBS surface at given parameters.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Analyzes the surface curvature of a given Bezier surface.\n *\n * @param {Object} surface - The Bezier surface to analyze.\n * @param {number} paramU - The U parameter value.\n * @param {number} paramV - The V parameter value.\n * @return {number} The surface curvature at the specified (u, v) parameters.\n */","code":"function analyzeSurfaceCurvature(surface, paramU, paramV) {\n    var d2dx = 0;\n    var d2dy = 0;\n    var d2dz = 0;\n\n    for (var i = 0; i < surface.controlPoints.length; i++) {\n        var controlPoint = surface.controlPoints[i];\n        var weightU = surface.weights[i];\n        var weightV = surface.weights[(i + 1) % surface.weights.length];\n\n        if (paramU === 0 && paramV === 0) {\n            d2dx += weightU * weightV * (controlPoint.x * controlPoint.x);\n            d2dy += weightU * weightV * (controlPoint.y * controlPoint.y);\n            d2dz += weightU * weightV * (controlPoint.z * controlPoint.z);\n        } else if (paramU === 0) {\n            var tangentX = (surface.weights[(i + 1) % surface.weights.length] - weightU) / surface.knotsV[i];\n            var tangentY = (surface.weights[(i + 1) % surface.weights.length] * controlPoint.z - weightU * controlPoint.z) / surface.knotsV[i];\n            var tangentZ = (weightU * controlPoint.y - surface.weights[(i + 1) % surface.weights.length] * controlPoint.y) / surface.knotsV[i];\n\n            d2dx += weightU * weightV * (tangentX * tangentX);\n            d2dy += weightU * weightV * (tangentY * tangentY);\n            d2dz += weightU * weightV * (tangentZ * tangentZ);\n        } else if (paramV === 0) {\n            var tangentX = (surface.weights[(i + 1) % surface.weights.length] - weightU) / surface.knotsU[i];\n            var tangentY = (weightU * controlPoint.y - surface.weights[(i + 1) % surface.weights.length] * controlPoint.y) / surface.knotsU[i];\n            var tangentZ = (surface.weights[(i + 1) % surface.weights.length] * controlPoint.z - weightU * controlPoint.z) / surface.knotsU[i];\n\n            d2dx += weightU * weightV * (tangentX * tangentX);\n            d2dy += weightU * weightV * (tangentY * tangentY);\n            d2dz += weightU * weightV * (tangentZ * tangentZ);\n        } else {\n            var uParam = surface.knotsU[Math.min(Math.floor((paramU - surface.knotsU[0]) / (surface.knotsU[1] - surface.knotsU[0])), surface.controlPoints.length - 2)];\n            var vParam = surface.knotsV[Math.min(Math.floor((paramV - surface.knotsV[0]) / (surface.knotsV[1] - surface.knotsV[0])), surface.controlPoints.length - 2)];\n\n            for (var j = 0; j < surface.controlPoints.length; j++) {\n                if (Math.abs(surface.weights[j] * (uParam - surface.knotsU[j])) < Math.abs(weightU * (uParam - uParam))) {\n                    weightU = surface.weights[j];\n                    uParam = surface.knotsU[j];\n                }\n                if (Math.abs(surface.weights[(j + 1) % surface.weights.length] * (vParam - surface.knotsV[(j + 1) % surface.weights.length])) < Math.abs(weightV * (vParam - vParam))) {\n                    weightV = surface.weights[(j + 1) % surface.weights.length];\n                    vParam = surface.knotsV[(j + 1) % surface.weights.length];\n                }\n            }\n\n            var tangentX = (weightU * controlPoint.x - weightV * surface.controlPoints[(vParam - surface.knotsV[0]) / (surface.knotsV[1] - surface.knotsV[0])] * surface.controlPoints[0].x) / ((uParam - surface.knotsU[0]) * (vParam - surface.knotsV[0]));\n            var tangentY = (weightU * controlPoint.y - weightV * surface.controlPoints[(vParam - surface.knotsV[0]) / (surface.knotsV[1] - surface.knotsV[0])] * surface.controlPoints[0].y) / ((uParam - surface.knotsU[0]) * (vParam - surface.knotsV[0]));\n            var tangentZ = (weightU * controlPoint.z - weightV * surface.controlPoints[(vParam - surface.knotsV[0]) / (surface.knotsV[1] - surface.knotsV[0])] * surface.controlPoints[0].z) / ((uParam - surface.knotsU[0]) * (vParam - surface.knotsV[0]));\n\n            d2dx += weightU * weightV * (tangentX * tangentX);\n            d2dy += weightU * weightV * (tangentY * tangentY);\n            d2dz += weightU * weightV * (tangentZ * tangentZ);\n        }\n    }\n\n    var curvature = Math.sqrt(d2dx + d2dy + d2dz) / surface.surfaceArea;\n\n    return curvature;\n}","lastGenerated":"2024-05-27T13:50:33.039Z"}
{"_id":"blendPoints","projectName":"default","arguments":"p1, p2, radius","specification":"Blends two points `p1` and `p2` along the line connecting them by a specified `radius`, resulting in a new point that lies at distance `radius` from both original points on the same z-axis. This function calculates the x and y coordinates of the blended point based on the provided radius and the z coordinate, which remains unchanged for all three points.","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Blends two points along a given radius to create an intermediate point on the line segment connecting them.\n * If the z-coordinates of the input points are equal, it returns `pointA` as there is no need for interpolation in the Z direction.\n * The function calculates the blended x and y coordinates based on the provided radius and distance to the axis formed by pointA and pointB.\n * \n * @function blendPoints\n * @param {Object} pointA - The starting point with properties `x`, `y`, and `z`.\n * @param {Object} pointB - The ending point with properties `x`, `y`, and `z`.\n * @param {number} radius - The radius within which to calculate the blended point. A smaller radius will result in a closer blend between the two points, while a larger radius will create an intermediate point further from both original points.\n * @returns {Object} An object representing the blended point with properties `x`, `y`, and `z`. The resulting `x` and `y` values are interpolated based on the provided radius and distance to the axis formed by pointA and pointB, while the `z` value is directly taken from either pointA or pointB depending on their equality.\n */","code":"function blendPoints(pointA, pointB, radius) {\n  const height = pointA.z === pointB.z ? 0 : Math.min(pointA.z, pointB.z);\n  const distanceToAxis = Math.max(Math.abs(pointA.x - pointB.x), Number.EPSILON);\n  \n  return { x: (radius - height) / distanceToAxis * (pointA.x + pointB.x) / 2,\n          y: (radius - height) / distanceToAxis * (pointA.y + pointB.y) / 2,\n          z: height };\n}","lastGenerated":"2024-06-02T02:31:48.923Z"}
{"_id":"blendSurfaces","projectName":"default","arguments":"surface1, surface2, blendRadius","specification":"Blends between two surfaces with a specified radius.","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Blends two surfaces together using a given blend radius to create a smooth transition between them.\n * @param {Object} surface1 - The first input surface, represented as an object with properties defining the NURBS surface.\n * @param {Object} surface2 - The second input surface, represented similarly to `surface1`.\n * @param {number} blendRadius - The radius of the blending area where the two surfaces will be merged together smoothly.\n * @returns {Object} A new NURBS surface representing the result of blending `surface1` and `surface2` within a circular radius defined by `blendRadius`.\n */","code":"function blendSurfaces(surface1, surface2, blendRadius) {\n    const pointsOnSurface1 = curveToPolyline(surface1, tolerance);\n    const pointsOnSurface2 = curveToPolyline(surface2, tolerance);\n    \n    let resultPoints = [];\n    \n    for (let i = 0; i < Math.max(pointsOnSurface1.length, pointsOnSurface2.length); i++) {\n        if (i < pointsOnSurface1.length) {\n            const point1 = pointsOnSurface1[i];\n            const point2 = analyzeSurfaceCurvature(surface1, paramU, paramV);\n            \n            let blendResult;\n            if (BooleanDifference(point1, surface2)) {\n                blendResult = BooleanUnion(blendPoints(point1, point2, blendRadius));\n            } else {\n                blendResult = BooleanIntersection(blendPoints(point1, point2, blendRadius), surface2);\n            }\n        } else {\n            const point1 = pointsOnSurface2[i];\n            const point2 = analyzeSurfaceCurvature(surface2, paramU, paramV);\n            \n            let blendResult;\n            if (BooleanDifference(point1, surface1)) {\n                blendResult = BooleanUnion(blendPoints(point1, point2, blendRadius));\n            } else {\n                blendResult = BooleanIntersection(blendPoints(point1, point2, blendRadius), surface1);\n            }\n        }\n        \n        resultPoints.push(blendResult);\n    }\n    \n    return createNURBSSurface(degreeU, degreeV, resultPoints, weights, knotsU, knotsV);\n}","lastGenerated":"2024-06-01T05:06:49.920Z"}
{"_id":"booleanDifference","projectName":"default","arguments":"shape1, shape2","specification":"Performs a boolean difference operation between two shapes.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Calculate the difference between two shapes.\n *\n * @param {Object} shape1 - The first shape to compare.\n * @param {Object} shape2 - The second shape to compare.\n * @return {Object} The resulting shape, if a difference was found.\n */","code":"function booleanDifference(shape1, shape2) {\n    let result = null;\n    if (shape1 && shape2) {\n        if (typeof shape1 === \"object\" && typeof shape2 === \"object\") {\n            if (Object.prototype.toString.call(shape1) === \"[object NURBSSurface]\" && Object.prototype.toString.call(shape2) === \"[object NURBSSurface]\") {\n                let surfaceResult = null;\n                let paramUArray = [];\n                let paramVArray = [];\n                for (let paramU = 0; paramU <= 1; paramU += 0.01) {\n                    for (let paramV = 0; paramV <= 1; paramV += 0.01) {\n                        if (!booleanIntersection(shape1, blendSurfaces(shape2, shape1, Math.sqrt(Math.pow(paramU - 0.5, 2) + Math.pow(paramV - 0.5, 2))))) {\n                            surfaceResult = closeSurface(surfaceResult ? surfaceResult : createNURBSSurface(3, [{x: paramU, y: paramV, z: 0}], [1], [0, 1, 1, 0], [0, 1], [0, 1]));\n                        }\n                    }\n                }\n                result = surfaceResult;\n            } else {\n                console.error(\"Unsupported shape type\");\n            }\n        } else {\n            console.error(\"Invalid input shapes\");\n        }\n    } else {\n        console.error(\"Invalid input arguments\");\n    }\n    return result;\n}","lastGenerated":"2024-05-27T14:04:05.982Z"}
{"_id":"booleanIntersection","projectName":"default","arguments":"shape1, shape2","specification":"Performs a boolean intersection operation between two shapes.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Returns an array of points that are common to both shape1 and shape2.\n *\n * @param {Array} shape1 - The first shape to compare.\n * @param {Array} shape2 - The second shape to compare.\n * @return {Array} An array of points that are common to both shapes.\n */","code":"function booleanIntersection(shape1, shape2) {\n    var result = [];\n    for (var i = 0; i < shape1.length; i++) {\n        for (var j = 0; j < shape2.length; j++) {\n            if (shape1[i].x === shape2[j].x && shape1[i].y === shape2[j].y && shape1[i].z === shape2[j].z) {\n                result.push({ x: shape1[i].x, y: shape1[i].y, z: shape1[i].z });\n            }\n        }\n    }\n    return result;\n}","lastGenerated":"2024-05-27T14:01:41.946Z"}
{"_id":"booleanUnion","projectName":"default","arguments":"shape1, shape2","specification":"Performs a boolean union operation between two shapes.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n* Combines two shapes by unioning their points.\n*\n* @param {Object} shape1 - The first shape to combine.\n* @param {Object} shape2 - The second shape to combine.\n*/","code":"function booleanUnion(shape1, shape2) {\n    for (var point1 in shape1.points) {\n        var found = false;\n        for (var point2 in shape2.points) {\n            if (distanceBetween(point1, point2) <= 0.00001) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            shape1.points.push(point1);\n        }\n    }\n    for (var point2 in shape2.points) {\n        var found = false;\n        for (var point1 in shape1.points) {\n            if (distanceBetween(point1, point2) <= 0.00001) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            shape1.points.push(point2);\n        }\n    }\n}\n\nfunction distanceBetween(p1, p2) {\n    return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2) + Math.pow(p2.z - p1.z, 2));\n}","lastGenerated":"2024-05-27T14:00:04.000Z"}
{"_id":"chamferEdges","projectName":"default","arguments":"edge1, edge2, distance","specification":"Creates a chamfer between two edges.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n* Chamfers the edges of two surfaces by creating a blended curve and subtracting it from one of the original edges.\n*\n* @param {Object} edge1 - The first surface edge.\n* @param {Object} edge2 - The second surface edge.\n* @param {Number} distance - The distance at which to blend the curves.\n* @returns {Object} The resulting chamfered edge.","code":"function chamferEdges(edge1, edge2, distance) {\n    const p1 = analyzeSurfaceCurvature(edge1, null, null);\n    const p2 = analyzeSurfaceCurvature(edge2, null, null);\n    const curve1 = createNURBSCurve(3, [p1.x, p1.y, p1.z], [], []);\n    const curve2 = createNURBSCurve(3, [p2.x, p2.y, p2.z], [], []);\n    const blendedCurve = blendSurfaces(curve1, curve2, distance);\n    return booleanDifference(blendedCurve, edge1);\n}","lastGenerated":"2024-05-27T05:35:26.685Z"}
{"_id":"closeSurface","projectName":"default","arguments":"surface","specification":"Closes an open surface to form a solid.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Closes the surface by adding new control points and weights.\n *\n * @param {Object} surface The surface to close.\n * @returns {Object} Closed surface with updated control points, weights, knotsU, and knotsV.\n */","code":"function closeSurface(surface) {\n    var degreeU = surface.degreeU;\n    var degreeV = surface.degreeV;\n    var controlPoints = surface.controlPoints;\n    var weights = surface.weights;\n    var knotsU = surface.knotsU;\n    var knotsV = surface.knotsV;\n\n    for (var i = 0; i < controlPoints.length; i++) {\n        if (!knotsU.includes(knotsU[i])) {\n            knotsU.push(knotsU[i]);\n        }\n        if (!knotsV.includes(knotsV[i])) {\n            knotsV.push(knotsV[i]);\n        }\n    }\n\n    var closedControlPoints = [];\n    for (var i = 0; i < controlPoints.length; i++) {\n        var point = controlPoints[i];\n        var nextPoint;\n        if (i == controlPoints.length - 1) {\n            nextPoint = controlPoints[0];\n        } else {\n            nextPoint = controlPoints[i + 1];\n        }\n        closedControlPoints.push({x: point.x, y: point.y, z: point.z});\n        closedControlPoints.push({x: (point.x + nextPoint.x) / 2, y: (point.y + nextPoint.y) / 2, z: (point.z + nextPoint.z) / 2});\n    }\n\n    var closedWeights = [];\n    for (var i = 0; i < weights.length; i++) {\n        closedWeights.push(weights[i]);\n        closedWeights.push(weights[i] * -1);\n    }\n\n    var closedKnotsU = [...knotsU];\n    closedKnotsU[closedKnotsU.length - 1] = knotsU[0];\n\n    var closedKnotsV = [...knotsV];\n    closedKnotsV[closedKnotsV.length - 1] = knotsV[0];\n\n    return {degreeU: degreeU, degreeV: degreeV, controlPoints: closedControlPoints, weights: closedWeights, knotsU: closedKnotsU, knotsV: closedKnotsV};\n}\n","lastGenerated":"2024-05-27T13:39:35.724Z"}
{"_id":"createNURBSCurve","projectName":"default","arguments":"degree, controlPoints, weights, knots","specification":"Creates a NURBS curve.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @name createNURBSCurve\n * @function Creates a NURBS curve given the degree, control points, weights and knots.\n * @param {number} degree - The degree of the curve.\n * @param {Array.<{x: number, y: number}>} controlPoints - An array of 2D points that define the shape of the curve.\n * @param {Array<number>} weights - An array of numbers representing the weights for each control point.\n * @param {Array<number>} knots - An array of numbers representing the knot values for the curve.\n * @returns {{weights: Array<number>, knots: Array<number>}} A object containing the weighted knots.\n */","code":"function createNURBSCurve(degree, controlPoints, weights, knots) {\n    var n = controlPoints.length;\n    var d = degree + 1;\n    for (var i = 0; i < n; i++) {\n        var point = controlPoints[i];\n        var knot = knots[i];\n        for (var j = 0; j < d; j++) {\n            weights[i * d + j] *= Math.pow((point.x - knot) / (knots[n - 1] - knot), degree);\n        }\n    }\n    return { weights: weights, knots: knots };\n}","lastGenerated":"2024-05-28T00:43:09.383Z"}
{"_id":"createNURBSSurface","projectName":"default","arguments":"degreeU, degreeV, controlPoints, weights, knotsU, knotsV","specification":"Creates a NURBS surface.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Creates a Nurbs surface given the degree in the U and V directions,\n * control points, weights, and knots.\n *\n * @param {number} degreeU - The degree of the surface in the U direction\n * @param {number} degreeV - The degree of the surface in the V direction\n * @param {array} controlPoints - A 2D array of control points\n * @param {array} weights - A 1D array of weights for each control point\n * @param {array} knotsU - A 1D array of knots in the U direction\n * @param {array} knotsV - A 1D array of knots in the V direction\n *\n * @return {array} The Nurbs surface as a 2D array of points\n */","code":"function createNURBSSurface(degreeU, degreeV, controlPoints, weights, knotsU, knotsV) {\n    var surface = [];\n    for (var i = 0; i < controlPoints.length; i++) {\n        surface.push([]);\n        for (var j = 0; j < controlPoints[0].length; j++) {\n            surface[i].push(0);\n        }\n    }\n    for (var i = 0; i < controlPoints.length; i++) {\n        for (var j = 0; j < controlPoints[0].length; j++) {\n            var u = knotsU[j];\n            for (var k = 0; k < degreeV + 1; k++) {\n                surface[i][j] += weights[k] * Math.pow(1 - u, k) * Math.pow(u, degreeV - k);\n            }\n        }\n    }\n    return surface;\n}","lastGenerated":"2024-05-27T05:53:32.669Z"}
{"_id":"createPipeSurface","projectName":"default","arguments":"curve, radius","specification":"Creates a pipe surface around a NURBS curve.","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Creates a pipe surface from a given curve with specified radius.\n * @param {Array} curve - The input curve as an array of points.\n * @param {number} radius - The radius of the blending circle for creating the pipe surface.\n * @returns {Object} A new NURBS surface created by blending curves and appending them to a list.\n */","code":"function createPipeSurface(curve, radius) {\n    let newCurves = [];\n    for (let i = 0; i < curve.length - 1; i++) {\n        let p1 = curve[i], p2 = curve[i + eatingRadius];\n        let blendSurface = blendSurfaces(p1, p2, radius);\n        newCurves.push(blendSurface);\n    }\n    return createNURBSSurface(newCurves);\n}","lastGenerated":"2024-06-01T04:37:42.037Z"}
{"_id":"createRuledSurface","projectName":"default","arguments":"curve1, curve2","specification":"Creates a ruled surface between two NURBS curves.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Creates a ruled surface from two curves.\n *\n * @param {Object} curve1 - The first curve.\n * @param {Object} curve2 - The second curve.\n * @return {Object} An object representing the created ruled surface, with x, y, and z coordinates.\n */","code":"function createRuledSurface(curve1, curve2) {\n    let knotsU = [];\n    let knotsV = [];\n    for (let i = 0; i < curve1.controlPoints.length; i++) {\n        knotsU.push(i / (curve1.controlPoints.length - 1));\n    }\n    for (let j = 0; j < curve2.controlPoints.length; j++) {\n        knotsV.push(j / (curve2.controlPoints.length - 1));\n    }\n    let controlPoints = [];\n    for (let i = 0; i < curve1.controlPoints.length; i++) {\n        for (let j = 0; j < curve2.controlPoints.length; j++) {\n            controlPoints.push([curve1.controlPoints[i][0], curve1.controlPoints[i][1], curve2.controlPoints[j][2]]);\n        }\n    }\n    let degreeU = 3;\n    let degreeV = 3;\n    return { x: controlPoints.map(function(point) { return point[0]; }), y: controlPoints.map(function(point) { return point[1]; }), z: controlPoints.map(function(point) { return point[2]; }) };\n}","lastGenerated":"2024-05-27T13:44:23.438Z"}
{"_id":"curveBoundingBox","projectName":"default","arguments":"curve","specification":"Computes the bounding box of a NURBS curve.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Returns the bounding box for a given curve.\n *\n * @param {Object} curve The curve to compute the bounding box for.\n * @returns {{min: Object, max: Object}} The bounding box as an object with 'min' and 'max' properties.\n */","code":"function curveBoundingBox(curve) {\n    var min = {x: Infinity, y: Infinity, z: Infinity};\n    var max = {x: -Infinity, y: -Infinity, z: -Infinity};\n\n    for (var i = 0; i < curve.controlPoints.length; i++) {\n        var point = curve.controlPoints[i];\n        if (point.x < min.x) min.x = point.x;\n        if (point.x > max.x) max.x = point.x;\n        if (point.y < min.y) min.y = point.y;\n        if (point.y > max.y) max.y = point.y;\n        if (point.z < min.z) min.z = point.z;\n        if (point.z > max.z) max.z = point.z;\n    }\n\n    return {min: min, max: max};\n}\n","lastGenerated":"2024-05-27T04:54:04.866Z"}
{"_id":"curveControlPolygon","projectName":"default","arguments":"curve","specification":"Returns the control polygon of a NURBS curve.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n* @param {Object} curve - Curve object containing degree, weights, and knots.\n* @returns {Array} Array of control points for the curve.\n*\n* Generates an array of control points that approximate a B-spline curve.\n* The control points are calculated using the given curve's degree, weights, and knots.\n*/","code":"function curveControlPolygon(curve) {\n    var degree = curve.degree;\n    var weights = curve.weights;\n    var knots = curve.knots;\n    var controlPoints = [];\n    \n    for (var i = 0; i <= degree; i++) {\n        for (var j = 0; j <= degree; j++) {\n            var point = {};\n            point.x = 0;\n            point.y = 0;\n            point.z = 0;\n            for (var k = 0; k < knots.length - 1; k++) {\n                if (knots[k] <= i / degree && knots[k + 1] > i / degree) {\n                    var t = (i / degree - knots[k]) * (degree - 1);\n                    point.x += weights[i * degree + j] * ((knots[k + 1] - k) * Math.pow(1 - t, degree - 1));\n                }\n            }\n            controlPoints.push(point);\n        }\n    }\n    \n    return controlPoints;\n}","lastGenerated":"2024-05-27T05:24:07.975Z"}
{"_id":"curveDegreeElevation","projectName":"default","arguments":"curve, newDegree","specification":"Elevates the degree of a NURBS curve.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Elevation curve degree.\n *\n * @param {Curve} curve - The original curve.\n * @param {number} newDegree - The new degree of the curve.\n */","code":"function curveDegreeElevation(curve, newDegree) {\n    var weights = curve.weights;\n    var controlPoints = curve.controlPoints;\n    for (var i = 0; i < weights.length; i++) {\n        weights[i] = deBoorAlgorithm(newDegree, controlPoints, curve.knots, i / (weights.length - 1));\n    }\n}","lastGenerated":"2024-05-27T05:20:21.719Z"}
{"_id":"curveDerivativeAtParam","projectName":"default","arguments":"curve, param, order","specification":"Computes the derivative of a NURBS curve at a given parameter.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Calculates the derivative of a curve at a specified parameter using De Boor's algorithm and binomial coefficients for approximation.\n *\n * @param {Object} curve - The input curve object containing control points, degree, and knot vector.\n * @param {number} param - The parameter at which to evaluate the derivative.\n * @param {number} order - The order of the derivative to be calculated (e.g., first-order derivative).\n * @returns {Array<number>|null} Returns an array representing the derivative basis or null if curve is not valid.\n * \n * Note:\n * - The 'curve' parameter must be a non-null object with a 'degree' property and should have control points, knot vector.\n * - The function uses deBoorAlgorithm to compute the basis functions for the input curve.\n * - Binomial coefficient calculations are used in deriving the derivative of the curve based on De Boor's algorithm.\n * - It is assumed that 'e', 'binom', and 'pow' are pre-defined utility functions available in this context.\n */","code":"function curveDerivativeAtParam(curve, param, order) {\n    if (typeof curve !== 'object' || !('degree' in curve)) return null;\n    \n    const basisFunctions = deBoorAlgorithm(curve.degree, curve.controlPoints, curve.knotVector, param);\n    \n    let derivativeBasis = [];\n    \n    for (let i = 0; i < order + 1; i++) {\n        let product = basisFunctions[i];\n        \n        for (let j = e(param), e; j >= 0; j /= 10) {\n            derivativeBasis.push((binom(j, i) * pow(x, j)) - ((binom(j-1, i) * pow(x, j-1))));\n        }\n    }\n    \n    return derivativeBasis[order];\n}","lastGenerated":"2024-05-31T05:25:49.991Z"}
{"_id":"curveKnotInsertion","projectName":"default","arguments":"curve, knot","specification":"Inserts a knot into a NURBS curve.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Inserts a knot into the curve at the specified location.\n *\n * @param {Curve} curve - The curve to modify.\n * @param {number} knot - The new knot value to insert.\n */","code":"function curveKnotInsertion(curve, knot) {\n    var degree = curve.degree;\n    var controlPoints = curve.controlPoints;\n    var weights = curve.weights;\n    var knots = curve.knots;\n    var newKnots = [];\n    var i;\n    \n    for (i = 0; i < knots.length; i++) {\n        if (knots[i] <= knot) {\n            break;\n        }\n    }\n    \n    for (; i < knots.length; i++) {\n        newKnots.push(knots[i]);\n    }\n    \n    var oldIndex = i - 1;\n    var newIndex = knots.length;\n    \n    for (i = oldIndex; i < newIndex; i++) {\n        if (knots[oldIndex] <= knot && knot <= knots[oldIndex + 1]) {\n            newKnots.splice(newIndex++, 0, knot);\n            break;\n        }\n        else if (knots[i] > knot) {\n            newKnots.splice(i, 0, knot);\n            break;\n        }\n    }\n    \n    curve.knots = newKnots;\n}","lastGenerated":"2024-05-27T05:16:44.101Z"}
{"_id":"curveLength","projectName":"default","arguments":"curve","specification":"Computes the length of a NURBS curve.","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Calculates the total length of a curve defined by an array of control points and knots.\n *\n * @function curveLength\n * @param {Object} curve - An object representing the curve to calculate its length on. It must have two properties: `controlPoints` (an array of objects with x, y, z coordinates) and `knots` (an array of knot values).\n * @returns {number} The total length of the curve as a floating point number.\n * \n * @example\n * const myCurve = { controlPoints: [{x:0, y:0, z:0}, {x:1, y:1, z:1}, {x:2, y:2, z:2}], knots:[0, 0.5, 1] };\n * const length = curveLength(myCurve);\n */","code":"function curveLength(curve) {\n  var totalLength = 0;\n  \n  for (var i = 1; i < curve.controlPoints.length; i++) {\n    const point1 = evaluateCurveAtParam(curve, curve.knots[i - 1]);\n    const point2 = evaluateCurveAtParam(curve, curve.knots[i]);\n    \n    totalLength += Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2) + Math.pow(point2.z - point1.z, 2));\n  }\n  \n  return totalLength;\n}","lastGenerated":"2024-06-01T00:50:34.529Z"}
{"_id":"curvePointProjection","projectName":"default","arguments":"curve, point","specification":"Projects a point onto a NURBS curve.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n* Calculates the point on a curve that corresponds to a given input point.\n*\n* @param {Curve} curve The Bezier curve to use for calculation.\n* @param {Point} point The input point to project onto the curve.\n* @return {Point} The projected point on the curve.\n*/","code":"function curvePointProjection(curve, point) {\n    var degree = curve.degree;\n    var controlPoints = curve.controlPoints;\n    var weights = curve.weights;\n    var knots = curve.knots;\n    var param = null;\n    for (var i = 0; i < knots.length - 1; i++) {\n        if (point.x > knots[i] && point.x <= knots[i + 1]) {\n            param = deBoorAlgorithm(degree, controlPoints, knots, point.x);\n            break;\n        }\n    }\n    return evaluateCurveAtParam(curve, param);\n}","lastGenerated":"2024-05-27T05:00:29.744Z"}
{"_id":"curveReparameterization","projectName":"default","arguments":"curve, newKnotVector","specification":"Reparameterizes a NURBS curve with a new knot vector.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Reparameterizes a curve to have the given knot vector.\n *\n * @param {Array.<Array.<number>>} curve The original curve.\n * @param {Array.<number>} newKnotVector The desired knot vector.\n * @return {NURBSCurve} A reparameterized NURBS curve.\n */","code":"function curveReparameterization(curve, newKnotVector) {\n    var degree = curve[0].length - 1;\n    var controlPoints = [];\n    for (var i = 0; i < curve.length; i++) {\n        controlPoints.push([curve[i][1], curve[i][2]]);\n    }\n    var weights = [];\n    for (var i = 0; i < degree + 1; i++) {\n        weights.push(1);\n    }\n    return createNURBSCurve(degree, controlPoints, weights, newKnotVector);\n}","lastGenerated":"2024-05-27T05:21:58.768Z"}
{"_id":"curveSubdivision","projectName":"default","arguments":"curve, param","specification":"Subdivides a NURBS curve at a given parameter.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @param {Object} curve - The curve to be subdivided.\n * @param {number} param - The parameter value used for subdivision.\n * @return {Object} A new curve resulting from the subdivision operation.\n *\n * Subdivides a NURBS curve at the given parameter value. The curve is split into two parts\n * at the parameter value, and new control points are created to represent the subdivided curve.\n */","code":"function curveSubdivision(curve, param) {\n    let degree = curve.degree;\n    let controlPoints = curve.controlPoints;\n    let weights = curve.weights;\n    let knots = curve.knots;\n\n    let newControlPoints = [];\n    let newWeights = [];\n    let newKnots = [];\n\n    for (let i = 0; i < controlPoints.length; i++) {\n        if (knots[i] <= param) {\n            newControlPoints.push(controlPoints[i]);\n            newWeights.push(weights[i]);\n            newKnots.push(knots[i]);\n        } else if (knots[i] > param && i === 0) {\n            break;\n        }\n    }\n\n    for (let i = controlPoints.length - 1; i >= 0; i--) {\n        if (knots[i] >= param) {\n            newControlPoints.push(controlPoints[i]);\n            newWeights.push(weights[i]);\n            newKnots.push(knots[i]);\n        } else if (knots[i] < param && i === controlPoints.length - 1) {\n            break;\n        }\n    }\n\n    let newCurve = createNURBSCurve(degree, newControlPoints, weights, newKnots);\n    return newCurve;\n}\n","lastGenerated":"2024-05-27T05:19:05.181Z"}
{"_id":"curveTangentAtParam","projectName":"default","arguments":"curve, param","specification":"Computes the tangent of a NURBS curve at a given parameter.","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Calculates the tangent vector at a given parameter value along a curve defined by control points, weights and knot vectors.\n * This function utilizes deBoor's algorithm to compute the point on the curve corresponding to the provided parameter and then calculates the derivative of that point (tangent).\n * \n * @param {object} curve - The Curve object representing a B-spline or NURBS curve. It should have properties for degree, knots, controlPoints, and weights.\n * @param {number} parameter - A real number within the valid range of the knot vector to specify the point on the curve where the tangent will be calculated.\n * \n * @throws {Error} If the provided parameter is out of bounds (less than 0 or greater than the length of the knots array minus the degree).\n * @returns {object} An object representing a vector with x, y, and z components that corresponds to the tangent at the specified parameter.\n */","code":"function curveTangentAtParam(curve, parameter) {\n    var degree = curve.degree;\n    var knotVector = curve.knots;\n\n    if (parameter < 0 || parameter >= knotVector.length - degree) {\n        throw new Error('Parameter is out of bounds');\n    }\n\n    var tangent = { x: 0, y: 0, z: 0 };\n\n    for (var i = degree + 1; i < knotVector.length - 1; i++) {\n        if (knotVector[i] === parameter) {\n            break;\n        }\n        \n        var controlPointWeight = curve.weights[i];\n        tangent.x += curve.controlPoints[i].x * controlPointWeight;\n        tangent.y += curve.controlPoints[i].y * controlPointWeight;\n        tangent.z += curve.controlPoints[i].z * controlPointWeight;\n    }\n\n    return deBoorAlgorithm(degree, curve.controlPoints, knotVector, parameter);\n}","lastGenerated":"2024-06-01T07:18:22.823Z"}
{"_id":"curveToPolyline","projectName":"default","arguments":"curve, tolerance","specification":"Approximates a NURBS curve with a polyline within a given tolerance.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n* Converts a Bezier curve into a polyline.\n*\n* @param {Object} curve The Bezier curve to convert.\n* @param {Number} tolerance The maximum deviation from the original curve allowed in the generated polyline.\n* @returns {Array} An array of points representing the converted polyline.\n*/","code":"function curveToPolyline(curve, tolerance) {\n    var points = [];\n    for (var i = 0; i <= curve.controlPoints.length - 1; i++) {\n        points.push({ x: curve.controlPoints[i].x, y: curve.controlPoints[i].y });\n    }\n    var polyLine = [];\n    for (var i = 0; i < points.length - 1; i++) {\n        var direction = subtract(points[i + 1], points[i]);\n        for (var j = 0; j <= Math.sqrt(Math.pow(direction.x, 2) + Math.pow(direction.y, 2)); j++) {\n            polyLine.push({ x: points[i].x + j * direction.x / Math.sqrt(Math.pow(direction.x, 2) + Math.pow(direction.y, 2)), y: points[i].y + j * direction.y / Math.sqrt(Math.pow(direction.x, 2) + Math.pow(direction.y, 2)) });\n        }\n    }\n    return polyLine;\n}","lastGenerated":"2024-05-27T05:26:08.602Z"}
{"_id":"deBoorAlgorithm","projectName":"default","arguments":"degree, controlPoints, knots, param","specification":"Computes a point on a NURBS curve using de Boor's algorithm.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * The deBoorAlgorithm function calculates the point on a B-spline curve \n * given its degree, control points, knots and parameter value.\n *\n * @param {Number} degree - The degree of the B-spline\n * @param {Array} controlPoints - An array of control points defining the shape of the spline\n * @param {Array} knots - An array of knot values that define the domain of the spline\n * @param {Number} param - The parameter value for which to calculate the point on the curve\n *\n * @returns {Number} The calculated point on the B-spline curve at the given parameter value\n */","code":"function deBoorAlgorithm(degree, controlPoints, knots, param) {\n    var n = degree + 1;\n    var t = [];\n    for (var i = 0; i < n; i++) {\n        t[i] = 0;\n    }\n    for (var j = 0; j <= degree; j++) {\n        var p = 1;\n        for (var k = 0; k < n - 1; k++) {\n            if (k < j) {\n                p *= param - knots[k];\n            } else if (k > j) {\n                p *= knots[k + 1] - param;\n            }\n        }\n        t[j] += controlPoints[j] * p;\n    }\n    return t[0];\n}","lastGenerated":"2024-05-27T04:49:54.897Z"}
{"_id":"deBoorAlgorithmSurface","projectName":"default","arguments":"degreeU, degreeV, controlPoints, knotsU, knotsV, paramU, paramV","specification":"Computes a point on a NURBS surface using de Boor's algorithm.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @param {Number} degreeU - \n * @param {Number} degreeV - \n * @param {Array} controlPoints - \n * @param {Array} knotsU - \n * @param {Array} knotsV - \n * @param {Number} paramU - \n * @param {Number} paramV - \n * @return {{x: Number, y: Number, z: Number}} - \n */","code":"function deBoorAlgorithmSurface(degreeU, degreeV, controlPoints, knotsU, knotsV, paramU, paramV) {\n    var indexU = findKnotIndex(knotsU, paramU);\n    var indexV = findKnotIndex(knotsV, paramV);\n    \n    if (indexU == -1 || indexV == -1) return null;\n    \n    var basisFunctionsU = [];\n    for (var i = 0; i <= degreeU; i++) {\n        basisFunctionsU[i] = evaluateBasisFunction(degreeU, knotsU[indexU + i], paramU);\n    }\n    \n    var basisFunctionsV = [];\n    for (var i = 0; i <= degreeV; i++) {\n        basisFunctionsV[i] = evaluateBasisFunction(degreeV, knotsV[indexV + i], paramV);\n    }\n    \n    var resultX = 0;\n    var resultY = 0;\n    var resultZ = 0;\n    \n    for (var i = 0; i <= degreeU; i++) {\n        for (var j = 0; j <= degreeV; j++) {\n            resultX += controlPoints[indexU + i][indexV + j][0] * basisFunctionsU[i] * basisFunctionsV[j];\n            resultY += controlPoints[indexU + i][indexV + j][1] * basisFunctionsU[i] * basisFunctionsV[j];\n            resultZ += controlPoints[indexU + i][indexV + j][2] * basisFunctionsU[i] * basisFunctionsV[j];\n        }\n    }\n    \n    return {x: resultX, y: resultY, z: resultZ};\n}\n\nfunction findKnotIndex(knots, param) {\n    for (var i = 0; i < knots.length - 1; i++) {\n        if (knots[i] <= param && param <= knots[i + 1]) return i;\n    }\n    return -1;\n}\n\nfunction evaluateBasisFunction(degree, knot, param) {\n    var basisValue = 1;\n    \n    for (var i = 0; i < degree; i++) {\n        if (knot != param) {\n            basisValue *= (param - knot) / (knots[i + 1] - knot);\n        } else {\n            return 0;\n        }\n    }\n    \n    return basisValue;\n}","lastGenerated":"2024-05-27T05:58:47.431Z"}
{"_id":"evaluateCurveAtParam","projectName":"default","arguments":"curve, param","specification":"Evaluates the NURBS curve at a given parameter.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Evaluates the curve at a given parameter.\n *\n * @param {Object} curve - The B-spline curve to evaluate.\n * @param {number} param - The parameter value to evaluate.\n * @return {{x: number, y: number, z: number}|null} - The evaluated point or null if outside the knot range.\n */","code":"function evaluateCurveAtParam(curve, param) {\n    var degree = curve.degree;\n    var controlPoints = curve.controlPoints;\n    var weights = curve.weights;\n    var knots = curve.knots;\n\n    for (var i = 0; i < degree; i++) {\n        for (var j = 0; j <= i; j++) {\n            if (knots[i] > param) break;\n            if (param >= knots[j + degree - 1]) continue;\n            var basisValue = deBoorAlgorithm(degree, controlPoints, knots, param);\n            return {\n                x: basisValue[0] * weights[i],\n                y: basisValue[1] * weights[i],\n                z: basisValue[2] * weights[i]\n            };\n        }\n    }\n\n    for (var i = degree; i < controlPoints.length; i++) {\n        if (knots[i - 1] > param) break;\n        if (param >= knots[i]) continue;\n        var basisValue = deBoorAlgorithm(degree, controlPoints, knots, param);\n        return {\n            x: basisValue[0] * weights[i],\n            y: basisValue[1] * weights[i],\n            z: basisValue[2] * weights[i]\n        };\n    }\n\n    return null;\n}\n\nfunction deBoorAlgorithm(degree, controlPoints, knots, param) {\n    if (degree == 1) {\n        for (var i = 0; i < controlPoints.length; i++) {\n            if (knots[i] <= param && param < knots[i + 1]) {\n                return [controlPoints[i][0], controlPoints[i][1], controlPoints[i][2]];\n            }\n        }\n    }\n\n    var basisValue = new Array(degree);\n    for (var i = 0; i < degree; i++) {\n        if (knots[i] > param) {\n            basisValue.fill(0);\n            for (var j = 0; j <= i - 1; j++) {\n                basisValue[j] = weights[i - 1];\n            }\n            return basisValue;\n        }\n    }\n\n    for (var i = degree; i < controlPoints.length; i++) {\n        if (knots[i - 1] > param) {\n            basisValue.fill(0);\n            for (var j = 0; j <= i - degree; j++) {\n                basisValue[j] = weights[i];\n            }\n            return basisValue;\n        }\n    }\n\n    return null;\n}","lastGenerated":"2024-05-27T04:48:03.064Z"}
{"_id":"evaluateSurfaceAtParam","projectName":"default","arguments":"surface, paramU, paramV","specification":"Evaluates the NURBS surface at given parameters.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Evaluates the surface at given parameters.\n *\n * @param {Object} surface - The NURBS surface to evaluate.\n * @param {number} paramU - The parameter value for U dimension.\n * @param {number} paramV - The parameter value for V dimension.\n * @returns {Array} The evaluated surface values.\n */","code":"function evaluateSurfaceAtParam(surface, paramU, paramV) {\n    var degreeU = surface.degreeU;\n    var degreeV = surface.degreeV;\n    var controlPoints = surface.controlPoints;\n    var weights = surface.weights;\n    var knotsU = surface.knotsU;\n    var knotsV = surface.knotsV;\n\n    var basisU = [];\n    var basisV = [];\n\n    for (var i = 0; i <= degreeU; i++) {\n        basisU[i] = deBoorAlgorithm(degreeU, controlPoints[i], knotsU, paramU);\n    }\n\n    for (var j = 0; j <= degreeV; j++) {\n        basisV[j] = deBoorAlgorithm(degreeV, controlPoints[0][j], knotsV, paramV);\n    }\n\n    var result = new Array(basisU.length * basisV.length);\n\n    for (var i = 0; i < basisU.length; i++) {\n        for (var j = 0; j < basisV.length; j++) {\n            result[i * basisV.length + j] = basisU[i] * basisV[j];\n        }\n    }\n\n    return result;\n}","lastGenerated":"2024-05-27T05:55:42.520Z"}
{"_id":"extrudeCurve","projectName":"default","arguments":"curve, direction, distance","specification":"Extrudes a NURBS curve in a specified direction.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n* Extrudes a curve into 3D space.\n*\n* @param {Object} curve - The curve to extrude, containing control points, weights and knots.\n* @param {Array} direction - The direction vector for the extrusion.\n* @param {Number} distance - The distance along the direction vector to extrude the curve.\n* @returns {Object} A NURBS surface created from the extruded curve.\n*/","code":"function extrudeCurve(curve, direction, distance) {\n    var controlPoints = [];\n    for (var i = 0; i < curve.controlPoints.length; i++) {\n        controlPoints.push([curve.controlPoints[i].x + direction[0] * distance,\n                             curve.controlPoints[i].y + direction[1] * distance,\n                             curve.controlPoints[i].z + direction[2] * distance]);\n    }\n    var weights = [];\n    for (var i = 0; i < curve.weights.length; i++) {\n        weights.push(curve.weights[i]);\n    }\n    var knotsU = [];\n    for (var i = 0; i <= curve.knots.length; i++) {\n        knotsU.push(curve.knots[i]);\n    }\n    return createNURBSSurface(1, 1, controlPoints, weights, knotsU, []);\n}","lastGenerated":"2024-05-27T05:27:47.319Z"}
{"_id":"filletEdges","projectName":"default","arguments":"edge1, edge2, radius","specification":"Creates a fillet between two edges.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @param {Object} edge1 - description of edge1\n * @param {Object} edge2 - description of edge2\n * @param {Number} radius - description of radius\n *\n * @returns {Boolean} result of filletEdges operation\n *\n * Description: This function calculates the boolean intersection of two surfaces.\n */","code":"function filletEdges(edge1, edge2, radius) {\n    var curve1 = analyzeSurfaceCurvature(edge1, 0, 1);\n    var curve2 = analyzeSurfaceCurvature(edge2, 0, 1);\n    return booleanIntersection(blendSurfaces(curve1, curve2, radius));\n}","lastGenerated":"2024-05-27T05:33:49.994Z"}
{"_id":"findCurveIntersections","projectName":"default","arguments":"curve1, curve2","specification":"Finds intersections between two NURBS curves.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Finds the intersections between two curves.\n *\n * @param {Curve} curve1 - The first curve.\n * @param {Curve} curve2 - The second curve.\n * @returns {Array.<{x: number, y: number, z: number}>} An array of intersection points.\n */","code":"function findCurveIntersections(curve1, curve2) {\n    var result = [];\n    for (var i = 0; i < curve1.controlPoints.length; i++) {\n        var p1 = evaluateCurveAtParam(curve1, curve1.knots[i]);\n        for (var j = 0; j < curve2.controlPoints.length; j++) {\n            var p2 = evaluateCurveAtParam(curve2, curve2.knots[j]);\n            if (isPointOnLine(p1, p2, curve1) && isPointOnLine(p1, p2, curve2)) {\n                result.push({x: p1.x, y: p1.y, z: 0});\n            }\n        }\n    }\n    return result;\n}\n\n","lastGenerated":"2024-05-27T04:52:10.041Z"}
{"_id":"findSurfaceIntersections","projectName":"default","arguments":"surface1, surface2","specification":"Finds intersections between two NURBS surfaces.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Finds the surface intersections between two surfaces.\n *\n * @param {Surface} surface1 The first surface to check for intersections.\n * @param {Surface} surface2 The second surface to check for intersections.\n * @returns {Array.<Point>} An array of points where the two surfaces intersect.\n */","code":"function findSurfaceIntersections(surface1, surface2) {\n    for (var u = 0; u <= 1; u += 0.01) {\n        for (var v = 0; v <= 1; v += 0.01) {\n            var point = evaluateSurfaceAtParam(surface1, u, v);\n            if (point !== null && isPointOnSurface(surface2, point)) {\n                point = evaluateSurfaceAtParam(surface2, u, v);\n                if (point !== null && isPointOnSurface(surface1, point)) {\n                    return [point];\n                }\n            }\n        }\n    }\n    return [];\n}\n\nfunction isPointOnSurface(surface, point) {\n    var distance = 0;\n    for (var i = 0; i < surface.controlPoints.length; i++) {\n        var controlPoint = surface.controlPoints[i];\n        var vector = subtractVectors(subtractVectors(point, controlPoint), surface.normalAtParam(0.5, 0.5));\n        distance += vector.x * vector.x + vector.y * vector.y + vector.z * vector.z;\n    }\n    return distance < 1e-6;\n}\n\nfunction subtractVectors(vector1, vector2) {\n    return { x: vector1.x - vector2.x, y: vector1.y - vector2.y, z: vector1.z - vector2.z };\n}","lastGenerated":"2024-05-27T06:01:10.924Z"}
{"_id":"globalCurveInterpolation","projectName":"default","arguments":"points, degree","specification":"Interpolates a set of points with a NURBS curve globally.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @param {Array.<{x: number, y: number, z: number}>} points An array of control points.\n * @param {number} degree The degree of the NURBS curve.\n * @return {NURBSCurve}\n */","code":"function globalCurveInterpolation(points, degree) {\n    let knots = [];\n    let weights = [];\n    let controlPoints = [];\n\n    for (let i = 0; i < points.length; i++) {\n        let point = points[i];\n        let knot = point.x;\n        knots.push(knot);\n        let weight = 1.0 / points.length;\n        weights.push(weight);\n        controlPoints.push([point.y, point.z]);\n    }\n\n    return createNURBSCurve(degree, controlPoints, weights, knots);\n}\n","lastGenerated":"2024-05-27T05:06:32.750Z"}
{"_id":"globalSurfaceInterpolation","projectName":"default","arguments":"points, degreeU, degreeV","specification":"Interpolates a set of points with a NURBS surface globally.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Creates a global surface interpolation using NURBS.\n *\n * @param {Array} points - Array of control points.\n * @param {Number} degreeU - Degree in the U direction.\n * @param {Number} degreeV - Degree in the V direction.\n * @returns {Object} The interpolated surface.\n */","code":"function globalSurfaceInterpolation(points, degreeU, degreeV) {\n    var controlPoints = [];\n    var knotsU = [];\n    var knotsV = [];\n    var weights = [];\n\n    for (var i = 0; i < points.length; i++) {\n        controlPoints.push([points[i].x, points[i].y, points[i].z]);\n        knotsU.push(i / (points.length - 1));\n        weights.push(1);\n    }\n\n    return createNURBSSurface(degreeU, degreeV, controlPoints, weights, knotsU, knotsV);\n}","lastGenerated":"2024-05-27T06:19:09.023Z"}
{"_id":"intersectionCurveSurface","projectName":"default","arguments":"curve, surface","specification":"Computes the intersection curve between a NURBS curve and a NURBS surface.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Returns the intersection curve of a given NURBS curve and surface.\n *\n * This function finds the points where the curve intersects with the surface by evaluating\n * both the curve and the surface at different parameter values. It then checks if the z-value\n * of the curve is equal to the z-value of the surface at each point, and if so, adds it to the\n * intersection curve.\n *\n * @param {NURBS Curve} curve - The NURBS curve to find the intersection with.\n * @param {NURBS Surface} surface - The NURBS surface to find the intersection with.\n * @returns {Array} An array of points where the curve intersects with the surface.","code":"function intersectionCurveSurface(curve, surface) {\n    var paramU = [];\n    var paramV = [];\n    for (var i = 0; i < curve.knots.length - 1; i++) {\n        if (curve.deBoorAlgorithm(curve.degree, curve.controlPoints, curve.knots, i) > surface.evaluateSurfaceAtParam(surface, surface.knotsU[0], surface.knotsV[0]).z) {\n            paramU.push(i);\n        }\n    }\n    for (var i = 0; i < surface.knotsV.length - 1; i++) {\n        if (curve.deBoorAlgorithm(curve.degree, curve.controlPoints, curve.knots, 0) > surface.evaluateSurfaceAtParam(surface, surface.knotsU[0], i).z) {\n            paramV.push(i);\n        }\n    }\n    var intersectionCurve = [];\n    for (var i = 0; i < paramU.length; i++) {\n        for (var j = 0; j < paramV.length; j++) {\n            var point = surface.evaluateSurfaceAtParam(surface, paramU[i], paramV[j]);\n            if (curve.deBoorAlgorithm(curve.degree, curve.controlPoints, curve.knots, curve.evaluateCurveAtParam(curve, point).t) === point.z) {\n                intersectionCurve.push({x: point.x, y: point.y, z: point.z});\n            }\n        }\n    }\n    return intersectionCurve;\n}","lastGenerated":"2024-05-27T05:44:08.316Z"}
{"_id":"intersectionSurfaceSurface","projectName":"default","arguments":"surface1, surface2","specification":"Computes the intersection curve between two NURBS surfaces.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n* Finds the intersection points of two NURBS surfaces.\n*\n* @param {Object} surface1 The first NURBS surface.\n* @param {Object} surface2 The second NURBS surface.\n* @return {Array} An array of intersection points, or an empty array if no intersection is found.\n*/","code":"function intersectionSurfaceSurface(surface1, surface2) {\n    var knotsU1 = surface1.knotsU;\n    var knotsV1 = surface1.knotsV;\n    var controlPoints1 = surface1.controlPoints;\n    var degreeU1 = surface1.degreeU;\n    var degreeV1 = surface1.degreeV;\n    \n    var knotsU2 = surface2.knotsU;\n    var knotsV2 = surface2.knotsV;\n    var controlPoints2 = surface2.controlPoints;\n    var degreeU2 = surface2.degreeU;\n    var degreeV2 = surface2.degreeV;\n\n    for (var i = 0; i < knotsU1.length - 1; i++) {\n        for (var j = 0; j < knotsV1.length - 1; j++) {\n            var paramU1 = deBoorAlgorithm(degreeU1, controlPoints1, knotsU1, i);\n            var paramV1 = deBoorAlgorithm(degreeV1, controlPoints1, knotsV1, j);\n            \n            var point1 = evaluateSurfaceAtParam(surface1, paramU1, paramV1);\n\n            for (var k = 0; k < knotsU2.length - 1; k++) {\n                for (var l = 0; l < knotsV2.length - 1; l++) {\n                    var paramU2 = deBoorAlgorithm(degreeU2, controlPoints2, knotsU2, k);\n                    var paramV2 = deBoorAlgorithm(degreeV2, controlPoints2, knotsV2, l);\n\n                    var point2 = evaluateSurfaceAtParam(surface2, paramU2, paramV2);\n\n                    if (point1.x === point2.x && point1.y === point2.y && point1.z === point2.z) {\n                        // found an intersection\n                        return [point1];\n                    }\n                }\n            }\n        }\n    }\n\n    return [];\n}","lastGenerated":"2024-05-27T13:42:26.992Z"}
{"_id":"isCurveClosed","projectName":"default","arguments":"curve","specification":"Checks if a NURBS curve is closed.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Determines whether a curve is closed.\n *\n * @param {Object} curve The curve to check.\n * @returns {boolean} True if the curve is closed, false otherwise.\n */","code":"function isCurveClosed(curve) {\n    var knots = curve.knots;\n    var controlPoints = curve.controlPoints;\n    var degree = curve.degree;\n    for (var i = 0; i < knots.length - 1; i++) {\n        if (knots[i] !== knots[knots.length - 1]) {\n            return false;\n        }\n    }\n    return true;\n}","lastGenerated":"2024-05-27T05:49:32.310Z"}
{"_id":"isPointOnLine","projectName":"default","arguments":"point1, point2, curve","specification":"Determines if a specified point lies directly on the line segment defined by two other points within a B-spline surface context. This function utilizes deBoorAlgorithmSurface to find the parameter corresponding to the second point along the curve and evaluateSurfaceAtParam to assess whether the first point's coordinates are sufficiently close to that location on the B-spline surface.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Checks if a point is on the line defined by two points and a curve.\n *\n * @param {Object} point1 - The first point defining the line.\n * @param {Object} point2 - The second point defining the line.\n * @param {Object} curve - The curve defining the line.\n * @returns {boolean} True if the point is on the line, false otherwise.\n */","code":"function isPointOnLine(point1, point2, curve) {\n    var paramU = deBoorAlgorithmSurface(1, [curve], [], [], 0, 0);\n    var surfaceCoord = evaluateSurfaceAtParam(curve, paramU, 0);\n    if (Math.abs(point1.x - surfaceCoord[0]) < 0.0001 && Math.abs(point1.y - surfaceCoord[1]) < 0.0001 && Math.abs(point1.z - surfaceCoord[2]) < 0.0001) {\n        return true;\n    } else {\n        return false;\n    }\n}","lastGenerated":"2024-05-29T06:12:17.683Z"}
{"_id":"isSurfaceClosed","projectName":"default","arguments":"surface","specification":"Checks if a NURBS surface is closed.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Checks if a surface is closed.\n *\n * @param {Object} surface The surface to check for closure.\n * @returns {boolean} Whether the surface is closed or not.\n */","code":"function isSurfaceClosed(surface) {\n  var knotsU = surface.knotsU;\n  var knotsV = surface.knotsV;\n  for (var i = 0; i < knotsU.length - 1; i++) {\n    if (knotsU[i] !== knotsU[i + 1]) return false;\n  }\n  for (var j = 0; j < knotsV.length - 1; j++) {\n    if (knotsV[j] !== knotsV[j + 1]) return false;\n  }\n  return true;\n}","lastGenerated":"2024-05-27T13:52:04.460Z"}
{"_id":"localCurveRefinement","projectName":"default","arguments":"curve, tolerance","specification":"Locally refines a NURBS curve based on a tolerance.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @description Refine a curve by inserting knots to reduce the error.\n *\n * @param {Curve} curve - The curve to refine.\n * @param {number} tolerance - The maximum deviation allowed between the original and refined curves.\n * @return {Curve} The refined curve.\n */\n\n/**\n * @description Finds the best knot in a segment of the curve that minimizes the error.\n *\n * @param {Knot[]} knots - The array of knots to search.\n * @param {number} degree - The degree of the polynomial used to evaluate the curve.\n * @param {{}} controlPoints - The control points of the curve.\n * @param {{}} weights - The weights of the curve.\n * @param {{x:number,y:number}} point - The point to compare with the refined curve.\n * @param {{x:number,y:number}} tangent - The tangent vector at the point.\n * @param {number} paramStart - The start parameter of the segment.\n * @param {number} paramEnd - The end parameter of the segment.\n * @return {number} The best knot in the segment.\n */\n\n/**\n * @description Finds the best knot in a segment of the curve that minimizes the error.\n *\n * @param {Knot[]} knots - The array of knots to search.\n * @param {number} degree - The degree of the polynomial used to evaluate the curve.\n * @param {{}} controlPoints - The control points of the curve.\n * @param {{}} weights - The weights of the curve.\n * @param {{x:number,y:number}} point - The point to compare with the refined curve.\n * @param {{x:number,y:number}} tangent - The tangent vector at the point.\n * @param {number} paramStart - The start parameter of the segment.\n * @param {number} paramEnd - The end parameter of the segment.\n * @return {number} The best knot in the segment.\n */\n\n/**\n * @description Finds the best knot within a specific interval that minimizes the error.\n *\n * @param {Knot[]} knots - The array of knots to search.\n * @param {number} degree - The degree of the polynomial used to evaluate the curve.\n * @param {{}} controlPoints - The control points of the curve.\n * @param {{}} weights - The weights of the curve.\n * @param {{x:number,y:number}} point - The point to compare with the refined curve.\n * @param {{x:number,y:number}} tangent - The tangent vector at the point.\n * @param {number} start - The start parameter of the interval.\n * @param {number} end - The end parameter of the interval.\n * @return {number} The best knot in the interval.\n */\n\n/**\n * @description Finds the best knot within a specific interval that minimizes the error.\n *\n * @param {Knot[]} knots - The array of knots to search.\n * @param {number} degree - The degree of the polynomial used to evaluate the curve.\n * @param {{}} controlPoints - The control points of the curve.\n * @param {{}} weights - The weights of the curve.\n * @param {{x:number,y:number}} point - The point to compare with the refined curve.\n * @param {{x:number,y:number}} tangent - The tangent vector at the point.\n * @return {number} The best knot in the interval.\n */\n\n/**\n * @description Calculates the deviation between two points.\n *\n * @param {{x:number,y:number}} point1 - The first point.\n * @param {{x:number,y:number}} point2 - The second point.\n * @return {number} The deviation between the two points.","code":"function localCurveRefinement(curve, tolerance) {\n    let knots = curve.knots;\n    let degree = curve.degree;\n    let controlPoints = curve.controlPoints;\n    let weights = curve.weights;\n\n    for (let i = 0; i < knots.length - 1; i++) {\n        let paramStart = knots[i];\n        let paramEnd = knots[i + 1];\n\n        let segment = evaluateCurveAtParam(curve, paramStart);\n        let endSegment = evaluateCurveAtParam(curve, paramEnd);\n\n        let distance = curveLength(curve) / (paramEnd - paramStart);\n        let numDivisions = Math.ceil(tolerance * distance);\n\n        for (let j = 0; j < numDivisions; j++) {\n            let param = (j * (paramEnd - paramStart)) / numDivisions + paramStart;\n            let point = evaluateCurveAtParam(curve, param);\n            let tangent = curveTangentAtParam(curve, param);\n\n            let knot = findKnot(knots, degree, controlPoints, weights, segment, endSegment, point, tangent);\n\n            if (knot !== null) {\n                knots.splice(i + 1, 0, knot);\n                i++;\n                break;\n            }\n        }\n    }\n\n    return curve;\n}\n\nfunction findKnot(knots, degree, controlPoints, weights, segment, endSegment, point, tangent) {\n    let maxDeviation = Infinity;\n    let bestKnot = null;\n\n    for (let i = 0; i < knots.length - 1; i++) {\n        let paramStart = knots[i];\n        let paramEnd = knots[i + 1];\n\n        if (paramStart <= segment[0] && endSegment[0] <= paramEnd) {\n            let newKnot = findBestKnot(knots, degree, controlPoints, weights, point, tangent, paramStart, paramEnd);\n            if (newKnot !== null && deviation(point, evaluateCurveAtParam(curve, newKnot)) < maxDeviation) {\n                maxDeviation = deviation(point, evaluateCurveAtParam(curve, newKnot));\n                bestKnot = newKnot;\n            }\n        }\n    }\n\n    return bestKnot;\n}\n\nfunction findBestKnot(knots, degree, controlPoints, weights, point, tangent, paramStart, paramEnd) {\n    let bestDeviation = Infinity;\n    let bestKnot = null;\n\n    for (let i = 0; i < knots.length - 1; i++) {\n        if (knots[i] <= paramStart && paramEnd <= knots[i + 1]) {\n            let newKnot = findBestKnotInSegment(knots, degree, controlPoints, weights, point, tangent, paramStart, paramEnd, i);\n            if (newKnot !== null && deviation(point, evaluateCurveAtParam(curve, newKnot)) < bestDeviation) {\n                bestDeviation = deviation(point, evaluateCurveAtParam(curve, newKnot));\n                bestKnot = newKnot;\n            }\n        }\n    }\n\n    return bestKnot;\n}\n\nfunction findBestKnotInSegment(knots, degree, controlPoints, weights, point, tangent, paramStart, paramEnd, index) {\n    let leftKnot = knots[index];\n    let rightKnot = knots[index + 1];\n\n    if (leftKnot <= paramStart && paramEnd <= rightKnot) {\n        return findBestKnotInInterval(knots, degree, controlPoints, weights, point, tangent, paramStart, paramEnd);\n    } else if (paramStart <= leftKnot && rightKnot <= paramEnd) {\n        return findBestKnotInInterval(knots, degree, controlPoints, weights, point, tangent, leftKnot, rightKnot);\n    }\n\n    return null;\n}\n\nfunction findBestKnotInInterval(knots, degree, controlPoints, weights, point, tangent, start, end) {\n    let bestDeviation = Infinity;\n    let bestKnot = null;\n\n    for (let i = Math.floor((start + end) / 2); i >= start && i <= end; i--) {\n        let newKnot = evaluateCurveAtParam(curve, i);\n        if (deviation(point, newKnot) < bestDeviation) {\n            bestDeviation = deviation(point, newKnot);\n            bestKnot = i;\n        } else if (deviation(point, newKnot) > bestDeviation) {\n            break;\n        }\n    }\n\n    return bestKnot;\n}\n\nfunction deviation(point1, point2) {\n    let dx = point1.x - point2.x;\n    let dy = point1.y - point2.y;\n\n    return Math.sqrt(dx * dx + dy * dy);\n}","lastGenerated":"2024-05-27T05:14:20.055Z"}
{"_id":"localSurfaceRefinement","projectName":"default","arguments":"surface, tolerance","specification":"Locally refines a NURBS surface based on a tolerance.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Refines the local surface around each control point based on the specified tolerance.\n *\n * @param {Object} surface - The surface to refine.\n * @param {number} tolerance - The maximum distance between adjacent points to consider refinement necessary.\n */","code":"function localSurfaceRefinement(surface, tolerance) {\n    var knotsU = surface.knotsU;\n    var knotsV = surface.knotsV;\n    var controlPoints = surface.controlPoints;\n    var degreeU = surface.degreeU;\n    var degreeV = surface.degreeV;\n\n    for (var i = 0; i < knotsU.length - 1; i++) {\n        for (var j = 0; j < knotsV.length - 1; j++) {\n            var surfacePoint = evaluateSurfaceAtParam(surface, knotsU[i], knotsV[j]);\n            var neighborPoints = [\n                evaluateSurfaceAtParam(surface, knotsU[i], knotsV[j+1]),\n                evaluateSurfaceAtParam(surface, knotsU[i+1], knotsV[j])\n            ];\n\n            if (distanceBetweenPoints(surfacePoint, neighborPoints[0]) > tolerance &&\n                distanceBetweenPoints(surfacePoint, neighborPoints[1]) > tolerance) {\n                // Refine the surface here\n                // This is a placeholder for actual refinement logic\n                console.log(\"Refining surface at (\" + knotsU[i] + \", \" + knotsV[j] + \")\");\n            }\n        }\n    }\n}\n\nfunction distanceBetweenPoints(p1, p2) {\n    return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2) + Math.pow(p2.z - p1.z, 2));\n}","lastGenerated":"2024-05-27T06:21:18.477Z"}
{"_id":"loftCurves","projectName":"default","arguments":"curveList","specification":"Creates a surface by lofting through a list of NURBS curves.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n* @description Generate a NURBS surface from an array of curves.\n* @param {Array} curveList - The list of curves to generate the surface from.\n* @returns {NURBSSurface}\n*/","code":"function loftCurves(curveList) {\n    let controlPoints = [];\n    let weights = [];\n    let knotsU = [];\n    let knotsV = [];\n\n    for (let i = 0; i < curveList.length; i++) {\n        let curve = curveList[i];\n        let controlPoint = analyzeSurfaceCurvature(curve, 0, 1);\n        controlPoints.push(controlPoint);\n\n        weights.push(1);\n        knotsU.push(0);\n        knotsV.push(i / (curveList.length - 1));\n    }\n\n    return createNURBSSurface(2, 1, controlPoints, weights, knotsU, knotsV);\n}","lastGenerated":"2024-05-27T05:32:28.088Z"}
{"_id":"mirrorCurve","projectName":"default","arguments":"curve, plane","specification":"Mirrors a NURBS curve across a specified plane.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @param {Curve} curve The original curve to be mirrored.\n * @param {Plane} plane The plane that the curve should be mirrored across.\n * @return {Curve} The new curve, which is a mirror of the input curve.\n */","code":"function mirrorCurve(curve, plane) {\n    var controlPoints = [];\n    for (var i = 0; i < curve.controlPoints.length; i++) {\n        var point = curve.controlPoints[i];\n        var mirroredPoint = {\n            x: 2 * plane.normal.x * point.z + plane.point.x - 2 * plane.normal.x * point.x,\n            y: 2 * plane.normal.y * point.z + plane.point.y - 2 * plane.normal.y * point.y,\n            z: 2 * plane.normal.z * point.z + plane.point.z - 2 * plane.normal.z * point.x\n        };\n        controlPoints.push(mirroredPoint);\n    }\n    var newCurve = createNURBSCurve(curve.degree, controlPoints, curve.weights, curve.knots);\n    return newCurve;\n}","lastGenerated":"2024-05-27T05:51:21.521Z"}
{"_id":"mirrorSurface","projectName":"default","arguments":"surface, plane","specification":"Mirrors a NURBS surface across a specified plane.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Creates a mirrored version of the input surface.\n *\n * @param {Object} surface - The original surface to be mirrored.\n * @param {Object} plane - The plane used for mirroring.\n * @return {Object} The mirrored surface.\n */","code":"function mirrorSurface(surface, plane) {\n    var newControlPoints = [];\n    for (var i = 0; i < surface.controlPoints.length; i++) {\n        var point = surface.controlPoints[i];\n        var mirroredPoint = {};\n        mirroredPoint.x = 2 * plane.normal.x * (plane.point.x - point.x) + point.x;\n        mirroredPoint.y = 2 * plane.normal.y * (plane.point.y - point.y) + point.y;\n        mirroredPoint.z = 2 * plane.normal.z * (plane.point.z - point.z) + point.z;\n        newControlPoints.push(mirroredPoint);\n    }\n    var newKnotVectorU = surface.knotVectorU.slice();\n    var newKnotVectorV = surface.knotVectorV.slice();\n    for (var i = 0; i < newKnotVectorU.length; i++) {\n        newKnotVectorU[i] = plane.normal.x * (plane.point.x - newKnotVectorU[i]) + newKnotVectorU[i];\n    }\n    for (var i = 0; i < newKnotVectorV.length; i++) {\n        newKnotVectorV[i] = plane.normal.y * (plane.point.y - newKnotVectorV[i]) + newKnotVectorV[i];\n    }\n    var mirroredSurface = {\n        controlPoints: newControlPoints,\n        knotVectorU: newKnotVectorU,\n        knotVectorV: newKnotVectorV\n    };\n    return mirroredSurface;\n}","lastGenerated":"2024-05-27T13:54:29.208Z"}
{"_id":"offsetCurve","projectName":"default","arguments":"curve, distance","specification":"Offsets a NURBS curve by a specified distance.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @name offsetCurve\n * @function\n * @param {Object} curve - The original NURBS curve.\n * @param {Number} distance - The distance to offset the curve.\n * @returns {Object} A new NURBS curve that is the offset of the original curve by the specified distance.\n */","code":"function offsetCurve(curve, distance) {\n    var newControlPoints = [];\n    for (var i = 0; i < curve.controlPoints.length; i++) {\n        var point = curve.controlPoints[i];\n        var newPoint = {x: point.x + distance * point.z, y: point.y, z: point.z};\n        newControlPoints.push(newPoint);\n    }\n    return createNURBSCurve(curve.degree, newControlPoints, curve.weights, curve.knots);\n}","lastGenerated":"2024-05-27T05:36:50.093Z"}
{"_id":"offsetSurface","projectName":"default","arguments":"surface, distance","specification":"Offsets a NURBS surface by a specified distance.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @name offsetSurface\n * @description Offsets a surface by the given distance.\n * @param {Object} surface The surface to offset.\n * @param {Number} distance The amount of distance to offset the surface.\n * @returns {Object} The updated surface with offset control points.\n */","code":"function offsetSurface(surface, distance) {\n    var degreeU = surface.degreeU;\n    var degreeV = surface.degreeV;\n    var controlPoints = surface.controlPoints;\n    var weights = surface.weights;\n    var knotsU = surface.knotsU;\n    var knotsV = surface.knotsV;\n\n    for (var i = 0; i < controlPoints.length; i++) {\n        controlPoints[i][2] += distance;\n    }\n\n    return { degreeU: degreeU, degreeV: degreeV, controlPoints: controlPoints, weights: weights, knotsU: knotsU, knotsV: knotsV };\n}","lastGenerated":"2024-05-27T06:37:42.443Z"}
{"_id":"projectCurveOntoSurface","projectName":"default","arguments":"curve, surface","specification":"Projects a NURBS curve onto a NURBS surface.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n* Projects a NURBS curve onto a given surface.\n*\n* @param {NURBS Curve} curve - The curve to project.\n* @param {NURBS Surface} surface - The surface to project onto.\n* @returns {NURBS Surface} The projected surface.\n*/","code":"function projectCurveOntoSurface(curve, surface) {\n    var degreeU = surface.degreeU;\n    var degreeV = surface.degreeV;\n    var controlPoints = [];\n    for (var i = 0; i < curve.controlPoints.length; i++) {\n        var point = curve.controlPoints[i];\n        var weights = [];\n        for (var j = 0; j <= degreeU; j++) {\n            weights[j] = deBoorAlgorithm(degreeU, [point], surface.knotsU, i, j);\n        }\n        controlPoints.push({ x: 0, y: 0, z: 0, weights: weights });\n    }\n    for (var i = 0; i <= degreeV; i++) {\n        var knot = surface.knotsV[i];\n        var points = [];\n        for (var j = 0; j < controlPoints.length; j++) {\n            points.push({ x: controlPoints[j].x, y: controlPoints[j].y, z: controlPoints[j].z });\n        }\n        var curve = createNURBSCurve(degreeU, points, surface.weightsV, [knot]);\n        for (var j = 0; j <= degreeV; j++) {\n            weights[j] = deBoorAlgorithm(degreeV, [curve], surface.knotsV, i, j);\n        }\n        controlPoints.push({ x: 0, y: 0, z: 0, weights: weights });\n    }\n    var resultSurface = createNURBSSurface(degreeU, degreeV, controlPoints, surface.weightsU, surface.knotsU, surface.knotsV);\n    return resultSurface;\n}","lastGenerated":"2024-05-27T05:46:37.939Z"}
{"_id":"refineCurveKnotVector","projectName":"default","arguments":"curve, additionalKnots","specification":"Refines the knot vector of a NURBS curve.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Refine the curve knot vector by adding new knots.\n *\n * @param {Object} curve - The curve object.\n * @param {Array} additionalKnots - The additional knots to add.\n */","code":"function refineCurveKnotVector(curve, additionalKnots) {\n    var degree = curve.degree;\n    var knots = curve.knots;\n    var weights = curve.weights;\n    var controlPoints = curve.controlPoints;\n    \n    for (var i = 0; i < additionalKnots.length; i++) {\n        var knot = additionalKnots[i];\n        \n        // check if the knot is inside the existing knot vector\n        var found = false;\n        for (var j = 0; j < knots.length; j++) {\n            if (knot >= knots[j] && knot <= knots[j + 1]) {\n                found = true;\n                break;\n            }\n        }\n        \n        // add the new knot to the existing knot vector\n        if (!found) {\n            var kInsertIndex = 0;\n            for (var j = 0; j < knots.length; j++) {\n                if (knot >= knots[j] && knot <= knots[j + 1]) {\n                    kInsertIndex = j;\n                    break;\n                }\n            }\n            if (kInsertIndex > 0) {\n                for (var j = knots.length - 1; j > kInsertIndex; j--) {\n                    knots[j] = knots[j - 1];\n                }\n            }\n            knots.splice(kInsertIndex, 0, knot);\n        }\n    }\n}","lastGenerated":"2024-05-27T04:58:50.278Z"}
{"_id":"refineSurfaceKnotVector","projectName":"default","arguments":"surface, additionalKnotsU, additionalKnotsV","specification":"Refines the knot vectors of a NURBS surface.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Refine the surface knot vector by adding new knots and removing existing ones.\n *\n * @param {Surface} surface The surface to refine.\n * @param {Array<number>} additionalKnotsU Additional U-knots to add.\n * @param {Array<number>} additionalKnotsV Additional V-knots to add.\n * @return {Surface} The refined surface.\n */","code":"function refineSurfaceKnotVector(surface, additionalKnotsU, additionalKnotsV) {\n    var degreeU = surface.degreeU;\n    var degreeV = surface.degreeV;\n    var controlPoints = surface.controlPoints;\n    var knotsU = surface.knotsU;\n    var knotsV = surface.knotsV;\n    var weights = surface.weights;\n\n    for (var i = 0; i < additionalKnotsU.length; i++) {\n        if (knotsU.indexOf(additionalKnotsU[i]) === -1) {\n            knotsU.push(additionalKnotsU[i]);\n        }\n    }\n\n    for (var j = 0; j < additionalKnotsV.length; j++) {\n        if (knotsV.indexOf(additionalKnotsV[j]) === -1) {\n            knotsV.push(additionalKnotsV[j]);\n        }\n    }\n\n    var newKnotVectorU = [];\n    for (var i = 0; i < knotsU.length; i++) {\n        if (knotsU[i] < controlPoints[0][0]) {\n            newKnotVectorU.push(knotsU[i]);\n        } else if (knotsU[i] > controlPoints[knotsU.length - 1][0]) {\n            newKnotVectorU.push(knotsU[i]);\n        }\n    }\n\n    var newKnotVectorV = [];\n    for (var j = 0; j < knotsV.length; j++) {\n        if (knotsV[j] < controlPoints[0][1]) {\n            newKnotVectorV.push(knotsV[j]);\n        } else if (knotsV[j] > controlPoints[knotsV.length - 1][1]) {\n            newKnotVectorV.push(knotsV[j]);\n        }\n    }\n\n    surface.knotsU = newKnotVectorU;\n    surface.knotsV = newKnotVectorV;\n\n    return surface;\n}","lastGenerated":"2024-05-27T06:09:21.868Z"}
{"_id":"revolveCurve","projectName":"default","arguments":"curve, axis, angle","specification":"Revolves a NURBS curve around a specified axis.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @param {Object} curve - The input curve to revolve.\n * @param {String} axis - The axis around which the curve is revolved (x, y, or z).\n * @param {Number} angle - The angle of rotation in radians.\n * @returns {Object} The resulting NURBS curve after revolution.\n */","code":"function revolveCurve(curve, axis, angle) {\n    var controlPoints = [];\n    for (var i = 0; i < curve.controlPoints.length; i++) {\n        var point = curve.controlPoints[i];\n        controlPoints.push({\n            x: point.x * Math.cos(angle) - point.z * Math.sin(angle),\n            y: point.y,\n            z: point.x * Math.sin(angle) + point.z * Math.cos(angle)\n        });\n    }\n    return createNURBSCurve(1, controlPoints, [1], [0]);\n}","lastGenerated":"2024-05-27T05:29:25.214Z"}
{"_id":"shellSurface","projectName":"default","arguments":"surface, thickness","specification":"Creates a shell from a surface by offsetting it.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n* @param {Array} surface - The original surface points.\n* @param {Number} thickness - The thickness of the shell surface.\n* @return {Array} - The resulting shell surface points.\n*/","code":"function shellSurface(surface, thickness) {\n    var result = [];\n    for (var i = 0; i < surface.length; i++) {\n        var point = surface[i];\n        var newPoint1 = {x: point.x - thickness, y: point.y, z: point.z};\n        var newPoint2 = {x: point.x + thickness, y: point.y, z: point.z};\n        result.push(newPoint1);\n        result.push(newPoint2);\n    }\n    return result;\n}","lastGenerated":"2024-05-27T06:36:03.445Z"}
{"_id":"splitCurve","projectName":"default","arguments":"curve, param","specification":"Splits a NURBS curve at a given parameter.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @param {Object} curve - Curve object.\n * @param {number} param - Param value.\n * @return {Object} New curve object with updated control points and knots.\n */","code":"function splitCurve(curve, param) {\n    var degree = curve.degree;\n    var controlPoints = curve.controlPoints;\n    var weights = curve.weights;\n    var knots = curve.knots;\n\n    for (var i = 0; i < degree; i++) {\n        controlPoints[i] /= (weights[0] * (knots[1] - param) + weights[1] * (param - knots[0]));\n    }\n\n    for (var i = 0; i < degree; i++) {\n        controlPoints[i] *= (weights[0] * (knots[1] - param) + weights[1] * (param - knots[0]));\n    }\n\n    var newKnots = [];\n    for (var i = 0; i < knots.length; i++) {\n        if (knots[i] <= param) {\n            newKnots.push(knots[i]);\n        } else {\n            break;\n        }\n    }\n\n    for (var i = knots.length - 1; i >= 0; i--) {\n        if (knots[i] > param) {\n            newKnots.push(knots[i]);\n        } else {\n            break;\n        }\n    }\n\n    return { degree: degree, controlPoints: controlPoints, weights: [weights[0], weights[1]], knots: newKnots };\n}","lastGenerated":"2024-05-27T05:41:40.086Z"}
{"_id":"splitSurface","projectName":"default","arguments":"surface, paramU, paramV","specification":"Splits a NURBS surface at given parameters.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Splits a surface into two parts based on the given parameters.\n *\n * @param {Object} surface The surface to split.\n * @param {Number} paramU The parameter U to split by.\n * @param {Number} paramV The parameter V to split by.\n * @return {[Array]} An array of two surfaces, the left and right parts.\n */","code":"function splitSurface(surface, paramU, paramV) {\n    var degreeU = surface.degreeU;\n    var degreeV = surface.degreeV;\n    var controlPoints = surface.controlPoints;\n    var knotsU = surface.knotsU;\n    var knotsV = surface.knotsV;\n    var weights = surface.weights;\n\n    var leftSurface = new Array();\n    var rightSurface = new Array();\n\n    for (var i = 0; i < controlPoints.length; i++) {\n        var point = controlPoints[i];\n        if (point[0] <= paramU) {\n            leftSurface.push(point);\n        } else if (point[0] > paramV) {\n            rightSurface.push(point);\n        }\n    }\n\n    for (var i = 0; i < knotsU.length; i++) {\n        var knot = knotsU[i];\n        if (knot <= paramU) {\n            leftSurface.push([knot, 0]);\n        } else if (knot > paramV) {\n            rightSurface.push([knot, 0]);\n        }\n    }\n\n    for (var i = 0; i < knotsV.length; i++) {\n        var knot = knotsV[i];\n        if (knot <= paramU) {\n            leftSurface.push([0, knot]);\n        } else if (knot > paramV) {\n            rightSurface.push([0, knot]);\n        }\n    }\n\n    for (var i = 0; i < weights.length; i++) {\n        var weight = weights[i];\n        if (weight <= paramU) {\n            leftSurface.push(weight);\n        } else if (weight > paramV) {\n            rightSurface.push(weight);\n        }\n    }\n\n    return [leftSurface, rightSurface];\n}","lastGenerated":"2024-05-27T06:43:05.415Z"}
{"_id":"surfaceArea","projectName":"default","arguments":"surface","specification":"Computes the area of a NURBS surface.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n* Calculates the surface area of a given surface.\n*\n* @param {Object} surface - The surface to calculate the area for.\n* @returns {Number} The calculated surface area.\n*/","code":"function surfaceArea(surface) {\n    let sum = 0;\n    for (let u = 0; u <= surface.knotsU.length - 1; u++) {\n        for (let v = 0; v <= surface.knotsV.length - 1; v++) {\n            let basisU = analyzeSurfaceCurvature(surface, u, v).basis;\n            let basisV = analyzeSurfaceCurvature(surface, u, v).basis;\n            sum += Math.abs(basisU * basisV);\n        }\n    }\n    return sum;\n}","lastGenerated":"2024-05-27T06:13:25.795Z"}
{"_id":"surfaceBoundingBox","projectName":"default","arguments":"surface","specification":"Computes the bounding box of a NURBS surface.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Calculate the bounding box of a given surface.\n *\n * @param {Object} surface The surface to calculate the bounding box for.\n * @returns {{x: number, y: number, z: number, width: number, height: number, depth: number}} The bounding box as an object with x, y, z coordinates and width, height, depth values.\n */","code":"function surfaceBoundingBox(surface) {\n    var minX = Infinity;\n    var maxX = -Infinity;\n    var minY = Infinity;\n    var maxY = -Infinity;\n    var minZ = Infinity;\n    var maxZ = -Infinity;\n\n    for (var i = 0; i < surface.controlPoints.length; i++) {\n        var point = surface.controlPoints[i];\n        if (point.x < minX) minX = point.x;\n        if (point.x > maxX) maxX = point.x;\n        if (point.y < minY) minY = point.y;\n        if (point.y > maxY) maxY = point.y;\n        if (point.z < minZ) minZ = point.z;\n        if (point.z > maxZ) maxZ = point.z;\n    }\n\n    return {x: minX, y: minY, z: minZ, width: maxX - minX, height: maxY - minY, depth: maxZ - minZ};\n}","lastGenerated":"2024-05-27T06:03:07.830Z"}
{"_id":"surfaceControlNet","projectName":"default","arguments":"surface","specification":"Returns the control net of a NURBS surface.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Generates a network of control points for a surface.\n *\n * @param {Object} surface The surface object to generate the control point network from.\n * @returns {Array} An array of arrays, where each inner array represents a row in the control point network.\n */","code":"function surfaceControlNet(surface) {\n    var degreeU = surface.degreeU;\n    var degreeV = surface.degreeV;\n    var controlPoints = surface.controlPoints;\n    var weights = surface.weights;\n    var knotsU = surface.knotsU;\n    var knotsV = surface.knotsV;\n    \n    var net = [];\n    for (var i = 0; i < controlPoints.length; i++) {\n        var point = controlPoints[i];\n        var row = [];\n        for (var j = 0; j < controlPoints[0].length; j++) {\n            row.push(point[j]);\n        }\n        net.push(row);\n    }\n    \n    return net;\n}","lastGenerated":"2024-05-27T06:32:34.414Z"}
{"_id":"surfaceDegreeElevation","projectName":"default","arguments":"surface, newDegreeU, newDegreeV","specification":"Elevates the degrees of a NURBS surface.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @name surfaceDegreeElevation\n * @param {Object} surface - The surface to modify.\n * @param {number} newDegreeU - The new degree U for the surface.\n * @param {number} newDegreeV - The new degree V for the surface.\n * @returns {Object} The modified surface.\n */","code":"function surfaceDegreeElevation(surface, newDegreeU, newDegreeV) {\n    var degreeU = surface.degreeU;\n    var degreeV = surface.degreeV;\n    var controlPoints = surface.controlPoints;\n    var weights = surface.weights;\n    var knotsU = surface.knotsU;\n    var knotsV = surface.knotsV;\n\n    for (var i = 0; i < controlPoints.length; i++) {\n        controlPoints[i].curveDegreeElevation(newDegreeU);\n    }\n\n    for (var j = 0; j < weights.length; j++) {\n        weights[j] = deBoorAlgorithmSurface(newDegreeU, newDegreeV, controlPoints, knotsU, knotsV, knotsU[j], knotsV[j]);\n    }\n\n    surface.degreeU = newDegreeU;\n    surface.degreeV = newDegreeV;\n\n    return surface;\n}\n","lastGenerated":"2024-05-27T06:27:35.979Z"}
{"_id":"surfaceDerivativeAtParam","projectName":"default","arguments":"surface, paramU, paramV, orderU, orderV","specification":"Computes the derivatives of a NURBS surface at given parameters.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @param {Object} surface - The control point and weight array of the NURBS surface.\n * @param {Number} paramU - The parameter value for U direction.\n * @param {Number} paramV - The parameter value for V direction.\n * @param {Number} orderU - The order of the basis function in U direction.\n * @param {Number} orderV - The order of the basis function in V direction.\n * @returns {Object} The derivative of the NURBS surface at the given parameter values.\n */","code":"function surfaceDerivativeAtParam(surface, paramU, paramV, orderU, orderV) {\n    var basisFunctions = [];\n    for (var i = 0; i < surface.controlPoints.length; i++) {\n        basisFunctions.push([]);\n        for (var j = 0; j < surface.weights[i].length; j++) {\n            basisFunctions[i].push({\n                x: surface.controlPoints[i][0] * surface.weights[i][j],\n                y: surface.controlPoints[i][1] * surface.weights[i][j],\n                z: surface.controlPoints[i][2] * surface.weights[i][j]\n            });\n        }\n    }\n    var derivativeU = {\n        x: 0,\n        y: 0,\n        z: 0\n    };\n    var derivativeV = {\n        x: 0,\n        y: 0,\n        z: 0\n    };\n    for (var i = 0; i < surface.controlPoints.length; i++) {\n        for (var j = 0; j < surface.weights[i].length; j++) {\n            var basisU = basisFunctions[i][j];\n            var basisV = basisFunctions[i + 1][j] ? basisFunctions[i + 1][j] : { x: 0, y: 0, z: 0 };\n            var derivativeUU = {\n                x: surface.weights[i][j] * (basisU.x - basisV.x),\n                y: surface.weights[i][j] * (basisU.y - basisV.y),\n                z: surface.weights[i][j] * (basisU.z - basisV.z)\n            };\n            var derivativeVV = {\n                x: 0,\n                y: 0,\n                z: 0\n            };\n            for (var k = 0; k < surface.controlPoints.length; k++) {\n                for (var l = 0; l < surface.weights[k].length; l++) {\n                    var basisUU = basisFunctions[k][l];\n                    var basisVV = basisFunctions[k + 1][l] ? basisFunctions[k + 1][l] : { x: 0, y: 0, z: 0 };\n                    derivativeVV.x += surface.weights[k][l] * (basisUU.x - basisVV.x);\n                    derivativeVV.y += surface.weights[k][l] * (basisUU.y - basisVV.y);\n                    derivativeVV.z += surface.weights[k][l] * (basisUU.z - basisVV.z);\n                }\n            }\n            derivativeU.x += derivativeUU.x;\n            derivativeU.y += derivativeUU.y;\n            derivativeU.z += derivativeUU.z;\n            derivativeV.x += derivativeVV.x / Math.pow(surface.knotsU[paramU], orderU + 1);\n            derivativeV.y += derivativeVV.y / Math.pow(surface.knotsU[paramU], orderU + 1);\n            derivativeV.z += derivativeVV.z / Math.pow(surface.knotsU[paramU], orderU + 1);\n        }\n    }\n    return {\n        x: derivativeU.x * surface.weights[paramU][0],\n        y: derivativeU.y * surface.weights[paramU][0],\n        z: derivativeU.z * surface.weights[paramU][0]\n    };\n}","lastGenerated":"2024-05-27T06:17:32.634Z"}
{"_id":"surfaceKnotInsertion","projectName":"default","arguments":"surface, knotU, knotV","specification":"Inserts knots into a NURBS surface.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @param {Surface} surface \n * @param {Array} knotU \n * @param {Array} knotV \n */ \n\n/**\n * Inserts knots into a Bezier surface.\n *\n * This method can be implemented based on the specific needs of your application.\n */","code":"function surfaceKnotInsertion(surface, knotU, knotV) {\n    var degreeU = surface.degreeU;\n    var degreeV = surface.degreeV;\n    var controlPoints = surface.controlPoints;\n    var weights = surface.weights;\n    var knotsU = surface.knotsU;\n    var knotsV = surface.knotsV;\n\n    // Your implementation here\n}\n","lastGenerated":"2024-05-27T06:22:29.697Z"}
{"_id":"surfaceNormalAtParam","projectName":"default","arguments":"surface, paramU, paramV","specification":"Computes the normal of a NURBS surface at given parameters.\nDo not use var. Use let. ","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Calculates the surface normal at a given parameterized position (u, v) on a NURBS surface.\n *\n * @param {NURBS.Surface} surface - The NURBS surface to calculate the normal for.\n * @param {number} paramU - The U parameter value.\n * @param {number} paramV - The V parameter value.\n * @returns {Array.<number>} The surface normal at the given position (u, v).\n */","code":"function surfaceNormalAtParam(surface, paramU, paramV) {\n    let du = [];\n    let dv = [];\n    for (let i = 0; i < surface.controlPoints.length; i++) {\n        let controlPoint = surface.controlPoints[i];\n        du.push([controlPoint[0], controlPoint[1], controlPoint[2]]);\n        dv.push([controlPoint[3], controlPoint[4], controlPoint[5]]);\n    }\n    for (let i = 0; i < surface.weights.length; i++) {\n        let weight = surface.weights[i];\n        for (let j = 0; j < du.length; j++) {\n            du[j][0] += weight * surface.controlPoints[i][6] * surface.knotsU[i + 1] - surface.knotsU[i];\n            du[j][1] += weight * surface.controlPoints[i][7] * surface.knotsU[i + 1] - surface.knotsU[i];\n            du[j][2] += weight * surface.controlPoints[i][8] * surface.knotsU[i + 1] - surface.knotsU[i];\n        }\n        for (let j = 0; j < dv.length; j++) {\n            dv[j][0] += weight * surface.controlPoints[i][9] * surface.knotsV[j + 1] - surface.knotsV[j];\n            dv[j][1] += weight * surface.controlPoints[i][10] * surface.knotsV[j + 1] - surface.knotsV[j];\n            dv[j][2] += weight * surface.controlPoints[i][11] * surface.knotsV[j + 1] - surface.knotsV[j];\n        }\n    }\n    let normal = [0, 0, 0];\n    for (let i = 0; i < du.length; i++) {\n        for (let j = 0; j < dv.length; j++) {\n            normal[0] += du[i][0] * dv[j][1] - dv[i][0] * du[j][1];\n            normal[1] += du[i][1] * dv[j][2] - dv[i][1] * du[j][2];\n            normal[2] += du[i][2] * dv[j][0] - dv[i][2] * du[j][0];\n        }\n    }\n    return [normal[0], normal[1], normal[2]];\n}\n","lastGenerated":"2024-05-27T15:05:53.966Z"}
{"_id":"surfacePointProjection","projectName":"default","arguments":"surface, point","specification":"Projects a point onto a NURBS surface.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @param {Object} surface - the NURBS surface to project onto\n * @param {Object} point - the 3D point to project\n * @returns {Object} - the projected 2D point and its closest distance from the surface, or null if no close enough points were found\n */","code":"function surfacePointProjection(surface, point) {\n  var u = 0;\n  var v = 0;\n  var minDistance = Infinity;\n  var closestPoint = null;\n\n  for (var i = 0; i < surface.knotsU.length - 1; i++) {\n    for (var j = 0; j < surface.knotsV.length - 1; j++) {\n      var uVal = surface.deBoorAlgorithmSurface(surface.degreeU, surface.controlPoints, surface.knotsU, surface.knotsV, i, j);\n      var vVal = surface.deBoorAlgorithmSurface(surface.degreeV, surface.controlPoints, surface.knotsU, surface.knotsV, i, j);\n\n      if (Math.abs(point.x - uVal) + Math.abs(point.y - vVal) <= 0.001) {\n        return {x: point.x, y: point.y, z: evaluateSurfaceAtParam(surface, u, v)};\n      }\n\n      var distance = Math.pow(evaluateSurfaceAtParam(surface, i + (u - surface.knotsU[0]) / (surface.knotsU[i + 1] - surface.knotsU[0])), 2) +\n        Math.pow(evaluateSurfaceAtParam(surface, j + (v - surface.knotsV[0]) / (surface.knotsV[j + 1] - surface.knotsV[0])), 2);\n\n      if (distance < minDistance) {\n        minDistance = distance;\n        closestPoint = {x: evaluateSurfaceAtParam(surface, u), y: evaluateSurfaceAtParam(surface, v), z: evaluateSurfaceAtParam(surface, u, v)};\n      }\n    }\n  }\n\n  return closestPoint;\n}","lastGenerated":"2024-05-27T06:11:59.515Z"}
{"_id":"surfaceReparameterization","projectName":"default","arguments":"surface, newKnotVectorU, newKnotVectorV","specification":"Reparameterizes a NURBS surface with new knot vectors.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * @param {Surface} surface The input surface.\n * @param {Array<number>} newKnotVectorU The new knot vector for the U direction.\n * @param {Array<number>} newKnotVectorV The new knot vector for the V direction.\n * @returns {{controlPoints: Array<Array<number>>, weights: Array<number>, degreeU: number, degreeV: number, knotsU: Array<number>, knotsV: Array<number>}} The updated surface information.\n\n**/","code":"function surfaceReparameterization(surface, newKnotVectorU, newKnotVectorV) {\n    var degreeU = surface.degreeU;\n    var degreeV = surface.degreeV;\n    var controlPoints = surface.controlPoints;\n    var weights = surface.weights;\n    var knotsU = surface.knotsU;\n    var knotsV = surface.knotsV;\n\n    for (var i = 0; i < newKnotVectorU.length; i++) {\n        if (newKnotVectorU[i] > knotsU[degreeU]) {\n            for (var j = degreeU; j >= 0; j--) {\n                controlPoints[j][1] = deBoorAlgorithm(degreeU, controlPoints[j], knotsU, newKnotVectorU[i], 1);\n                weights[j] = weights[j] * controlPoints[j][2];\n            }\n        } else if (newKnotVectorU[i] < knotsU[0]) {\n            for (var j = degreeU; j >= 0; j--) {\n                controlPoints[j][1] = deBoorAlgorithm(degreeU, controlPoints[j], knotsU, newKnotVectorU[i], 1);\n                weights[j] = weights[j] * controlPoints[j][2];\n            }\n        }\n    }\n\n    for (var i = 0; i < newKnotVectorV.length; i++) {\n        if (newKnotVectorV[i] > knotsV[degreeV]) {\n            for (var j = degreeV; j >= 0; j--) {\n                controlPoints[j][2] = deBoorAlgorithm(degreeV, controlPoints[j][1], knotsV, newKnotVectorV[i], 1);\n                weights[j] = weights[j] * controlPoints[j][2];\n            }\n        } else if (newKnotVectorV[i] < knotsV[0]) {\n            for (var j = degreeV; j >= 0; j--) {\n                controlPoints[j][2] = deBoorAlgorithm(degreeV, controlPoints[j][1], knotsV, newKnotVectorV[i], 1);\n                weights[j] = weights[j] * controlPoints[j][2];\n            }\n        }\n    }\n\n    return { controlPoints: controlPoints, weights: weights, degreeU: degreeU, degreeV: degreeV, knotsU: newKnotVectorU, knotsV: newKnotVectorV };\n}\n","lastGenerated":"2024-05-27T06:30:53.758Z"}
{"_id":"surfaceSubdivision","projectName":"default","arguments":"surface, paramU, paramV","specification":"Subdivides a NURBS surface at given parameters.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Subdivides the given surface at the specified parametric coordinates (U, V).\n *\n * @param {Object} surface The surface to be subdivided.\n * @param {Number} paramU The U-coordinate of the subdivision point.\n * @param {Number} paramV The V-coordinate of the subdivision point.\n * @returns {Object} The new control points, weights, and knots for the subdivided surface.\n */","code":"function surfaceSubdivision(surface, paramU, paramV) {\n    var degreeU = surface.degreeU;\n    var degreeV = surface.degreeV;\n    var controlPoints = surface.controlPoints;\n    var weights = surface.weights;\n    var knotsU = surface.knotsU;\n    var knotsV = surface.knotsV;\n\n    var newControlPoints = [];\n    for (var i = 0; i < controlPoints.length; i++) {\n        if ((knotsU[i] <= paramU && paramU <= knotsU[i + degreeU]) &&\n            (knotsV[0] <= paramV && paramV <= knotsV[knotsV.length - 1])) {\n            newControlPoints.push({\n                x: controlPoints[i].x,\n                y: controlPoints[i].y,\n                z: controlPoints[i].z\n            });\n        }\n    }\n\n    var newWeights = [];\n    for (var i = 0; i < weights.length; i++) {\n        if ((knotsU[i] <= paramU && paramU <= knotsU[i + degreeU]) &&\n            (knotsV[0] <= paramV && paramV <= knotsV[knotsV.length - 1])) {\n            newWeights.push(weights[i]);\n        }\n    }\n\n    var newKnotsU = [];\n    for (var i = 0; i < knotsU.length; i++) {\n        if (knotsU[i] <= paramU && paramU <= knotsU[i + degreeU]) {\n            newKnotsU.push(knotsU[i]);\n        }\n    }\n\n    var newKnotsV = [];\n    for (var i = 0; i < knotsV.length; i++) {\n        if (knotsV[i] <= paramV && paramV <= knotsV[i + degreeV]) {\n            newKnotsV.push(knotsV[i]);\n        }\n    }\n\n    return { controlPoints: newControlPoints, weights: newWeights, knotsU: newKnotsU, knotsV: newKnotsV };\n}","lastGenerated":"2024-05-27T06:25:42.036Z"}
{"_id":"surfaceToMesh","projectName":"default","arguments":"surface, tolerance","specification":"Approximates a NURBS surface with a mesh within a given tolerance.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Converts a surface into a mesh.\n *\n * @param {Object} surface - The surface to convert.\n * @param {Number} tolerance - The maximum distance between points in the mesh.\n * @return {Array} The resulting mesh.\n */","code":"function surfaceToMesh(surface, tolerance) {\n    var knotVectorU = surface.knotsU;\n    var knotVectorV = surface.knotsV;\n    var controlPoints = surface.controlPoints;\n    var degreeU = surface.degreeU;\n    var degreeV = surface.degreeV;\n\n    var mesh = [];\n\n    for (var u = 0; u <= knotVectorU.length - 1; u++) {\n        for (var v = 0; v <= knotVectorV.length - 1; v++) {\n            var point = evaluateSurfaceAtParam(surface, u, v);\n            if (!mesh.some(function(m) { return distance(m, point) < tolerance })) {\n                mesh.push(point);\n            }\n        }\n    }\n\n    return mesh;\n}\n\nfunction distance(p1, p2) {\n    return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2) + Math.pow(p2.z - p1.z, 2));\n}","lastGenerated":"2024-05-27T06:34:31.173Z"}
{"_id":"sweepCurve","projectName":"default","arguments":"curve, path","specification":"Sweeps a NURBS curve along a given path.","needsGeneration":"false","errorLogs":"","jsdoc":" /**\n * Sweeps a given curve along a path to generate a surface mesh.\n *\n * This function takes in a `curve` representing the base shape and a `path` that defines the sweep direction, \n * then generates an array of control points by blending the current control point with adjacent control point from the path using tangent vectors at each curve parameter value. Finally, it creates a NURBS surface mesh based on these generated points.\n *\n * @param {Curve} curve - The base shape represented as a Curve object to be swept along the given path.\n * @param {Path} path - A Path object defining the direction and extent of the sweep.\n * @returns {NURBSSurface} - A NURBS surface mesh generated by sweeping the input curve along the provided path.\n */","code":"function sweepCurve(curve, path) {\n  var points = [];\n  for (var i = 0; i < curve.length(); i++) {\n    var currentControlPoint = curve.evaluateAtParam(i);\n    var nextControlPoint = path.getNextPoint(i);\n    var tangentDirection = curveTangentAtParam(curve, i);\n    \n    points.push({x: currentControlPoint.x + tangentDirection.x * nextControlPoint.distance(), y: currentControlPoint.y + tangentDirection.y * nextControlPoint.distance(), z: currentControlPoint.z});\n  }\n  \n  var surface = createNURBSSurface(1, 1, points, [{}]*points.length, [0, path.getTotalLength()], [[0]]);\n  return surface;\n}","lastGenerated":"2024-06-01T01:07:23.071Z"}
{"_id":"trimCurve","projectName":"default","arguments":"curve, paramStart, paramEnd","specification":"Trims a NURBS curve between two parameters.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n* Trims the control points, weights and knots of a Bezier curve to a specified range.\n*\n* @param {Object} curve The Bezier curve object.\n* @param {Number} paramStart The start parameter value (inclusive).\n* @param {Number} paramEnd The end parameter value (inclusive).\n* @returns {Object} A new curve with trimmed control points, weights and knots.\n*/","code":"function trimCurve(curve, paramStart, paramEnd) {\n    var startKnot = null;\n    var endKnot = null;\n\n    for (var i = 0; i < curve.knots.length; i++) {\n        if (curve.knots[i] >= paramStart && startKnot === null) {\n            startKnot = i;\n        }\n        if (curve.knots[i] >= paramEnd && endKnot === null) {\n            endKnot = i;\n        }\n    }\n\n    if (startKnot === null || endKnot === null) {\n        throw new Error(\"Invalid parameter range\");\n    }\n\n    var startWeight = 0;\n    for (var i = startKnot; i < curve.knots.length && startWeight === 0; i++) {\n        if (curve.knots[i] >= paramStart) {\n            startWeight = curve.weights[i];\n        }\n    }\n\n    var endWeight = 0;\n    for (var i = endKnot - 1; i >= 0 && endWeight === 0; i--) {\n        if (curve.knots[i] <= paramEnd) {\n            endWeight = curve.weights[i];\n        }\n    }\n\n    var newControlPoints = [];\n    var newWeights = [];\n    var newKnots = [];\n\n    for (var i = startKnot; i < endKnot; i++) {\n        newControlPoints.push(curve.controlPoints[i]);\n        newWeights.push(startWeight);\n        if (curve.knots[i] !== curve.knots[startKnot]) {\n            newKnots.push(curve.knots[i]);\n        }\n    }\n\n    return { controlPoints: newControlPoints, weights: newWeights, knots: newKnots };\n}","lastGenerated":"2024-05-27T05:39:22.069Z"}
{"_id":"trimSurface","projectName":"default","arguments":"surface, boundaryCurve","specification":"Trims a NURBS surface with a boundary curve.","needsGeneration":"false","errorLogs":"","jsdoc":"/**\n * Trims the surface control points to only those that lie within a given boundary curve.\n *\n * @param {Object} surface The NURBS surface to trim.\n * @param {Object} boundaryCurve The boundary curve used for trimming.\n * @return {Object} The trimmed surface.\n */","code":"function trimSurface(surface, boundaryCurve) {\n    var surfaceKnotsU = surface.knotsU;\n    var surfaceKnotsV = surface.knotsV;\n    var surfaceDegreeU = surface.degreeU;\n    var surfaceDegreeV = surface.degreeV;\n    var surfaceControlPoints = surface.controlPoints;\n    var boundaryKnots = boundaryCurve.knots;\n    var boundaryDegree = boundaryCurve.degree;\n    var boundaryControlPoints = boundaryCurve.controlPoints;\n\n    for (var i = 0; i < surfaceControlPoints.length; i++) {\n        var point = surfaceControlPoints[i];\n        if (!pointOutsideBoundary(point, boundaryKnots, boundaryControlPoints)) {\n            surfaceControlPoints.splice(i, 1);\n            i--;\n        }\n    }\n\n    function pointOutsideBoundary(point, boundaryKnots, boundaryControlPoints) {\n        for (var j = 0; j < boundaryControlPoints.length - 1; j++) {\n            var controlPoint1 = boundaryControlPoints[j];\n            var controlPoint2 = boundaryControlPoints[j + 1];\n            if (point.x >= Math.min(controlPoint1.x, controlPoint2.x) &&\n                point.x <= Math.max(controlPoint1.x, controlPoint2.x) &&\n                point.y >= Math.min(controlPoint1.y, controlPoint2.y) &&\n                point.y <= Math.max(controlPoint1.y, controlPoint2.y)) {\n                continue;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    surface.knotsU = surfaceKnotsU;\n    surface.degreeU = surfaceDegreeU;\n    surface.controlPoints = surfaceControlPoints;\n\n    return surface;\n}\n","lastGenerated":"2024-05-27T06:40:20.832Z"}
