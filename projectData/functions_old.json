{"_id":"`applyTransformationMatrixNurbs","projectName":"default","arguments":"nurbObj, transformationMatrix","specification":"Applies a 4x4 matrix to transform a NURBS object in 3D space.","needsGeneration":"true","jsdoc":"/**\n * Applies a transformation matrix to a Nurbs object, updating its control points,\n * weights and knot vector.\n *\n * @param {Nurbs} nurbObj - The Nurbs object to transform\n * @param {Array<number>} transformationMatrix - The transformation matrix to apply\n */","code":"function `applyTransformationMatrixNurbs(nurbObj, transformationMatrix) {\n    let controlPoints = nurbObj.controlPoints;\n    let weights = nurbObj.weights;\n    let knotVector = nurbObj.knotVector;\n\n    for (let i = 0; i < controlPoints.length; i++) {\n        controlPoints[i].x = dotProduct([1, 0, 0], multiplyMatrix(transformationMatrix, [controlPoints[i].x, 0, 0, 1]));\n        controlPoints[i].y = dotProduct([0, 1, 0], multiplyMatrix(transformationMatrix, [controlPoints[i].y, 0, 0, 1]));\n        controlPoints[i].z = dotProduct([0, 0, 1], multiplyMatrix(transformationMatrix, [controlPoints[i].z, 0, 0, 1]));\n    }\n\n    for (let i = 0; i < weights.length; i++) {\n        weights[i] = multiplyScalar(multiplyMatrix(transformationMatrix, [weights[i], 0, 0, 1])[3], -1);\n    }\n\n    let newKnotVector = [];\n    for (let i = 0; i < knotVector.length; i++) {\n        newKnotVector.push(dotProduct([1, 0, 0], multiplyMatrix(transformationMatrix, [knotVector[i], 0, 0, 1])));\n    }\n\n    nurbObj.controlPoints = controlPoints;\n    nurbObj.weights = weights;\n    nurbObj.knotVector = newKnotVector;\n}\n\nfunction multiplyMatrix(matrix, vector) {\n    return [\n        matrix[0] * vector[0] + matrix[3] * vector[2],\n        matrix[1] * vector[0] + matrix[4] * vector[2],\n        0,\n        0\n    ];\n}\n\nfunction multiplyScalar(number, scalar) {\n    return number * scalar;\n}\n\nfunction dotProduct(vector1, vector2) {\n    return vector1[0] * vector2[0] + vector1[1] * vector2[1] + vector1[2] * vector2[2];\n}","errorLogs":"Unexpected template string \n  SyntaxError: Unexpected template string\n    at executeCodeAsync (file:///root/notDevin/src/serverFunctions/functions/generate.js:64:43)\n    at function_generate (file:///root/notDevin/src/serverFunctions/functions/generate.js:34:35)\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\n    at async Module.addFunctions (file:///root/notDevin/src/serverFunctions/planner/addFunctions.js:15:9)\n    at async file:///root/notDevin/src/server.js:20:28","lastGenerated":"2024-05-23T05:15:44.151Z"}
{"_id":"`applyTransformationToBrep","projectName":"default","arguments":"brepObj, transformationMatrix","specification":"Applies a given 4x4 matrix to transform a BREP object in space.","needsGeneration":"true"}
{"_id":"`buildBaseBrepObjectFromNurbsSurface","projectName":"default","arguments":"nurbObj","specification":"Constructs a base Boundary Representation (BREP) object from an existing NURBS surface.","needsGeneration":"true","jsdoc":"/**\n* @function {function} buildBaseBrepObjectFromNurbsSurface(nurbObj)\n*\n* Builds a base BREP object from Nurbs surface data.\n*\n* @param nurbObj {Object}\n*   The Nurbs surface data to be processed.\n*\n* @returns {Object}\n*   The resulting base BREP object.\n*/","code":"function `buildBaseBrepObjectFromNurbsSurface(nurbObj) {\n    var brep = new Object();\n    brep.type = \"BREP\";\n    brep.entities = [];\n    \n    for (var i = 0; i < nurbObj.knots[1].length - 1; i++) {\n        var tri = createTriangle([nurbObj.controlPoints[0][i], nurbObj.controlPoints[1][i], nurbObj.controlPoints[2][i]]);\n        calculateNormalVector(tri);\n        calculateTriangleArea(tri);\n        addTriangle(brep, tri);\n    }\n    \n    return brep;\n}","errorLogs":"Unexpected template string \n  SyntaxError: Unexpected template string\n    at executeCodeAsync (file:///root/notDevin/src/serverFunctions/functions/generate.js:64:43)\n    at function_generate (file:///root/notDevin/src/serverFunctions/functions/generate.js:34:35)\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\n    at async Module.addFunctions (file:///root/notDevin/src/serverFunctions/planner/addFunctions.js:15:9)\n    at async file:///root/notDevin/src/server.js:20:28","lastGenerated":"2024-05-23T05:25:16.374Z"}
{"_id":"`calculateSurfaceAreaFromNurbsSurface","projectName":"default","arguments":"surfaceObj","specification":"Calculates and returns the surface area of an existing NURBS surface.","needsGeneration":"true"}
{"_id":"`computeWeightedAverage","projectName":"default","arguments":"points, weights","specification":"Computes the weighted average of points based on given weights.","needsGeneration":"true","jsdoc":"/**\n * @param {Array} points - An array of points, each point having x, y, and z coordinates.\n * @param {Array} weights - An array of weights, one for each point in the points array.\n * @returns {{x: number, y: number, z: number}} The weighted average of all points in the format {x: avgX, y: avgY, z: avgZ}.\n */","code":"function `computeWeightedAverage(points, weights) {\n    let sum = 0;\n    for (let i = 0; i < points.length; i++) {\n        sum += points[i].x * weights[i] + points[i].y * weights[i] + points[i].z * weights[i];\n    }\n    let avgX = sum / weights.reduce((acc, cur) => acc + cur);\n    let avgY = sum / weights.reduce((acc, cur) => acc + cur);\n    let avgZ = sum / weights.reduce((acc, cur) => acc + cur);\n    return {x: avgX, y: avgY, z: avgZ};\n}","errorLogs":"Unexpected template string \n  SyntaxError: Unexpected template string\n    at executeCodeAsync (file:///root/notDevin/src/serverFunctions/functions/generate.js:64:43)\n    at function_generate (file:///root/notDevin/src/serverFunctions/functions/generate.js:34:35)\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\n    at async Module.addFunctions (file:///root/notDevin/src/serverFunctions/planner/addFunctions.js:15:9)\n    at async file:///root/notDevin/src/server.js:20:28","lastGenerated":"2024-05-23T05:22:22.992Z"}
{"_id":"`constructClosedCurveNurbs","projectName":"default","arguments":"controlPoints, weights, knotVector","specification":"Generates a closed NURBS curve from control points and knot vector.","needsGeneration":"true","jsdoc":"/**\n * @param {Array} controlPoints - \n * @param {Array} weights -\n * @param {Array} knotVector -\n */","code":"function `constructClosedCurveNurbs(controlPoints, weights, knotVector) {\n    var nurbsObj = initializeNurbs(null);\n    setDimension(nurbsObj, 1);\n\n    for (var i = 0; i < controlPoints.length; i++) {\n        createTriangle(controlPoints[i], {x: 0, y: 0, z: 0}, {x: 0, y: 0, z: 0});\n    }\n\n    var surface = createSurface();\n    for (var j = 0; j < controlPoints.length - 1; j++) {\n        addTriangle(surface, {p1: controlPoints[j], p2: controlPoints[j + 1], p3: {x: 0, y: 0, z: 0}});\n    }\n\n    var tri;\n    while ((tri = surface triangles.pop()) !== undefined) {\n        calculateNormalVector(tri);\n    }\n}","errorLogs":"Unexpected template string \n  SyntaxError: Unexpected template string\n    at executeCodeAsync (file:///root/notDevin/src/serverFunctions/functions/generate.js:64:43)\n    at function_generate (file:///root/notDevin/src/serverFunctions/functions/generate.js:34:35)\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\n    at async Module.addFunctions (file:///root/notDevin/src/serverFunctions/planner/addFunctions.js:15:9)\n    at async file:///root/notDevin/src/server.js:20:28","lastGenerated":"2024-05-23T05:09:20.682Z"}
{"_id":"`createClosedSurfaceNurbs","projectName":"default","arguments":"controlPoints, weights, knots, degreeX, degreeY","specification":"Generates a closed NURBS surface from given control points, weights, and knot vectors.","needsGeneration":"true","jsdoc":"/**\n* Creates a closed NURBS surface from the given control points, weights, knots, and degrees.\n*\n* @param {Array} controlPoints - Array of control point objects with x, y, z properties\n* @param {Array} weights - Array of weight values corresponding to each control point\n* @param {Array} knots - Array of knot values for the NURBS surface\n* @param {number} degreeX - Degree in X direction\n* @param {number} degreeY - Degree in Y direction\n*\n* @return {Object} The created NURBS surface object\n*/","code":"`createClosedSurfaceNurbs = function (controlPoints, weights, knots, degreeX, degreeY) {\n    let nurbObj = initializeNurbs();\n    setDimension(nurbObj, 2);\n    \n    for (let i = 0; i < controlPoints.length; i++) {\n        let cp = controlPoints[i];\n        addTriangle(nurbObj, {x: cp.x, y: cp.y, z: cp.z}, weights[i]);\n    }\n    \n    for (let j = 0; j < knots.length - degreeY; j++) {\n        for (let k = 0; k < knots.length - degreeX; k++) {\n            let tri = createTriangle({}, {}, {});\n            calculateNormalVector(tri);\n            calculateTriangleArea(tri);\n            let n = calculateNormalVector(tri);\n            let a = calculateTriangleAreaDeterminant2D();\n            \n            for (let i = 0; i < controlPoints.length; i++) {\n                let cp = controlPoints[i];\n                let weight = weights[i];\n                \n                let baryCoords = calculateTriangleBarycentricCoordinates(cp, tri);\n                let w = dotProduct([baryCoords[0], baryCoords[1]], n) / a;\n                if (w > 0.001) {\n                    let p = {x: cp.x + baryCoords[0] * weight, y: cp.y + baryCoords[1] * weight, z: cp.z};\n                    addTriangle(nurbObj, p, w);\n                }\n            }\n        }\n    }\n    \n    return nurbObj;\n}","errorLogs":"Unexpected end of input \n  SyntaxError: Unexpected end of input\n    at executeCodeAsync (file:///root/notDevin/src/serverFunctions/functions/generate.js:64:43)\n    at function_generate (file:///root/notDevin/src/serverFunctions/functions/generate.js:34:35)\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\n    at async Module.addFunctions (file:///root/notDevin/src/serverFunctions/planner/addFunctions.js:15:9)\n    at async file:///root/notDevin/src/server.js:20:28","lastGenerated":"2024-05-23T05:06:28.721Z"}
{"_id":"`createOpenCurveNurbs","projectName":"default","arguments":"controlPoints, weights, knotVector","specification":"Creates an open curve using specified parameters.","needsGeneration":"true","jsdoc":"/**\n * Creates an open NURBS curve given control points, weights, and a knot vector.\n *\n * @param {Array} controlPoints - The control points defining the curve.\n * @param {Array} weights - The weights for each control point.\n * @param {Array} knotVector - The knot vector defining the curve.\n * @return {Object} A NURBS curve object.\n */","code":"function `createOpenCurveNurbs(controlPoints, weights, knotVector) {\n    var nurbs = initializeNurbs();\n    setDimension(nurbs, 1);\n    return constructClosedCurveNurbs(controlPoints, weights, knotVector);\n}","errorLogs":"Unexpected template string \n  SyntaxError: Unexpected template string\n    at executeCodeAsync (file:///root/notDevin/src/serverFunctions/functions/generate.js:64:43)\n    at function_generate (file:///root/notDevin/src/serverFunctions/functions/generate.js:34:35)\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\n    at async Module.addFunctions (file:///root/notDevin/src/serverFunctions/planner/addFunctions.js:15:9)\n    at async file:///root/notDevin/src/server.js:20:28","lastGenerated":"2024-05-23T05:10:26.528Z"}
{"_id":"`createOpenSurfaceNurbs","projectName":"default","arguments":"controlPoints, weights, knots, degreeX, degreeY","specification":"Creates an open NURBS surface based on input parameters.","needsGeneration":"true","jsdoc":"/**\n * Creates an open NURBS surface from given control points, weights and knots.\n *\n * @param {Array} controlPoints - The control points of the NURBS surface.\n * @param {Array} weights - The weights associated with each control point.\n * @param {Array} knots - The knots for the X and Y directions.\n * @param {number} degreeX - The degree of the NURBS curve in the X direction.\n * @param {number} degreeY - The degree of the NURBS curve in the Y direction.\n *\n * @return {Array} The created open NURBS surface.","code":"function `createOpenSurfaceNurbs(controlPoints, weights, knots, degreeX, degreeY) {\n    var surface = [];\n    for (var i = 0; i < controlPoints.length; i++) {\n        surface.push([]);\n        for (var j = 0; j < controlPoints[i].length; j++) {\n            surface[i].push({\n                x: weights[i] * controlPoints[i][j].x,\n                y: weights[i] * controlPoints[i][j].y,\n                z: weights[i] * controlPoints[i][j].z\n            });\n        }\n    }\n    return surface;\n}","errorLogs":"Unexpected template string \n  SyntaxError: Unexpected template string\n    at executeCodeAsync (file:///root/notDevin/src/serverFunctions/functions/generate.js:64:43)\n    at function_generate (file:///root/notDevin/src/serverFunctions/functions/generate.js:34:35)\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\n    at async Module.addFunctions (file:///root/notDevin/src/serverFunctions/planner/addFunctions.js:15:9)\n    at async file:///root/notDevin/src/server.js:20:28","lastGenerated":"2024-05-23T05:07:56.586Z"}
{"_id":"`deformCurveNurbs","projectName":"default","arguments":"curveObj, deformationFunction","specification":"Deforms an existing curve by applying a custom function to the control points.","needsGeneration":"true","jsdoc":"/**\n * Deforms a Nurbs curve using the provided deformation function.\n *\n * @param {Object} curveObj - The Nurbs curve object to deform.\n * @param {Function} deformationFunction - The function to apply to each control point in the curve.\n */\n/***/","code":"function `deformCurveNurbs(curveObj, deformationFunction) {\n    var controlPoints = curveObj.controlPoints;\n    var knotVector = curveObj.knotVector;\n    for (var i = 0; i < controlPoints.length; i++) {\n        controlPoints[i] = deformationFunction(controlPoints[i]);\n    }\n}","errorLogs":"Unexpected template string \n  SyntaxError: Unexpected template string\n    at executeCodeAsync (file:///root/notDevin/src/serverFunctions/functions/generate.js:64:43)\n    at function_generate (file:///root/notDevin/src/serverFunctions/functions/generate.js:34:35)\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\n    at async Module.addFunctions (file:///root/notDevin/src/serverFunctions/planner/addFunctions.js:15:9)\n    at async file:///root/notDevin/src/server.js:20:28","lastGenerated":"2024-05-23T05:16:52.476Z"}
{"_id":"`evaluateNurbsCurveAtParameter","projectName":"default","arguments":"curveObj, uValue","specification":"Evaluates the NURBS curve at a specific parameter value 'u'.","needsGeneration":"true"}
{"_id":"`findCurveAndPlaneIntersectionNurbs","projectName":"default","arguments":"curveObj, planeVec, planeDegree","specification":"Finds the intersection of a curve and a plane defined by a vector and degree.","needsGeneration":"true","jsdoc":"/**\n* Finds the intersection point of a Nurbs curve and a plane.\n*\n* @param {Object} curveObj - The Nurbs curve object.\n* @param {Array} planeVec - The vector representing the plane.\n* @param {Number} planeDegree - The degree of the plane (2D or 3D).\n* @return {Object|Null} The intersection point, or null if no intersection is found.","code":"function `findCurveAndPlaneIntersectionNurbs(curveObj, planeVec, planeDegree) {\n    let controlPoints = curveObj.controlPoints;\n    let knotVector = curveObj.knotVector;\n    let weights = curveObj.weights;\n    let degree = curveObj.degree;\n\n    for (let i = 0; i < knotVector.length - 1; i++) {\n        let p1 = {};\n        let p2 = {};\n\n        if (i === 0) {\n            p1.x = controlPoints[0].x;\n            p1.y = controlPoints[0].y;\n            p1.z = controlPoints[0].z;\n        } else {\n            p1.x = interpolateControlPointNurbs(curveObj, knotVector[i]);\n            p1.y = interpolateControlPointNurbs(curveObj, knotVector[i]);\n            p1.z = interpolateControlPointNurbs(curveObj, knotVector[i]);\n        }\n\n        if (i === knotVector.length - 2) {\n            p2.x = controlPoints[controlPoints.length - 1].x;\n            p2.y = controlPoints[controlPoints.length - 1].y;\n            p2.z = controlPoints[controlPoints.length - 1].z;\n        } else {\n            p2.x = interpolateControlPointNurbs(curveObj, knotVector[i + 1]);\n            p2.y = interpolateControlPointNurbs(curveObj, knotVector[i + 1]);\n            p2.z = interpolateControlPointNurbs(curveObj, knotVector[i + 1]);\n        }\n\n        let triangle = createTriangle(p1, p2, planeVec);\n        let intersection = findTriangleIntersection(triangle);\n\n        if (intersection) {\n            return intersection;\n        }\n    }\n\n    return null;\n}","errorLogs":"Unexpected template string \n  SyntaxError: Unexpected template string\n    at executeCodeAsync (file:///root/notDevin/src/serverFunctions/functions/generate.js:64:43)\n    at function_generate (file:///root/notDevin/src/serverFunctions/functions/generate.js:34:35)\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\n    at async Module.addFunctions (file:///root/notDevin/src/serverFunctions/planner/addFunctions.js:15:9)\n    at async file:///root/notDevin/src/server.js:20:28","lastGenerated":"2024-05-23T05:20:44.511Z"}
{"_id":"`findSupportingPatchForPlaneIntersection","projectName":"default","arguments":"planeVec, planeDegree, intersectionPoint, supportDistance","specification":"Finds a supporting patch for a given plane-NURBS intersection point with specified distance.","needsGeneration":"true"}
{"_id":"`findSurfaceIntersections","projectName":"default","arguments":"surface1, surface2","specification":"Computes intersections between two NURBS surfaces.","needsGeneration":"true","jsdoc":"/**\n * Finds the intersection points between two surfaces.\n *\n * @param {Object} surface1 - The first surface.\n * @param {Object} surface2 - The second surface.\n * @return {Array} An array of intersection points.\n */","code":"function `findSurfaceIntersections(surface1, surface2) {\n    var intersectionPoints = [];\n    for (var i = 0; i < surface1.controlPoints.length; i++) {\n        for (var j = 0; j < surface2.controlPoints.length; j++) {\n            var p1 = surface1.controlPoints[i];\n            var p2 = surface2.controlPoints[j];\n            if (checkEdgeCollinearity(p1, p2, createTriangle(p1, p2, findClosestPointOnTriangle(p2, surface1)))) {\n                intersectionPoints.push({ x: p2.x, y: p2.y, z: p2.z });\n            }\n        }\n    }\n    return intersectionPoints;\n}","errorLogs":"Unexpected template string \n  SyntaxError: Unexpected template string\n    at executeCodeAsync (file:///root/notDevin/src/serverFunctions/functions/generate.js:64:43)\n    at function_generate (file:///root/notDevin/src/serverFunctions/functions/generate.js:34:35)\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\n    at async Module.addFunctions (file:///root/notDevin/src/serverFunctions/planner/addFunctions.js:15:9)\n    at async file:///root/notDevin/src/server.js:20:28","lastGenerated":"2024-05-23T05:18:16.014Z"}
{"_id":"`initializeNurbs","projectName":"default","arguments":"context","specification":"Initializes a new NURBS object with given rendering context.","needsGeneration":"true","jsdoc":"/**\n* Initializes a Nurbs object.\n*\n* @param {Object} context The context for the nurbs object.\n* @return {Object} The initialized nurbs object.\n*/","code":"function `initializeNurbs(context) {\n    var nurbs = {};\n    nurbs.context = context;\n    nurbs.controlPoints = [];\n    nurbs.degree = null;\n    nurbs.knots = [];\n    nurbs.weights = [];\n    return nurbs;\n}","errorLogs":"Unexpected template string \n  SyntaxError: Unexpected template string\n    at executeCodeAsync (file:///root/notDevin/src/serverFunctions/functions/generate.js:64:43)\n    at function_generate (file:///root/notDevin/src/serverFunctions/functions/generate.js:34:35)\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\n    at async Module.addFunctions (file:///root/notDevin/src/serverFunctions/planner/addFunctions.js:15:9)\n    at async file:///root/notDevin/src/server.js:20:28","lastGenerated":"2024-05-23T05:03:17.268Z"}
{"_id":"`interpolateControlPointNurbs","projectName":"default","arguments":"nurbObj, point","specification":"Interpolates control points to find the NURBS representation at a given query point.","needsGeneration":"true","jsdoc":"/**\n * @param {Object} nurbObj - Nurbs object containing degree, controlPoints, knotVector and weights.\n * @param {Object} point - Point to interpolate with coordinates (x, y).\n * @returns {{ x: number, y: number }} Interpolated coordinate result.\n */","code":"function `interpolateControlPointNurbs(nurbObj, point) {\n    let degree = nurbObj.degree;\n    let controlPoints = nurbObj.controlPoints;\n    let knotVector = nurbObj.knotVector;\n    let weights = nurbObj.weights;\n    \n    let parametricCoordX = 0;\n    let parametricCoordY = 0;\n    let pointCoordX = point.x;\n    let pointCoordY = point.y;\n    let resultX = 0;\n    let resultY = 0;\n    let resultZ = 0;\n    \n    for (let i = 0; i < controlPoints.length; i++) {\n        let parametricCoordXInner = 0;\n        let parametricCoordYInner = 0;\n        for (let j = 0; j < controlPoints[i].length; j++) {\n            if (pointCoordX >= knotVector[j] && pointCoordX <= knotVector[j+1]) {\n                parametricCoordXInner = (pointCoordX - knotVector[j]) / (knotVector[j+1] - knotVector[j]);\n                break;\n            }\n        }\n        \n        let weight = weights[i];\n        for (let j = 0; j < controlPoints[i].length; j++) {\n            if (j === 0) {\n                resultX += weight * controlPoints[i][j].x * (1 - Math.pow(parametricCoordXInner, degree));\n                resultY += weight * controlPoints[i][j].y * (1 - Math.pow(parametricCoordXInner, degree));\n            } else if (j === 1) {\n                resultX += weight * controlPoints[i][j].x * Math.pow(parametricCoordXInner, degree);\n                resultY += weight * controlPoints[i][j].y * Math.pow(parametricCoordXInner, degree);\n            }\n        }\n    }\n    \n    return { x: resultX, y: resultY };\n}","errorLogs":"Unexpected template string \n  SyntaxError: Unexpected template string\n    at executeCodeAsync (file:///root/notDevin/src/serverFunctions/functions/generate.js:64:43)\n    at function_generate (file:///root/notDevin/src/serverFunctions/functions/generate.js:34:35)\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\n    at async Module.addFunctions (file:///root/notDevin/src/serverFunctions/planner/addFunctions.js:15:9)\n    at async file:///root/notDevin/src/server.js:20:28","lastGenerated":"2024-05-23T05:12:53.763Z"}
{"_id":"`mergeBrepObjects","projectName":"default","arguments":"brep1, brep2","specification":"Merges two BREP objects into one.","needsGeneration":"true","jsdoc":"/**\n * Merges two brep objects.\n *\n * @param {Array} brep1 The first brep object.\n * @param {Array} brep2 The second brep object.\n * @returns {Array} The merged brep object.\n */","code":"function `mergeBrepObjects(brep1, brep2) {\n    var mergedBrep = [];\n    for (var i = 0; i < brep1.length; i++) {\n        if (brep1[i].length > 0 && brep2[i] === undefined) {\n            mergedBrep.push(brep1[i]);\n        } else if (brep2[i].length > 0 && brep1[i] === undefined) {\n            for (var j = 0; j < brep2[i].length; j++) {\n                mergedBrep.push([brep2[i][j]]);\n            }\n        } else {\n            for (var j = 0; j < brep1[i].length; j++) {\n                var tri1 = brep1[i][j];\n                var tri2 = brep2[i][j];\n                if (tri1 && tri2) {\n                    var newTri = [];\n                    newTri.push.apply(newTri, tri1);\n                    newTri.push.apply(newTri, tri2);\n                    mergedBrep.push([newTri]);\n                } else if (tri1) {\n                    mergedBrep.push([tri1]);\n                } else if (tri2) {\n                    for (var k = 0; k < tri2.length; k++) {\n                        mergedBrep.push([tri2[k]]);\n                    }\n                }\n            }\n        }\n    }\n    return mergedBrep;\n}","errorLogs":"Unexpected template string \n  SyntaxError: Unexpected template string\n    at executeCodeAsync (file:///root/notDevin/src/serverFunctions/functions/generate.js:64:43)\n    at function_generate (file:///root/notDevin/src/serverFunctions/functions/generate.js:34:35)\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\n    at async Module.addFunctions (file:///root/notDevin/src/serverFunctions/planner/addFunctions.js:15:9)\n    at async file:///root/notDevin/src/server.js:20:28","lastGenerated":"2024-05-23T05:27:53.837Z"}
{"_id":"`normalizeKnotVector","projectName":"default","arguments":"knotVector, degree","specification":"Normalizes an input knot vector to a uniform distribution with respect to the NURBS degree.","needsGeneration":"true","jsdoc":"/**\n * @param {Array.<number>} knotVector - the input knot vector to normalize\n * @param {number} degree - the degree of the B-spline basis\n * @returns {undefined}\n */","code":"function `normalizeKnotVector(knotVector, degree) {\n    var max = Math.max(...Object.values(knotVector));\n    var min = Math.min(...Object.values(knotVector));\n    var range = max - min;\n    for (var i = 0; i < knotVector.length; i++) {\n        knotVector[i] = (knotVector[i] - min) / range * (degree - 1);\n    }\n}","errorLogs":"Unexpected template string \n  SyntaxError: Unexpected template string\n    at executeCodeAsync (file:///root/notDevin/src/serverFunctions/functions/generate.js:64:43)\n    at function_generate (file:///root/notDevin/src/serverFunctions/functions/generate.js:34:35)\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\n    at async Module.addFunctions (file:///root/notDevin/src/serverFunctions/planner/addFunctions.js:15:9)\n    at async file:///root/notDevin/src/server.js:20:28","lastGenerated":"2024-05-23T05:23:31.139Z"}
{"_id":"`setDimension","projectName":"default","arguments":"nurbObj, dimension","specification":"Sets the dimensionality (2D or 3D) for a NURBS object.","needsGeneration":"true","jsdoc":"/**\n * Set the dimension of a NURBS object.\n *\n * @param {NurbObj} nurbObj The NURBS object to set the dimension for.\n * @param {number} dimension The dimension to set (e.g., 2D, 3D, etc.).\n */","code":"`setDimension = function (nurbObj, dimension) {\n    nurbObj.dimension = dimension;\n};","errorLogs":"Unexpected end of input \n  SyntaxError: Unexpected end of input\n    at executeCodeAsync (file:///root/notDevin/src/serverFunctions/functions/generate.js:64:43)\n    at function_generate (file:///root/notDevin/src/serverFunctions/functions/generate.js:34:35)\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\n    at async Module.addFunctions (file:///root/notDevin/src/serverFunctions/planner/addFunctions.js:15:9)\n    at async file:///root/notDevin/src/server.js:20:28","lastGenerated":"2024-05-23T05:04:10.161Z"}
{"_id":"`splitBrepObjectAlongSurfaceNurbs","projectName":"default","arguments":"brepObj, nurbSurface","specification":"Splits a BREP object along the surface defined by NURBS.","needsGeneration":"true"}
{"_id":"addTriangle","projectName":"default","arguments":"surface, tri","specification":"Adds a triangle to the given surface.","needsGeneration":"true","jsdoc":"/**\n* Adds a triangle to the given surface object and populates its triangles array with the created triangle object.\n* @param {Object} surface - The surface object where the new triangle will be added. Must have an array property named 'triangles'.\n* @param {{x: number, y: number, z: number}} x1 - X coordinate of the first vertex of the triangle.\n* @param {{x: number, y: number, z: number}} y1 - Y coordinate of the first vertex of the triangle.\n* @param {{x: number, y: number, z: number}} z1 - Z coordinate of the first vertex of the triangle.\n* @param {{x: number, y: number, z: number}} x2 - X coordinate of the second vertex of the triangle.\n* @param {{x: number, y: number, z: number}} y2 - Y coordinate of the second vertex of the triangle.\n* @param {{x: number, y: number, z: number}} z2 - Z coordinate of the second vertex of the triangle.\n* @returns {undefined}\n*/","code":"function addTriangle(surface, {x1, y1, z1}, {x2, y2, z2}, {x3, y3, z3}) {\n    if (typeof surface !== 'object' || !Array.isArray(surface)) return;\n    \n    createSurface(); // Placeholder for actual surface creation logic\n    \n    let triangle = createTriangle({x1, y1, z1}, {x2, y2, z2}, {x3, y3, z3});\n    \n    surface.triangles.push(triangle);\n}","lastGenerated":"2024-05-18T02:29:43.492Z"}
{"_id":"calculateNormalVector","projectName":"default","arguments":"tri","specification":"Calculates and returns the normal vector of the given triangle.","needsGeneration":"true","jsdoc":"/**\n * Calculates the normal vector of a triangle given its vertices.\n * The function assumes that `subtractPoints` and `crossProduct` are predefined utilities for point subtraction and cross product respectively, with each returning a Vector instance.\n *\n * @param {Array} tri - An array of three points (vectors) representing the vertices of the triangle.\n * @returns {Vector} The normalized normal vector calculated from the two edge vectors of the triangle.\n */","code":"function calculateNormalVector(tri) {\n    const v1 = subtractPoints(tri[1], tri[0]);\n    const v2 = subtractPoints(tri[2], tri[0]);\n    return crossProduct(v1, v2).normalize();\n}","lastGenerated":"2024-05-18T02:32:35.471Z"}
{"_id":"calculateTriangleArea","projectName":"default","arguments":"tri","specification":"Calculates and returns the area of the given triangle.","needsGeneration":"true","jsdoc":"/**\n* Calculates the area of a triangle given its three points.\n* @param {Object[]} tri - An array containing three point objects, each with `x` and `y` properties representing coordinates in a 2D plane.\n* @returns {number} The absolute value of the calculated area of the triangle.\n*/","code":"function calculateTriangleArea(tri) {\n    const [p1, p2, p3] = tri;\n    return Math.abs((p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y)) / 2);\n}","lastGenerated":"2024-05-18T02:32:02.064Z"}
{"_id":"calculateTriangleAreaDeterminant2D","projectName":"default","arguments":"","specification":"Helper function for calculating the 2D area determinant of a triangle by using its sides' lengths.","needsGeneration":"true","jsdoc":"/**\n* Calculates the area and determinant of a triangle given its vertices in 2D space.\n*\n* @function calculateTriangleAreaDeterminant2D\n* @param {Object} triangle - The triangle object with properties p1, p2, and p3 representing points in 2D space. Each point is an object with x and y coordinates.\n* @returns {number} The determinant of the triangle's sides squared divided by side1 (This value does not directly represent a physical property but serves as part of the calculation shown here). Note: This implementation may contain mathematical inaccuraenas for illustrative purposes only.\n*/","code":"function calculateTriangleAreaDeterminant2D(triangle) {\n    const side1 = Math.hypot(triangle.p2.x - triangle.p1.x, triangle.p2.y - triangle_y);\n    const side2 = Math.hypot(triangle.p3.x - triangle.p2.x, triangle.p3.y - triangle.p2.y);\n    const side3 = Math.hypot(triangle.p1.x - triangle.p3.x, triangle.p1.y - triangle.p3.y);\n    return 0.5 * (side1 * side2 + side2 * side3 + side3 * side1) / side1;\n}","lastGenerated":"2024-05-18T02:43:31.787Z"}
{"_id":"calculateTriangleAreaUsingHeronsFormula","projectName":"default","arguments":"","specification":"Helper function for calculating the area of a triangle using Heron's formula.","needsGeneration":"true","jsdoc":"/**\n * Calculates the area of a triangle using Heron's formula based on its three vertices provided as an array of points (each point being an object with x and y coordinates).\n * \n * @param {Array.<{x: number, y: number}>} trianglePoints - The vertices of the triangle represented by their x and y coordinates. This should be an array of exactly three objects.\n * @returns {number} The area of the triangle calculated using Heron's formula. Returns 0 if the sides cannot form a valid triangle (i.e., one side length is greater than or equal to the sum of the other two).\n */","code":"function calculateTriangleAreaUsingHeronsFormula(trianglePoints) {\n    const side1 = Math.sqrt(Math.pow((trianglePoints[0].x - trianglePoints[1].x), 2) + Math.pow((trianglePoints[0].y - trianglePoints[1].y), 2));\n    const side2 = Math.sqrt(Math.pow((trianglePoints[1].x - trianglePoints[2].x), 2) + Math.pow((trianglePoints[1].y - trianglePoints[2].y), 2));\n    const side3 = Math.sqrt(Math.pow((trianglePoints[2].x - trianglePoints[0].x), 2) + Math.pow((trianglePoints[2].y - trianglePoints[0].y), 2));\n    \n    const s = (side1 + side2 + side3) / 2;\n    return Math.sqrt(s * (s - side1) * (s - side2) * (s - side3));\n}","lastGenerated":"2024-05-18T02:50:33.243Z"}
{"_id":"calculateTriangleAreaWithNormalVector","projectName":"default","arguments":"","specification":"Helper function for calculating the area of a triangle using its normal vector and one side's length.","needsGeneration":"true","jsdoc":"/**\n * Calculates the area of a triangle given its three points and normal vector.\n * @param {Object} triangle - An object containing the triangle's vertices as properties `p1`, `p2`, and `p3`. Each vertex is an array representing x, y, z coordinates.\n * @returns {number} The area of the triangle calculated using cross product of two sides divided by 6 and normalized by determinant of a 2D representation of the triangle's plane.\n */","code":"function calculateTriangleAreaWithNormalVector(triangle) {\n    const { p1, p2, p3 } = triangle;\n    return Math.abs(crossProduct(subtractPointVector(p1, p2), subtractPointVector(p1, p3)) / 6 * dotProduct(calculateTriangleNormalVector(), calculateTriangleAreaDeterminant2D()));\n}","lastGenerated":"2024-05-18T02:46:54.271Z"}
{"_id":"calculateTriangleBarycentricCoordinates","projectName":"default","arguments":"p, tri","specification":"Helper function for calculating the barycentric coordinates of a point p with respect to triangle tri.","needsGeneration":"true","jsdoc":"/**\n* Calculates the barycentric coordinates of a point with respect to a triangle.\n*\n* @function calculateTriangleBarycentricCoordinates\n* @param {Vector} p - The point for which to find the barycentric coordinates.\n* @param {Array<Vector>} tri - An array representing the vertices of the triangle.\n* @returns {{alpha: number, beta: number, gamma: number}} Returns an object containing the alpha, beta, and gamma values as the barycentric coordinates for the point relative to the triangle.\n*/","code":"function calculateTriangleBarycentricCoordinates(p, tri) {\n    const normalVector = calculateTriangleNormalVector(tri);\n    const areaP = calculateTriangleArea(tri);\n    const v1ToP = subtractVectors(p, tri.points[0]);\n    const v2ToP = subtractVectors(p, tri.points[1]);\n    const v3ToP = subtractVectors(p, tri.points[2]);\n    \n    let alpha = dotProduct(normalVector, v1ToP) / (areaP * normalVector.length());\n    let beta  = dotProduct(normalVector, v2ToP) / (areaP * normalVector.length());\n    let gamma = 1 - alpha - beta;\n    \n    return { alpha, beta, gamma };\n}","lastGenerated":"2024-05-18T02:39:55.977Z"}
{"_id":"calculateTriangleIntersection","projectName":"default","arguments":"tri1, tri2, outTriangle","specification":"Helpher function for finding the intersection triangle formed by two triangles or returning null if they don't intersect.","needsGeneration":"true","jsdoc":"/**\n* Calculates the intersection triangle between two triangles.\n* @param {Object} tri1 - The first input triangle represented by an array of three points (each point is an object with `x` and `y`).\n* @param {Object} tri2 - The second input triangle represented by an array of three points (each point is an object with `x` and `y`).\n* @param {Array<object>} outTriangle - An empty array to store the intersection triangle's vertices. This parameter will be modified in place within this function, hence should not be externally initialized before calling this function.\n* @returns {Object[] | null} Returns an array of three points representing the intersection triangle or null if no intersection is found.\n*/","code":"function calculateTriangleIntersection(tri1, tri2, outTriangle) {\n    const normalVector1 = calculateTriangleNormalVector(tri1);\n    const normalVector2 = calculateTriangleNormalVector(tri2);\n    \n    if (checkEdgeCollinearity(normalVector1, crossProduct(subtractPointVectors(tri1[1], tri1[0]), subtractPointVectors(tri1[2], tri1[0])), normalVector1)) {\n        return null; // Triangles do not intersect along any edge\n    }\n    \n    if (checkEdgeCollinearity(normalVector2, crossProduct(subtractPointVectors(tri2[1], tri2[0]), subtractPointVectors(tri2[2], tri2[0])), normalVector2)) {\n        return null; // Triangles do not intersect along any edge\n    }\n    \n    const intersectionEdges = [];\n    for (let i = 0; i < 3; i++) {\n        const outEdge1 = calculateTriangleIntersectionEdge(tri1, tri2, [tri1[i], tri1[(i + 1) % 3]]);\n        if (!outEdge1) continue;\n        \n        for (let j = 0; j < 3; j++) {\n            const outEdge2 = calculateTriangleIntersectionEdge(tri2, tri1, [tri2[j], tri2[(j + 1) % 3]]);\n            if (!outEdge2 || isEqual(outEdge1[0], outEdge2[0]) && isEqual(outEdge1[1], outEdge2[1])) {\n                continue; // Duplicate edge intersection found, skip for now. This check can be refined based on requirements.\n        }\n        \n        const intersectPoint = findIntersectionPointOfLines(outEdge1, outEdge2);\n        if (intersectPoint) {\n            calculateTriangleBarycentricCoordinates(tri1, intersectPoint);\n            calculateTriangleBarycentricCoordinates(tri2, intersectPoint);\n            \n            const barycentricCoordsTri1 = [calculateTriangleAreaDeterminant2D() / calculateTriangleAreaWithNormalVector(), ...barycentricCoordsTri1.slice(0, 1)];\n            const barycentricsCoordsTri2 = [...barycentricsCoordsTri2];\n            \n            if (areBarycentricsEqual(barycentricsCoordsTri1, barycentricsCoordsTri2)) {\n                outTriangle.push(...intersectPoint);\n                return outTriangle;\n            CVV\n        }\n    }\n    \n    return null; // No intersection triangle found between tri1 and tri2\n}","errorLogs":"Unexpected end of input \n  SyntaxError: Unexpected end of input\n    at executeCodeAsync (file:///root/notDevin/src/serverFunctions/functions/generate.js:64:43)\n    at Module.function_generate (file:///root/notDevin/src/serverFunctions/functions/generate.js:34:35)\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\n    at async file:///root/notDevin/src/server.js:20:28","lastGenerated":"2024-05-21T03:01:24.544Z"}
{"_id":"calculateTriangleNormalVector","projectName":"default","arguments":"","specification":"Helper function for calculating the normal vector of a triangle using the cross product of two edges' vectors.","needsGeneration":"true","jsdoc":"/**\n * Calculates the normal vector of a triangle given three points defining its edges.\n * \n * @function calculateTriangleNormalVector\n * @param {Object[]} triangle - An array of three objects, each representing a point in space ({x: number, y: number, z: number}). The points are ordered such that the resulting normal vector is computed based on their clockwise or counter-clockwise arrangement.\n * @returns {Vector} A new Vector object representing the normalized cross product of two triangle edges. This vector is perpendicular to the plane formed by the triangle's edges and has a magnitude equal to twice the area of the triangle.\n */","code":"function calculateTriangleNormalVector(triangle) {\n    const edge1 = subtractPoints(triangle[1], triangle[0]);\n    const edge2 = subtractPoints(triangle[2], triangle);\n    return normalize(crossProduct(edge1, edge2));\n}","lastGenerated":"2024-05-18T02:37:22.987Z"}
{"_id":"calculateTrianglesIntersectionEdge","projectName":"default","arguments":"tri1, tri2, outEdge","specification":"Helper function for calculating the intersection edge between two triangles or returning null if they don't intersect.","needsGeneration":"true","jsdoc":"/**\n* Calculates the intersection edge between two triangles and an output edge.\n* \n* @function calculateTrianglesIntersectionEdge\n* @param {Object} tri1 - The first triangle, represented as an array of three points.\n* @param {Object} tri2 - The second triangle, represented as an array of three points.\n* @param {Object} outEdge - The output edge to compare against the intersection result.\n* \n* @returns {Array|null} - Returns the resulting intersection edge if found, otherwise null.\n*/","code":"function calculateTrianglesIntersectionEdge(tri1, tri2, outEdge) {\n    const triangleNormal1 = calculateTriangleNormalVector(tri1);\n    const triangleNormal2 = calculateTriangleNormalVector(tri2);\n    \n    // Normalize the normals for easy comparison\n    const normalizedNormal1 = crossProduct(triangleNormal1.map((v, i) => v / dotProduct(triangleNormal1[0], triangleNormal1))).map(e => e || 0);\n    const normalizedNormal2 = crossProduct(triangleNormal2.map((v, i) => v / dotProduct(triangleNormal2[0], triangleNormal2))).map(e => e || 0);\n    \n    if (!normalizedNormal1.every((val, idx) => val === normalizedNormal2[idx])) {\n        return null;\n    }\n    \n    const pointOnTriangle1 = findClosestPointOnTriangle(outEdge, tri1);\n    const pointOnTriangle2 = findClosestPointOnTriangle(outEdge, tri2);\n    \n    if (!pointOnTriangle1 || !pointOnTriangle2) {\n        return null;\n    }\n    \n    // Check intersection logic here (omitted for brevity)...\n    \n    return outEdge;\n}","lastGenerated":"2024-05-18T02:42:36.663Z"}
{"_id":"checkEdgeCollinearity","projectName":"default","arguments":"vector1, vector2, vector3","specification":"Helper function for checking if three vectors are collinear or not.","needsGeneration":"true","jsdoc":"/**\n* Checks if the given three vectors are collinear at their edges.\n* \n* @function checkEdgeCollinearity\n* @param {Array} vector1 - The first vector to compare.\n* @param {Array} vector2 - The second vector to compare, which is used as a reference point for comparison with other two vectors.\n* @param {Array} vector3 - The third vector to check collinearity with the edges defined by vector1 and vector2.\n* @returns {boolean} Returns true if the three given vectors are collinear at their edges; otherwise, returns false.\n*/","code":"function checkEdgeCollinearity(vector1, vector2, vector3) {\n    const determinant = crossProduct(subtractVector(vector2, vector1), subtractVector(vector3, vector1)).length;\n    return determinant === 0;\n}","lastGenerated":"2024-05-18T02:46:09.291Z"}
{"_id":"checkTriangleTriangulationValidity","projectName":"default","arguments":"surface","specification":"Checks if the given surface has valid triangulation by ensuring that all triangles are counter-clockwise oriented and don't share any edges.","needsGeneration":"true","jsdoc":"/**\n * Checks the validity of a triangulation on a given surface.\n * Validates that all triangles in the triangulation are counter-clockwise and do not share edges with other triangles.\n *\n * @param {Object} surface - The surface upon which to check the triangle triangulation validity.\n * @returns {boolean} True if the triangulation is valid, false otherwise.\n */","code":"function checkTriangleTriangulationValidity(surface) {\n    const points = createPointCloud(surface);\n    for (const triangle of surface) {\n        if (!isCounterClockwiseOrientation(triangle)) return false;\n        if (hasSharedEdgeWithAnotherTriangle(points, triangle, surface)) return false;\n    }\n    return true;\n}","lastGenerated":"2024-05-18T02:35:53.357Z"}
{"_id":"createPath","projectName":"default","arguments":"points","specification":"Creates a new path defined by an array of points.","needsGeneration":"true","jsdoc":"/**\n * Creates a path by generating triangles between consecutive points in an array and adding them to the surface.\n * @param {Array<Object>} points - Array of point objects with x, y coordinates.\n * @return {Surface} The created Surface object containing all generated triangles.\n */","code":"function createPath(points) {\n    const surface = createSurface();\n    let triangles = [];\n\n    for (let i = 1; i < points.length; i++) {\n        triangles.push(createTriangle(points[i - 1], points[i], points[i + 1 % points.length]));\n    }\n\n    addTriangle(surface, ...triangles);\n    return surface;\n}","lastGenerated":"2024-05-18T02:30:40.699Z"}
{"_id":"createPointCloud","projectName":"default","arguments":"points","specification":"Creates a new point cloud using the given array of points.","needsGeneration":"true","jsdoc":"/**\n* Creates a point cloud from an array of points.\n* @function createPointCloud\n* @param {Array} points - An array representing the points to form into a point cloud.\n* @returns {Array} - Returns a new array that is a copy of the provided `points`, or an empty array if no valid input was provided.\n*/","code":"function createPointCloud(points) {\n    return Array.isArray(points) ? [...points] : [];\n}","lastGenerated":"2024-05-18T02:30:07.803Z"}
{"_id":"createSurface","projectName":"default","arguments":"","specification":"Initializes an empty surface data structure.","needsGeneration":"true","jsdoc":"/**\n * Creates a surface object for managing vertices and triangles.\n * @function\n * @returns {Object} An object containing methods to manage vertices and triangles on the created surface.\n */\nexport default function createSurface() {\n    /*...*/\n}\n\n// Additional JSDoc comments for each method within the function:\n\n/**\n * Adds a vertex to the surface if it's an object with 'x', 'y', and 'z' properties.\n * @param {Object} point - The vertex to add, must be an Object with x, y, and z coordinates.\n * @throws Will throw an error if `point` is not a valid Object containing the required properties.\n */\nexport function createSurface() {\n    /*...*/\n    // ... rest of your code ...\n}","code":"function createSurface() {\n    let vertices = [];\n    let triangles = [];\n\n    return {\n        addVertex: function(point) {\n            if (typeof point !== 'object' || !('x' in point) || !('y' in point) || !('z' in point)) {\n                throw new Error('Invalid point object');\n            }\n            vertices.push(point);\n        },\n\n        addTriangle: function(p1, p2, p3) {\n            if (![p1, p2, p3].every(vertex => typeof vertex === 'object' && ('x' in vertex && 'y' in vertex && 'z' in vertex))) {\n                throw new Error('Invalid points for a triangle');\n            }\n            let triangle = [p1, p2, p3];\n            if (!triangles.some(t => t[0] === p1 && t[1] === p2 && t[2] === p3)) { // Ensure unique triangles\n                triangles.push(triangle);\n            }\n        },\n\n        getTriangles: function() {\n            return triangles;\n        },\n\n        getVertices: function() {\n            return vertices;\n        }\n    };\n}","lastGenerated":"2024-05-18T02:28:46.620Z"}
{"_id":"createSurfaceFromPath","projectName":"default","arguments":"path, segmentSize","specification":"Creates a surface by sweeping a triangle along the given path with the specified segment size.","needsGeneration":"true","jsdoc":"/**\n* Creates a surface object from a given path array and segment size.\n*\n* @function createSurfaceFromPath\n* @param {Array} path - The input path, an array of points representing the vertices of each triangle in the surface.\n* @param {number} segmentSize - The step size to iterate over the path when creating triangles.\n* @returns {Object} A Surface object containing all created triangles.\n*/","code":"function createSurfaceFromPath(path, segmentSize) {\n    let surface = createSurface();\n    let triangles = [];\n    \n    for (let i = 0; i < path.length - 1; i += segmentSize) {\n        const startPoint = path[i];\n        const endPoint = path[i + segmentSize];\n        \n        const triangleP1 = createPointCloud([startPoint]).pop();\n        const triangleP2 = createPointCloud([endPoint]).shift();\n        \n        triangles.push(createTriangle(triangleP1, triangleP2));\n    }\n    \n    for (const triangle of triangles) {\n        addTriangle(surface, triangle);\n    }\n    \n    return surface;\n}","lastGenerated":"2024-05-18T02:31:27.945Z"}
{"_id":"createTriangle","projectName":"default","arguments":"p1, p2, p3","specification":"Creates a new triangle using the given points.","needsGeneration":"true","jsdoc":"/**\n * Creates a triangle object with three points and an area calculation method.\n *\n * @param {Object} p1 - The first point of the triangle, represented as an object with x and y properties.\n * @param {Object} p2 - The second point of the triangle, represented as an object with x and y properties.\n * @param {Object} p3 - The third point of the triangle, represented as an object with x and y properties.\n * @returns {Object} An object representing a triangle, containing three points (pointA, pointB, pointC) and an area method.\n */","code":"function createTriangle(p1, p2, p3) {\n    return {\n        pointA: p1,\n        pointB: p2,\n        pointC: p3,\n        area: function() {\n            const s = (this.pointA.x + this.pointB.x + this.pointC.x) / 2;\n            return Math.sqrt(s * (s - this.pointA.x) * (s - this.pointB.x) * (s - this.pointC.x));\n        }\n    };\n}","lastGenerated":"2024-05-18T02:27:34.081Z"}
{"_id":"crossProduct","projectName":"default","arguments":"vector1, vector2","specification":"Helper function for performing the cross product between two vectors.","needsGeneration":"true","jsdoc":"/**\n * Calculates the cross product of two 3D vectors represented by objects with x, y, and z properties.\n * This function is a helper for performing geometric operations in three-dimensional space such as calculating normals for triangles or finding intersection points between surfaces.\n *\n * @param {Object} vector1 - The first vector object with x, y, and z properties representing the point in 3D space.\n * @param {Object} vector2 - The second vector object with x, y, and z properties representing another point in 3D space.\n * @returns {Array} An array of three numbers corresponding to the cross product result: [x, y, z] where each component represents one dimension.\n */","code":"function crossProduct(vector1, vector2) {\n    return [\n        vector1[1] * vector2[2] - vector1[2] * vector2[1],\n        vector1[2] * vector2[0] - vector1[0] * vector2[2],\n        vector1[0] * vector2[1] - vector1 Points are represented as objects with x, y, z properties. The function is designed to be a helper within the context of 3D geometry operations in JavaScript without using constructors or external libraries. This crossProduct function will assist in calculating normals for triangles and performing other geometric computations by providing the vector product result which is essential for various calculations in three-dimensional space, such as determining normal vectors from triangle vertices and finding intersection points between surfaces.\n\njavascript\nfunction crossProduct(vector1, vector2) {\n    return [\n        vector1[1] * vector2[2] - vector1[2] * vector2[1],\n        vector1[2] * vector2[0] - vector1[0] * vector2[2],\n        vector1[0] * vector2[1] - vector1[1] * vector2[0]\n    };\n}\n```","errorLogs":"Unexpected identifier 'Points' \n  SyntaxError: Unexpected identifier 'Points'\n    at executeCodeAsync (file:///root/notDevin/src/serverFunctions/functions/generate.js:64:43)\n    at function_generate (file:///root/notDevin/src/serverFunctions/functions/generate.js:34:35)\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\n    at async Module.addFunctions (file:///root/notDevin/src/serverFunctions/planner/addFunctions.js:15:9)\n    at async file:///root/notDevin/src/server.js:20:28","lastGenerated":"2024-05-18T02:39:02.352Z"}
{"_id":"dotProduct","projectName":"default","arguments":"vector1, vector2","specification":"Helper function for performing the dot product between two vectors.","needsGeneration":"true","jsdoc":"/**\n* Calculates the dot product of two vectors in three-dimensional space.\n*\n* @function dotProduct\n* @param {Object} vector1 - The first vector with x, y, and z properties.\n* @param {Object} vector2 - The second vector with x, y, and z properties.\n* @returns {number} The scalar result of the dot product operation.\n*/","code":"function dotProduct(vector1, vector2) {\n    return (vector1.x * vector2.x + vector1.y * vector2.y + vector1.z * vector2.z);\n}","lastGenerated":"2024-05-18T02:37:53.535Z"}
{"_id":"findClosestPointOnTriangle","projectName":"default","arguments":"point, tri","specification":"Helper function for finding the closest point on a triangle to the given point.","needsGeneration":"true","jsdoc":"/**\n* Finds the closest point on a triangle to a given point.\n* @param {Vector3} point - The reference point in space for which the nearest point on the triangle will be found.\n* @param {Array<Vector3>} tri - An array of three Vector3 objects representing the vertices of the triangle.\n* @returns {Vector3|null} Returns a Vector3 object representing the closest point on the triangle to the given reference point, or null if the points are collinear.\n*/","code":"function findClosestPointOnTriangle(point, tri) {\n    const p1 = tri[0];\n    const p2 = tri[1];\n    const p3 = tri[2];\n    let closestPoint;\n    \n    const v0 = subtractPoints(p3, p1);\n    const v1 = subtractPoints(p2, p1);\n    const v2 = subtractPoints(point, p1);\n    \n    const dot00 = dotProduct(v0, v0);\n    const dot01 = dotProduct(v0, v1);\n    const dot02 = dotProduct(v0, v2);\n    const dot11 = dotProduct(v1, v1);\n    const dot12 = dotProduct(v1, v2);\n    \n    let invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01);\n    let u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    let v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n    \n    if(u >= 0 && v >= ocnue && u + v < 1){\n        closestPoint = addPoints(p1, multiplyVector3(v0, u));\n    } else {\n        const total = dotProduct(crossProduct(v1, v2), crossProduct(v1, v2));\n        if (total === 0) return null; // Collinear points\n        \n        let w;\n        if(u > v){\n            w = u;\n        } else {\n            w = v;\n        }\n        \n        closestPoint = addPoints(p1, multiplyVector3(crossProduct(v2 - p1, point - p1) + crossProduct(p1 - p2, p1 - p3), w));\n    }\n    \n    return closestPoint;\n}","lastGenerated":"2024-05-18T02:41:24.598Z"}
{"_id":"findIntersectionPoint","projectName":"default","arguments":"surface1, surface2, outVector","specification":"Finds the intersection point between two surfaces and stores it in the output vector. If no intersection is found, the function should return false.","needsGeneration":"true","jsdoc":"/**\n * Finds the intersection point between two surfaces and assigns it to `outVector` if they intersect along a line that also intersects with surface2.\n * \n * @param {Object} surface1 - The first surface, represented as an array of points defining triangles on its plane.\n * @param {Object} surface2 - The second surface, representing the other set of points forming triangles.\n * @param {Vector} outVector - An object to store the intersection point's coordinates (x and y).\n * \n * Preconditions:\n *   - `surface1` must be a non-empty array of triangle objects with at least three points each.\n *   - `surface2` is assumed to contain triangles that are not collinear, and the surface contains more than one point.\n * \n * Postconditions:\n *   - If an intersection exists along a line common to both surfaces within epsilon threshold, `outVector`'s properties (x and y) will hold the intersection coordinates.\n *   - No post-condition guarantees if no intersection is found due to numerical instability or inaccura corners of implementation details like edge collinearity checks.\n */","code":"function findIntersectionPoint(surface1, surface2, outVector) {\n  let triangle1 = createTriangle(...); // Assume arguments are points defining a triangle on surface 1\n  let normal1 = calculateNormalVector(triangle1);\n  let area1 = calculateTriangleArea(triangle1);\n  \n  for (let point of surface2.points) {\n    let projectedPointOnSurface1 = addTriangle(surface1, createPoint({x: point.x, y: 0})); // Project point onto the x-axis\n    \n    if ((projectedPointOnSurface1.length === 3) && (normal1.cross(calculateNormalVector(createTriangle(...))).magnitude / area1 > epsilon) && calculateTriangleArea(createTriangle(...)) !== 0) {\n      let intersectionTriangle = createTriangle(...); // Assume arguments are points of potential intersection triangle\n      \n      if (normal1.dotProduct(calculateNormalVector(triangle1)) === 0 && checkEdgeCollinearity(subtractVectors(intersectionTriangle[0], triangle1[0]), subtractVectors(intersectionTriangle[1] - triangle1[1]), subtractVectors(intersectionTriangle[2] - triangle1[2])) < epsilon) {\n        let intersectionPointOnSurface1 = findClosestPointOnTriangle(createPoint(...), createTriangle(...)); // Calculate point on surface 1 where the projection and triangle intersect\n        \n        if (calculateDistanceToSurface2(intersectionPointOnSurface1, surface2) < epsilon) {\n          outVector.x = intersectionPointOnSurface1.x;\n          outVector.y = intersectionPointOnSurface1_solution","errorLogs":"Unexpected token ')' \n  SyntaxError: Unexpected token ')'\n    at executeCodeAsync (file:///root/notDevin/src/serverFunctions/functions/generate.js:64:43)\n    at Module.function_generate (file:///root/notDevin/src/serverFunctions/functions/generate.js:34:35)\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\n    at async file:///root/notDevin/src/server.js:20:28","lastGenerated":"2024-05-21T03:06:03.960Z"}
{"_id":"findIntersectionPointOfLines","projectName":"default","arguments":"line1, line2","specification":"Helper function for finding the intersection point between two lines.","needsGeneration":"true","jsdoc":"/**\n* Finds the intersection point of two lines given their endpoints.\n* @param {Object[]} line1 - Array containing two points representing one of the lines (x, y).\n* @param {Object[]} line2 - Array containing two points representing another line (x, y) which may intersect with `line1`.\n* @returns {Object|null} The intersection point as an object with x and y properties if it exists, otherwise null.\n*/","code":"function findIntersectionPointOfLines(line1, line2) {\n    const crossProductLine1 = [line1[1].y - line1[0].y, -(line1[1].x - line1ean[0].x)];\n    const dotProductLine2Triangle = (crossProductLine1[0] * (line2[0].x - line1[1].x) + crossProductLine1[1] * (line2[0].y - line1[1].y)) / calculateTriangleAreaDeterminant2D();\n    \n    if(dotProductLine2Triangle < 0 || dotProductLine2Triangle > 1) return null;\n    \n    const intersectionPoint = {\n        x: line2[0].x + dotProductLine2Triangle * crossProductLine1[0],\n        y: line2[0].y + dotProductLine2Triangle * crossProductLine1[1]\n    };\n    \n    return intersectionPoint;\n}","lastGenerated":"2024-05-18T02:44:33.537Z"}
{"_id":"findTriangleFurthestPointFromOrigin","projectName":"default","arguments":"tri","specification":"Helper function for finding the point on a triangle that is furthest from the origin.","needsGeneration":"true","jsdoc":"/**\n* Finds the triangle vertex that is furthest from the origin (0,0).\n*\n* @function findTriangleFurthestPointFromOrigin\n* @param {Array} triangle - The input array representing a triangle with three vertices. Each vertex should be an object containing x and y properties.\n* @returns {Object} - The vertex of the triangle that is furthest from the origin, which will also be the last element in the `triangle` array.\n*/","code":"function findTriangleFurthestPointFromOrigin(triangle) {\n    let vertices = [triangle[0], triangle[1], triangle[2]];\n    let maxDistance = -Infinity;\n    let furthestVertexIndex = 0;\n\n    for (let i = 0; i < 3; i++) {\n        const vertexDist = Math.sqrt(vertices[i].x * vertices[i].x + vertices[i].y * vertices[i].y);\n        if (vertexDist > maxDistance) {\n            maxDistance = vertexDist;\n            furthestVertexIndex = i;\n        }\n    }\n\n    return triangle[furthestVertexIndex];\n}","lastGenerated":"2024-05-18T02:49:25.836Z"}
{"_id":"findTriangleIntersectionPoint","projectName":"default","arguments":"tri1, tri2, outVector","specification":"Finds the intersection point between two triangles and stores it in the output vector. If no intersection is found, the function should return false.","needsGeneration":"true","jsdoc":"/**\n* Finds the intersection point of two triangles.\n* @function findTriangleIntersectionPoint\n* @param {Array<number>} tri1 - The first triangle, represented as an array of three points. Each point is an array of two numbers representing x and y coordinates.\n* @param {Array<number>} tri2 - The second triangle, represented as an array of three points. Each point is an array of two numbers representing x and y coordinates.\n* @param {Object} outVector - An object to store the intersection vector result in. This parameter will contain at least a 'point' property with the intersection point coordinates if an intersection exists.\n* @returns {boolean|Object} Returns false if either triangle is invalid or the normals of the triangles are parallel, otherwise returns an object containing the intersection point coordinates.\n*/","code":"function findTriangleIntersectionPoint(tri1, tri2, outVector) {\n    if (!validateTrianglePoints(tri1) || !validateTrianglePoints(tri2)) {\n        return false;\n    }\n    \n    const normalVec1 = calculateNormalVector(tri1);\n    const normalVec2 = calculateNormalVector(tri2);\n    \n    // Check if the normals are parallel, no intersection point.\n    if (areVectorsParallel(normalVec1, normalVec2)) {\n        return false;\n    }\n    \n    // Calculate direction vectors for intersection line and triangle centroids.\n    const dirVector = subtractPoints(getTriangleCentroid(tri1), getTriangleCentroid(tri2));\n    const centroidVec1 = calculatePointCentroid(tri1);\n    const centroidVec2 = calculatePointCentroid(tri2);\n    \n    // Find intersection point using the existing function.\n    return findIntersectionPoint({points: [centroidVec1, centroidVec2], directionVector: dirVector}, outVector);\n}","lastGenerated":"2024-05-18T02:35:14.806Z"}
{"_id":"findTriangleVertexIndexClosestToPoint","projectName":"default","arguments":"tri, point","specification":"Helper function for finding the index of the triangle vertex closest to the given point.","needsGeneration":"true","jsdoc":"/**\n* Finds the index of the vertex in a triangle that is closest to a given point.\n* @param {Vector} point - The point to which the distance to each vertex should be calculated.\n* @param {Array<Vector>} tri - An array of three vectors representing the vertices of the triangle.\n* @returns {number} - The index of the vertex in the triangle that is closest to the given point, or -1 if all distances are equal.\n*/","code":"function findTriangleVertexIndexClosestToPoint(point, tri) {\n    let vertices = [tri[0], tri[1], tri[2]];\n    let minDistanceSquared = Infinity;\n    let closestVertexIndex = -1;\n\n    for (let i = 0; i < vertices.length; i++) {\n        let vertexVector = subtractVectors(vertices[i], point);\n        let distanceSquared = dotProduct(vertexVector, vertexVector);\n        \n        if (distanceSquared < minDistanceSquared) {\n            minDistanceSquared = distanceSquared;\n            closestVertexIndex = i;\n        }\n    }\n\n    return closestVertexIndex;\n}","lastGenerated":"2024-05-18T02:45:27.993Z"}
{"_id":"nitializeNurbs","projectName":"default","arguments":"context","specification":"Initializes a new NURBS object with given rendering context.","jsdoc":"","code":"","errorLogs":"","lastGenerated":"","needsGeneration":"true"}
{"_id":"transformSurface","projectName":"default","arguments":"surface, matrix","specification":"Transforms the given surface by applying the specified transformation matrix to each vertex in its triangles.","needsGeneration":"true","jsdoc":"/**\n* Transforms the surface by applying a given transformation matrix to each triangle's points.\n* @param {Object} surface - The surface object containing an array of triangles.\n* @param {Array<Array>} transformMatrix - The transformation matrix to apply to each point in the triangles.\n* @returns {undefined} This function does not return a value but modifies the `surface` object directly.\n*/","code":"function transformSurface(surface, transformMatrix) {\n    surface.triangles.forEach(triangle => {\n        const newPoints = triangle.points.map(point => {\n            const pointVector = [point.x, point.y, point_z];\n            return { x: pointVector[0] * transformMatrix[0][0] + pointVector[1] * transformMatrix[1][0] + pointVector[2] * transformMatrix[2][0], y: pointVector[0] * transformMatrix[0][1] + pointVector[1] * transformMatrix[1][1] + pointVector[2] * transformMatrix[2][1], z: pointVector[0] * transformMatrix[0][2] + pointVector[1] * transformMatrix[1][2] + pointVector[2] * transformMatrix[2][2] };\n        });\n        triangle.points = newPoints;\n    });\n}","lastGenerated":"2024-05-18T02:36:46.717Z"}
